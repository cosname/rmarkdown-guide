[["index.html", "R Markdown 指南 前言 0.1 为什么要写这样一本书？ 0.2 本书是怎么写出来的？ 0.3 本书的创作理念是什么？ 0.4 本书主要有哪些内容？ 0.5 阅读本书时的注意事项", " R Markdown 指南 高春辉 王祎帆 闫求识 庄亮亮 杨晓龙 2022-12-22 前言 《R Markdown 权威指南》是第一本系统介绍 R Markdown 技术的中文图书。 0.1 为什么要写这样一本书？ R Markdown 是一个生产力工具。她基于流行的 R 语言，通过 knitr，rmarkdown， bookdown，tinytex 等一系列 R 软件包实现其功能。自 2012 年初 knitr 发布 以来，R Markdown 技术不断发展和丰富，已经成为当前制作动态文档、演示文稿、PDF 文档、建设网站，以及著书的主流工具之一。 基于 R Markdown 技术实现的动态文档，可以自行将文档内包含的代码编译执行，并将运行的结果（如绘图、控制台输出、LaTeX 数学公式、图片、源代码等）动态整合到最终文档中，最大程度上实现了技术文档的自动化。 与另一个流行的功能密切相关的生产力工具 Jupyter Notebook 相比，R Markdown 是 R 语言用户的第一选项。且R Markdown 在 RStudio 中具有原生支持，这大大降低了 学习的难度，提高了日常使用 R Markdown 的效率。另外，虽然R Markdown 基于 R 语言实现，但是她也支持在文档中使用 Python、Bash 等其它编程语言。 由于 R Markdown 具有上述种种优势，使其成为一种一旦掌握就能受益终身的通用技能。在学校，适合写作业，在职场，适合做工作汇报，在学术届，适合开展可重复研究等等。 现在网络上关于 R Markdown 的教程很多，但是对于一本图书而言，其系统、全面的优势是不可替代的。因此，在外文图书市场上有多部 R Markdown 技术书籍。其中，仅 Chapman &amp; Hall 出版社（https://www.crcpress.com/） 已经先后出版了”bookdown: Authoring Books and Technical Documents with R Markdown“、”R Markdown Cookbook“，”blogdown: Creating Websites with R Markdown“、”R Markdown: The Definitive Guide“等多部以 R Markdown 技术为主要介绍对象的书籍。除此之外， 基于 R Markdown 进行技术类图书写作也成为日益流行的创作样式，包括本书以及上述书籍在内都是依托 R Markdown 技术创建的。R 语言的经典教材和书籍（如”R for Data Science”等）也都是如此（https://www.bookdown.org/）。然而，在中文图书市场上，尚没有任何一部系统介绍 R Markdown 的图书。 于是，我们就决定写了这本书。 0.2 本书是怎么写出来的？ 本书是在谢益辉（@yihui）组织下，由高春辉、王祎帆、闫求识、庄亮亮、杨晓龙等共同创作完成的。书籍的创作主要参考了谢益辉所著的《R Markdown Cookbook》 和《R Markdown: The Definitive Guide》等资料。但是书籍创作过程并非严格的编译，而是结合了作者在这一领域的经验和认识。 作者的基本信息如下： 高春辉：博士，华中农业大学资源与环境学院副研究员； 王祎帆：中国人民大学统计学院博士生，统计之都成员， 《R Graphics Cookbook》 的译者； 闫求识：范德堡大学数据科学研究生； 庄亮亮：浙江工商大学理学统计博士生，微信公众号”庄闪闪的 R 语言手册”主编，统计之都成员； 杨晓龙：东京大学政治科学的本科三年级。 0.3 本书的创作理念是什么？ 本书的目的是让更多人受益于 R Markdown 技术。在写作的过程中，我们尽可能系统、全面地介绍 R Markdown 技术，并将最佳实践呈现给读者。实际上，本书就是用 R Markdown 进行写作的，在写作过程中我们遇到了很多问题，也新学习到了很多知识，这些都在各个章节有所体现，希望读者们能从中收益。 0.4 本书主要有哪些内容？ 本书章节设置如下： 第一部分：初识 R Markdown：本部分对 R Markdown 进行了简要介绍，本部分共包含两章： 第 1 章：R Markdown 概述：本章简单介绍 R Markdown 的发展历程（第 1.1 节），并以案例的形式介绍 R Markdown 的可能应用（第 1.2 节）； 第 2 章：R Markdown 的基础知识：本章从 R Markdown 的相关配置（第 2.1 节）、安装（第 ?? 节）、编译过程（第 2.4 节），到其基本元素（第 2.3 节）、页面设置布局（第 ?? 节）、文档元素（第 2.8 节）等方面，为 R Markdown 初学者提供其相关知识； 第二部分：基于 R Markdown 的应用：本部分介绍了基于 R Markdown 的基础应用，在学习完本部分，读者应能够使用 R Markdown 完成简单的学习或工作任务。本部分共包含两章： 第 3 章：使用 R Markdown 创建常用文档：本章介绍了如何使用 R Markdown 生成常用的 HTML（第 3.1 节）、PDF（第 3.2 节） 文档，甚至还包括如何生成 PPT（第 3.3 节）、Word（第 3.4 节） 以及新的文档输出格式（第 3.5 节）。在学完本章后，可以正常使用 R Markdown 开展日常的很多工作。 第 4 章：基于 R Markdown 工作与学习：本章给出了一些在工作和学习场合使用 R Markdown 完成一些可能会很繁琐的工作，包括发邮件（第 4.1 节）、制作 R 包（第 4.2 节）、制作简历（第 4.3 节）、写书或记笔记（第 4.4 节）以及制作网页（第 4.5 节），本章针对科研工作者还介绍了如何使用 R Markdown 制作科技论文的支撑材料（第 4.6 节），从而帮助读者更全面地了解 R Markdown 的强大之处； 第三部分：R Markdown 进阶操作：本部分为具有一定 R Markdown 使用经验的读者提供了更丰富的内容，从而帮助读者使用 R Markdown 大大增加日常学习工作的便捷性。本部分共包含三章： 第 5 章：使用 R Markdown 创建动态交互文档：本章介绍了 R Markdown 如何与 Shiny、Dashboards 结合，生成 Web 交互界面（第 5.1 节）以及交互式仪表盘（第 5.2 节），甚至在 R 包中也可以加入 R Markdown（第 5.3 节）。本章为第四章提供了补充。 第 6 章：R Markdown 的操作技巧：本章介绍了一些 R Markdown 的进阶操作技巧，可以在很大程度上优化使用者以及报告读者的体验，包括表格的一些特殊操作（第 6.1 节）、R Markdown 中的块选项（第 6.2 节）以及与其它语言的结合（第 6.3 节）。另外还有三节介绍了输出钩子（第 6.4 节）、缓存（第 6.5 节）以及其它的小技巧（第 6.6 节），供有一定使用经验的读者阅读。 第 7 章：使用 R Markdown 开展项目工作：本章的内容为第四章提供了更多的补充，并主要集中在项目管理（第 7.2 节）以及工作流（第 7.1 节）方面，可以帮助使用者在工作中大大提升工作效率。 0.5 阅读本书时的注意事项 本书在编写过程中包含了很多例子，为了使读者能够清晰地理解，本书并没有给出这些例子的编译结果，而是以源代码形式更直白地展现给读者，希望读者自行编译，也可以加深对这些例子的理解。当然，在必要的地方我们也会以各种形式给出例子的编译结果； 本书在编写过程中的一些内容可能并不能被所有读者轻易理解，本书在这些章节后面添加了“(*)”。跳过这些章节也不影响整体阅读，如果想要更详细了解 R Markdown，或想提升使用 R Markdown 的能力，可以进一步阅读这些章节； R Markdown 功能强大，可以实现很多功能，本书对于大多数常用功能进行了详细的解释，而对于一些更复杂的、受众相对较小的功能，本书仅对其进行了简要介绍，并提供了相应书籍甚至章节的名称以供读者查阅。 "],["rmarkdown-intro.html", "第 1 章 R Markdown概述 1.1 R Markdown 的渊源 1.2 以案例形式初识 R Markdown", " 第 1 章 R Markdown概述 1.1 R Markdown 的渊源 在过去的十多年间，R 语言发展的十分迅猛，这其中就包括了 R Markdown。这段往事可能要追溯到 2007 年。那时候，还在中国人民大学上学的谢益辉开始使用 Sweave，并沉迷于此无法自拔。不仅自己在写作业的时候尽可能的使用 Sweave，还持之以恒地向同学们兜售。Sweave 的命名是 S + weave，前者指的是 S 语言，这是 R 语言的前身，后者含义即“编织”。Sweave 之所以受到谢同学的追捧，正是因为它可以将某些东西编织起来——代码和代码执行后的结果。直到今天，Sweave 仍然是 RStudio 中从 Rnw 文档生成 PDF 的重要工具之一。 不过，因为 Sweave 中存在某些非常不好用的特性，所以对 Sweave 的痴迷也让谢益辉“深受其害”。这种痛苦和挣扎成为促使他开发 knitr (Xie 2022c) 的源动力1。显而易见，knitr 的编写从一开始就受 Sweave 影响，甚至命名的逻辑都是一样的。knitr 是 knit + R，前者的意思仍然是“编织”，后者则是 R 语言。而且 knitr 的读音听起来就跟另一个单词“neater”是一样的，给人一种更加灵巧的感觉！ 时至今日，knitr 是 CRAN 中依赖最多的包之一（https://blog.csdn.net/qq_18055167/article/details/104374971），与另外的 4600 多个包存在依赖、被依赖、建议安装等关系。rmarkdown 排第四，与 CRAN 中的其它软件包有超过 3600 种各类联系。 虽然 knitr 的编写受到 Sweave 影响，但模块化程度更高，扩展方便，支持文档类型也更多（Sweave 主要用于 LaTeX 文档）。与此同时，Sweave 中的一些优良特性也被 knitr 继承了下来，例如行内代码。从这个意义上说，Sweave 是 knitr 的“爸爸”。而 knitr 也其它一些包的“爸爸”，其中的一个就是 rmarkdown (Allaire, Xie, McPherson, et al. 2022)。knitr 包和 rmarkdown 包，以及其它一些扩展 R Markdown 功能的软件包，都是实现 R Markdown 功能的基础设施。最终，这些包一起成就了 R Markdown 的庞大生态系统。 回过头来看，当年谢益辉写 knitr 包只是为了更方便地完成自己的作业，而 knitr 可以写作业，也可以用来写数据分析报告，碰巧做数据分析的人都要写报告。在 knitr 之前有 Sweave，他用了好几年，刚开始觉得很兴奋，用着用着就到了四处碰壁的状态，觉得一个绝妙的想法不幸得到了一个蹩脚的实现。直到后来决定推倒重写算了。 在谈到开发经验时，他谈到： 不用看远方，就看你自身能感受到的非常痛苦的问题。如果你能解决自己的一个非常痛而且频繁出现的痛点，那么有相当大的概率你也会造福别人，从而产生重大影响。 解决的问题越基础越好，比如大家常用工作流程中必经的一步，这一步也许已经有现成解决方案了，但每个月总有那么三十来天让你对这个解决方案感到不满。越基础的问题，影响的人群就越广。 —— 谢益辉（2018） 2021 年，在巴西举行的 R-Day 会议上，谢益辉曾经官方解释过这段历史，感兴趣的读者不妨去看一下“Knitr 亲述历史”：https://slides.yihui.org/2021-Brazilian-R-Day.html。 1.1.1 R Markdown 与文学化编程 初学者可能会认为 rmarkdown 软件包就是 R Markdown 的全部，但是事实并非如此。R Markdown 是文学化编程的一种实现方式，她包含了一系列目的各异又相互联系的工具和软件包，而本书只能介绍其中有限的几个。文学化编程就是前面刚刚提及的一个绝妙的想法，那就是高德纳（Knuth, Donald E.）在 1984 年提出的编程方法，旨在取代结构化编程范型。文学编程范型让程序员用自己思维内在的逻辑和流程所要求的顺序开发程序，而且用人类日常使用的语言写出来，就好像一篇文章一样。 文学化编程本来是为了编程和写文档两个目的而生的，想法看起来很好，但同时完成这两件事情绝非易事。编程通常就是代码加注释，大家都熟悉这个套路，没有人在代码之间长篇大论写文档来解释这里的代码在干什么；文档通常也是相对独立于代码的。嵌入了代码的文档或嵌入了文档的代码对于一般读者来说都不易读。这么看来，文学化编程并非一个很好的点子。 然而，文学化编程范式却无意间影响了可重复的科学研究。它不适合单纯写代码，但非常适合写数据分析报告。虽然数据分析的过程往往是一团糟，但结果经常是图文并茂，这也就是文学化编程可以充分发挥实力的地方。代码嵌入文档中的目的并非为了单纯的编译，而是更好的展示分析结果（合理使用文字与图表等）。代码和文档结合之后，也便于动态的调整输出结果2。 1.2 以案例形式初识 R Markdown rmarkdown (Allaire, Xie, McPherson, et al. 2022) 一个是 R 语言的扩展包，提供了以 .Rmd 文件格式为中心的数据科学写作框架。它的核心思想是创作包含文本和代码的动态文档，让数据与叙事并进，最终提供易重复，易共享的数据分析环境。 本章从 R Markdown 的应用开始，遴选了不同场合 R Markdown 的用例和解决的问题。包括： 撰写数据分析报告 用交互笔记本记录学习过程 发表电子书和长篇文档 设计数据驱动的个人简历 建立个人网站和博客 创作演示文档和交互报表。 用动态文档自动化报告发布 最后，本书回顾了 R Markdown 的技术渊源和发展。 1.2.1 数据分析报告 从诞生开始，R 便是一门致力于交互式统计与数据分析的语言。而 R 用户的需求也自然而然地着重于数据分析与分析报告的生成，这也是 R Markdown 最常见的用途。 R Markdown 支持 HTML, PDF, Word, EPUB 等多种输出格式，以及与各种输出格式配套且开箱即用的主题系统。用户可以将工作重心放在内容创作上，即在写作完成后只需一键输出，让 R Markdown 的自动化的编译机制代劳形式上的调整。例如，只需要几行代码，同一个 R Markdown 文档就可以生成图 1.1 中 HTML，PDF 和 Word 三种格式的文档。 图 1.1: 同一个 R Markdown 文档可以生成多种格式的输出 除了多样的输出格式外，R Markdown 驱动的数据分析报告还解决了很多数据分析报告写作中的痛点： 之前在使用 R 或者其他数据分析工具时，经常需要在 Word 里写结论，在脚本里敲代码，在图表区生成图，将它们复制粘贴到一起后，还要操心格式问题，有没有什么自动化的解决方案？ 我的日常工作包含大量重复性高的数据分析与产出，如何创作一篇参数化、可复用的文档模板，从此可以在更新数据后系统性的产出结论与图表？ 如何确保分析过程和结论是可复现的，即别人是否能利用同样的数据得到相同的结论？ 我不了解网页开发，如何在报告中插入可交互的图表和网页元素？ 同时，R Markdown 还为 R 语言之外的几十种编程语言提供了一定程度的支持，例如 Python，C++，Julia，Bash，SQL 等，这意味着用户可以在一篇报告中混用多种编程语言。例如，Python 是数据分析的另一大利器，在 reticulate 包 (Ushey, Allaire, and Tang 2022) 的帮助下，用户可以在 R Markdown 文档中流畅地并用 Python 和 R3。在下面的例子中，本书先用 R 导入数据并作数据预处理，随后将 R 中的数据传递到 Python 环境中，生成 pandas 格式的 DataFrame, 并用 seaborn 包进行可视化。 # R 部分: 导入和预处理美国各州犯罪数据 arrests &lt;- datasets::USArrests arrests$State &lt;- rownames(arrests) # Python 部分，导入 R 数据，提取谋杀率最高的 10 个州，并用 seaborn 包作柱形图 import pandas as pd import seaborn as sns top_states = r.arrests\\ .sort_values([&quot;Murder&quot;], ascending = False)\\ .head(10) sns.barplot(x = &quot;Murder&quot;, y = &quot;State&quot;, data = top_states) 本书第 6.3 节详细讨论了如何在 R Markdown 中结合其他编程语言。 创作更大篇幅的文档或书籍时，仅用一个 R Markdown 文件组织全部内容难以维护。bookdown 包提供了更适于长篇文档和书籍的输出格式，用户可以用多个 R Markdown 文档创作一本书的不同章节。此外，bookdown 包还提供了交叉引用，定理和公式环境，文献引用等扩展功能。bookdown 的输出结果非常适合用于制作在线教材与讲义，例如北京大学李东风老师的《R 语言教程》，本书的在线版本也是用 bookdown 生成的。bookdown.org 汇集了更多 bookdown 制作的在线书籍。 图 1.2: 使用 bookdown 制作的中文图书范例, 一个章节对应一个 R Markdown 文档 在学术报告或论文的撰写中，用户可能对格式有更细致的要求。越来越多的包提供了易用的 R Markdown 模板，为用户免去了繁杂的手动格式调整，编译后即可直接投稿。rticles 包 (Allaire, Xie, Dervieux, et al. 2022) 提供了很多期刊和出版商的模板文档，例如 R Journals 和 Journals of Statistical Software。中文用户可能较常用 rticles 包提供的 CTeX 输出格式，它让 R Markdown 输出的 PDF 可以正常显示中文字符。 1.2.2 交互笔记本 rmarkdown 和 bookdown 等包支持运行代码，插入图片，公式，交叉引用和参考文献等常见元素，还可以组合长篇文档。因此、统计，数据科学、计算机科学乃至社会科学等领域的学生，研究人员和爱好者们时常使用 R Markdown 为首选的笔记本格式。 图 1.3: RStudio 支持实时预览 R Markdown 笔记本格式 如图 1.3 所示，R Markdown 笔记本支持运行代码，插入运行结果，添加文本样式和批注等功能。R Markdown 的交互特性让学习记录变得十分自然：用户通常添加一段代码，运行后得到预料之中/之外的可视化结果，随后在下面的多个代码块中反复调整某个参数，直至得到想要的结果。在此过程中用户常常会发现更多相关的包或代码，写下对不同代码的总结，并链接网络上他人的用例，甚至开始撰写自动化脚本。最后，用户可以一键生成包含了这一系列思考和学习过程的 HTML 或 PDF 精美文档。图 1.3 是一个 PDF 笔记文档示例。 图 1.4: 用 R Markdown 生成 PDF 学习笔记 即便用户的工作不涉及数据分析或代码运行，使用 R Markdown 作为笔记软件也有许多好处。用户可以流畅地使用版本控制工具，管理笔记依赖的数据，图片的资源等。用户可以将长篇笔记拆分为多个源文档，用纯文本文件管理输出设置，形成清晰的项目结构。RPubs 和 bookdown 等平台提供了免费的 R Markdown 文档发布服务，以此来发布自己的笔记与心得，便利他人和未来的自己。 1.2.3 个人简历 一些 R Markdown 扩展包提供了适用于个人简历（resume, CV）的输出格式。例如基于 pagedown 包 (R-pagedown?) 的简历模板，和 vitae 提供的 CV 模板。 除了提供模板外， R Markdown 还能使简历变得更加以“数据驱动 (Data driven)”。datadrivencv 包把简历中的各项教育背景，工作经历和项目经验等视作电子表格中的一条记录，用户仅需维护这张数据表，并由 R Markdown 来负责简历的格式。用户还可以插入 R 代码生成的交互图表，使简历可以“动”起来。图 1.5 是 datadrivencv 包的作者 Nick Strayer 结合 pagedown 包制作的个人简历。 图 1.5: Nick Strayer用 datadrivencv 和 pagedown 包制作的 CV 示意 1.2.4 网站 rmarkdown 包支持生成简单的静态网页。用户通过 YAML 配置文件定义网站的标题，导航栏，页面结构等元数据，而后创建数个 R Markdown 文档组成网站的不同 HTML 页面。 图 1.6: 用 R Markdown 创建网站 rmarkdown 包内置的网站功能较为简单。blogdown 包 (R-blogdown?) 提供了更复杂的网站功能，它使用了开源的网站工具：Hugo。Hugo 是目前速度最快，最受欢迎的静态网站生成器之一。一般用户通常需要在命令行调用 Hugo，不过作为幸福的 R 用户，读者可以照常写作 R Markdown 文档，随后调用 blogdown 包中封装好的函数间接地使用 Hugo，最后生成网站。 图 1.7: blogdown 包可以使用 Hugo 主题 包如其名，对个人用户来说，blogdown 特别适合制作博客类的个人网站。读者可以展示个人项目，存放简历，归档学习笔记和心得，求职时为自己添加一份切实的筹码。rbind 还提供了免费的域名服务。除此之外，用户还可以用 blogdown 制作其他类型的网站，例如软件文档，课程主页等。Hugo 的主题列表 列出了丰富的网站模板，其中大部分可以在 blogdown 中一键生成。最后，本书提供几个不同主题的 blogdown 网站样例以供读者参考： Rob J Hyndman 的个人网站 Alison Hill 的个人网站 《现代统计图形》的图书主页 1.2.5 幻灯片 R Markdown 和扩展包支持输出多种常见的幻灯片格式，例如 PowerPoint，Beamer，isoslides 和 Slidy 等。除此之外，本书还特别推荐 xaringan (Xie 2022e) 包。xaringan 基于 JavaScript 中的 remark.js 库设计了灵活的输出方案。对 CSS 和 JavaScript 语法有一定了解的读者还可以基于默认模板自定义出复杂的演示文档。xaringanExtra 包为 xaringan 幻灯片提供了更多有趣的增强插件。读者可以在 https://slides.yihui.org/xaringan/#1 和 https://pkg.garrickadenbuie.com/xaringanExtra/#/ 看到更多示例。 图 1.8: xaringan 提供的幻灯片模板示意 1.2.6 交互报表 报表是一种常见的商业报告形式，用 R Markdown 开发报表不仅可以将数据分析过程与商业结论结合地在一起，还能帮助用户充分发挥 R 语言强大的可视化功能。基于 HTML 格式的 flexdashboard(Iannone, Allaire, and Borges 2020) 包提供了这类报表的模板，还内置了一些常用报表元素的 HTML 组件， 例如指标盒，增长仪表，导航栏等。 图 1.9: 用 flexdashboard 包制作的仪表板 除去开发上的便捷易用外，R Markdown 生态还提供了丰富的测试，部署，自动化和持续集成功能，加速并确保用户的数据产品投入生产的效率。 1.2.7 动态文档 除了直接使用编辑器写作外，用户还可以调用编程 API rmarkdown::render() 生成文档，并动态地设置文档使用的各项参数。这让用户可以自动化、参数化地批量生成文档。一个典型场景是：数据库每日更新全国销售数据，而数据分析师用自动化脚本控制 R Markdown 来根据不同地区与职务来生成多个更有针对性的报表。这样的动态文档是通过参数实现的，也就是说用户在源文档中使用参数的名字，而不是具体的数据来进行定义。随后在脚本中通过 rmarkdown::render() 动态来传入当日的数据。 图 1.10: 根据 Shiny 输入动态生成 R Markdown 文档 图 1.10 是一个结合 Shiny 包动态生成 R Markdown 输出文档的例子。R Markdown 允许用户上传某个数据集，挑选需要数据清理的维度，随后把清理结果动态地传递给 rmarkdonw::render()，从而生成右侧截图所示的输出文档。 参考文献 "],["rmarkdown-base.html", "第 2 章 R Markdown 的基础知识 2.1 安装 RStudio 2.2 安装 rmarkdown 包 2.3 R Markdown 的基本元素 2.4 R Markdown 的编译过程和组成元素 2.5 YAML 头部 2.6 Markdown 语法 2.7 代码块和行内代码 2.8 文档元素 2.9 RStudio 图形化编辑器", " 第 2 章 R Markdown 的基础知识 本节首先介绍运行 R Markdown 的软件配置，并带领读者编译第一个 R Markdown 源文档，生成 HTML 和 PDF 两种格式。随后探讨了 R Markdown 的编译机制。最后介绍了各类通用的文档元素。 2.1 安装 RStudio 本书推荐读者使用 RStudio 编辑器作为开发环境。RStudio 编辑器是 R 社区中最流行的编辑器之一，并集成了许多便利 R Markdown 文档书写的功能，例如简单的图形化按钮，在线预览，视觉编辑器等。RStudio 编辑器的免费开源版本可从 https://www.rstudio.com/products/rstudio/ 下载，英文名称为 RStudio Desktop Open Source Edition。 安装完成后，打开 RStudio 编辑器，基本界面如图 2.1 所示。 图 2.1: RStudio 编辑器的基本界面 RStudio 编辑器默认将工作区域分为三个面板，其中左侧为为 R 的控制台 (console)，用于交互式的代码输入和输出；中间为编辑器 (editor)。右上包括当前 R 进程的环境，历史和连接等信息，右下包括文件浏览器，图和帮助文档等。读者可以通过菜单栏中的 Tools -&gt; Global Options -&gt; Pane Layout 调整面板的排列。 2.2 安装 rmarkdown 包 R Markdown 文档的编译依赖于同名的 rmarkdown R 包，在控制台中输入如下命令安装：4 install.packages(&quot;rmarkdown&quot;) 安装完成后，在 RStudio 的菜单栏中选择 File -&gt; New File -&gt; R Markdown，点击 OK 后， 即可创建一个新的 R Markdown 文档模版，如图 2.2 所示。 图 2.2: 在 RStudio 中创建 R Markdown 文档 随后，RStudio 创建了一个 untitled.Rmd 文件，如图 2.3 所示。 图 2.3: RStudio 中的 R Markdown 编辑器 .Rmd 文件是 R Markdown 的源文档，是撰写 R Markdown 文档的主要工作区域，一个文档的内容、格式、标题等都在这里定义，本书后续章节对文本和代码的编辑均是围绕类似这样的源文档展开的。 为了验证 rmarkdown 包及 RStudio 配置成功，可以在 RStudio 中打开 untitled.Rmd 文件，然后点击右上角的 Knit 按钮，即可在 RStudio 中看到编译后的文档，如图 2.4 所示。 图 2.4: 源文档上方的编译按钮 图 2.5: untitled.Rmd 文件输出的 HTML 文档 untitled.html 文件是 untitled.Rmd 源文档的编译结果，称为输出文档。HTML 是 R Markdown 文档的默认输出格式，后续章节介绍了其他输出格式的使用方法。 除了 RStudio 中的 Knit 按钮，读者还可以在 RStudio 的控制台中输入如下命令，对 R Markdown 文档进行编译： rmarkdown::render(&quot;untitled.Rmd&quot;) rmarkdown::render() 函数是编译 R Markdown 文档的重要工具，也是 Knit 按钮背后调用的函数。读者可以为 render() 提供各类参数自定义各项输出设置，将在后续章节中介绍。 2.2.1 安装 TinyTex 要想使用 R Markdown 输出 PDF 格式的文档，必须事先安装 LaTeX。LaTeX 有很多发行版，如 MiKTex，MacTeX， TeX Live 等，建议 R Markdown 的用户使用 TinyTeX。它是一个瘦身版的 TeX Live，去掉了 TeX Live 中对普通用户毫无用处的源代码和文档，可以通过 tinytex (Xie 2022d) R 包安装。 图 2.6: TinyTex 是一个瘦身版的 TeX Live 要安装 TinyTeX，只需要在 R 语言终端输入两条命令即可5。 # 安装 tinytex install.packages(&quot;tinytex&quot;) # 安装 TinyTex 套件 tinytex::install_tinytex() 如果 TinyTeX 下载速度慢，或在 R 里面下载不完整，那么可以用浏览器或其它下载工具直接下载：https://github.com/yihui/tinytex-releases/releases 然后把下载的文件路径传给安装函数，比如： # 假设下载文件所在的位置是 ~/Downloads/TinyTeX-v2021.01.zip tinytex:::install_prebuilt(&quot;~/Downloads/TinyTeX-v2021.01.zip&quot;) 运行完毕后，可以尝试编译 PDF 输出文档以验证 TinyTex 安装成功。以先前的 untitled.Rmd 为例，将文件的头部替换为： --- title: &quot;Untitled&quot; output: pdf_document date: &quot;2022-10-23&quot; --- 随后点击 Knit 按钮，生成的 PDF 输出文档如图 2.7 所示。 图 2.7: untitled.Rmd 生成的 PDF 文档 2.2.1.1 安装 LaTeX 组件 从 rmarkdown 1.9 版本开始，输出 PDF 文档时会调用 TinyTeX，进而使用 LaTeX 包。因此，对 R Markdown 用户来说，编译 PDF 时出错的最常见原因是缺失某些 LaTeX 包。 LaTeX 包（也被称为 “package”）是 LaTeX 的组件，数目非常多，可以用来扩展 LaTeX 的功能。tinytex::install_tinytex() 默认只安装了必须的一些组件，在实际使用过程中经常会出现缺少组件的错误。 如果知道包的名称，那么可以直接使用下面的命令安装。这里值得注意的是，国内用户通常需要额外设定 LaTeX 软件仓库的位置。下面的例子使用了清华大学的 TeX Live 镜像。 # 安装需要的 LaTeX 组件 tinytex::tlmgr_repo(url = &quot;https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet&quot;) tinytex::tlmgr_install(c(&quot;pgf&quot;, &quot;preview&quot;, &quot;xcolor&quot;)) 如果不知道包的名称也没有关系，tinytex 也提供了相应的函数来帮助用户从报错信息中找到解决方法。tinytex::parse_install() 提供两种方法，第一种是通过准确的错误提示，第二种是通过分析 log 日志文件。如果 log 文件过长或者找不到具体提示信息，还可以使用第二种办法。 # 假如有相关报错信息 &quot;! LaTeX Error: File `preview.sty&#39; not found.&quot; tinytex::parse_install(text = &quot;! LaTeX Error: File `preview.sty&#39; not found.&quot;) # 假如错误 log 名为 tex.log tinytex::parse_install(log = &quot;tex.log&quot;) 2.2.2 安装 Git (*) 了解 Git 和 Github 的使用可以帮助 R Markdown 用户分享代码和输出结果，并且可以方便地与他人协作。 Git 是一个分布式版本控制软件，最初由 Linus Torvalds 开发6，于 2005 年以 GPL 协议发布。Git 软件可以在其官方网站下载（https://git-scm.com/downloads）。为了与 Git 配合使用，通常还需要注册一个支持 Git 软件仓库托管的配套网站，比较流行网站服务包括 GitHub（https://github.com），Gitee（https://gitee.com/）等。在这里以 GitHub 为例进行说明。 图 2.8: 使用 Git 和 GitHub 可以提高团队协作的效率 2.2.2.1 配置 Git 和 GitHub Windows 系统下 7，安装完 Git 客户端之后，鼠标右键菜单中会多出来两个命令：“Git GUI Here”和”Git Bash Here”。前者打开一个图形界面，后者打开一个终端，通过这两个命令都可以进入 Git。 首先需要配置 Git 的用户信息，下面是终端命令： # 全局配置 $ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;xxx@xxx.xxx&quot; # 本地配置 $ git config user.name &quot;your name&quot; # 查看配置 $ git config --list # 查看指定项 $ git config user.name 为了能够使用 GitHub 提供的服务，需要先注册一个账号（https://github.com/signup）。 2.2.2.2 使用 Git Git 常用的命令有下面几个： git init sample 在当前目录新建一个”sample”目录，在目录中启用 Git 版本控制系统。 git clone https://github.com/cosname/rmarkdown-guide.git 从 GitHub 克隆一个软件仓库到当前目录。这将在当前目录新建一个”rmarkdown-guide”文件夹，其中包含所有文件和版本历史。 git status 显示当前 Git 仓库的状态。如果有修改，新建，删除等操作，将会自动列举出来。 git add newfile.Rmd newfile.Rmd 是一个新建的文件，其中有一些新增的代码。该命令将其加入 Git 追踪的文件清单中。 git commit 或者 git commit -a 这个命令将执行一次 Commit 操作，系统会打开默认的文本编辑器，以填写本次 Commit 操作涉及的工作内容。 git push 将本地仓库的修改推送到远程仓库中去。要执行该命令，本地仓库需要关联一个远程仓库，并且用户对该远程仓库具有修改权限（使用 git remote -v 查看本地仓库关联的远程仓库地址）。 git pull 将本地仓库的内容与远程仓库同步（这是远程仓库的文件比本地仓库的文件版本新）。 2.2.2.3 配置 Git 远程仓库的 SSH 认证 SSH 密钥是成对的，包括公钥和私钥；公钥登记到 GitHub 网站，私钥存储在本地计算机（私有）。密钥在本地生成。点击鼠标右键，选择”Git Bash Here”，输入下列命令将生成一对 SSH 密钥。 默认情况下，私钥保存在”~/.ssh/id_rsa“文件中，公钥保存在”~/.ssh/id_rsa.pub”文件中 （在 Windows 系统中的 Git bash 终端下，~ 代表用户的家目录）。 ssh-keygen cat ./.ssh/id_rsa.pub 复制这个公钥的全部内容，进入”GitHub - Setting - SSH and GPG keys”，选择”New SSH key”，将公钥粘贴进去，点击”Add SSH key”，即可完成公钥添加。 这样，以后就调用 “Git Bash Here” 时，便会自动提供私钥认证，不需要输入用户名和密码了。 2.2.2.4 使用 GitHub 在 GitHub 网站中，通常主要进行下列操作： 创建一个新的软件仓库； 点击 GitHub 右上角的 “+”，选择 “Create a new repository”，按照提示操作即可。这步操作其实相当于在 GitHub 服务器上新建了一个目录。目录名称是 Repository Name。目录的路径就是 &lt;username&gt;/&lt;repository_name&gt;。对应的网址（绝对路径）是 https://github.com/&lt;username&gt;/&lt;repository_name&gt;。对应的 Git 地址是 git://git@github.com/&lt;username&gt;/&lt;repository_name&gt;.git。对应的 SSH 地址是 ssh://git@github.com/&lt;username&gt;/&lt;repository_name&gt;.git。 从其他用户的软件仓库中新建一个分支，即 Fork； 在 GitHub 项目网页中，点击”Fork”即可。 为其他用户的软件仓库中贡献代码，即 Pull Request； 因为自己不具备其他用户拥有的软件仓库的编辑权限，所以无法直接通过 push 的方法提交修改。在这种情况下，用户可以首先在 GitHub 上 Fork 其他用户的软件仓库，并在自己的 Fork 中做相应修改后，通过 Pull Request 的方法提交给其他用户，经过管理员审核后，即可合并到对方的软件仓库中去。这也是团队协作共同维护一个项目时的常规操作。 第 7.2.8 节还将介绍使用 GitHub Actions 实现自动化完成持续性集成（Continuous Integration，CI）的功能。 2.3 R Markdown 的基本元素 第 2.2 节中，读者创建了 untitled.Rmd 源文件，这是 rmarkdown 自带的一个文档模版，目前读者不需要修改其中的内容，untitled.Rmd 原内容如下： --- title: &quot;Untitled&quot; output: html_document --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` ## R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: ```{r cars} summary(cars) ``` ## Including Plots You can also embed plots, for example: ```{r pressure, echo=FALSE} plot(pressure) ``` Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot. 这个文件中包含了 R Markdown 文档中的三个基本元素，从上到下包括： YAML 元数据: 由一对三个减号 (---) 包围成的键值对，在 untitled.Rmd 中为 --- title: &quot;Untitled&quot; output: html_document --- 元数据用 YAML 语法以 key: value 的形式指定了源文档的各类输出设置，不涉及具体的正文内容。这里 untitled.Rmd 的元数据做了两项设置，title: \"Untitled\" 设定了文档标题，而 output: html_document 设定了输出格式为 HTML。 代码块：第二个 --- 后进入文档的正式内容。首先，是由一对三个反引号 (```) 所包围的代码块 8，这个代码块的内容是： knitr::opts_chunk$set(echo = TRUE) 这是一个 R 代码块，因为```{ 后是 r，读者还可以将其替换为 ```{python， ```{bash 等以指定代码块的语言类型。语言名称的后面还可以附上代码块选项。代码块选项与代码块的关系就如同 YAML 元数据之于整个文档一样，用于指定该代码块的运行和输出设置。这里，setup 是代码块的标签，include=FALSE 指定了这个代码块的内容不会显示在输出中，即隐藏 knitr::opts_chunk$set(echo = TRUE) 这一行，第 2.7 节解释了它的含义。 Markdown 文本：代码块之后是一段文字内容，内容如下： ## R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: 这段内容使用了 Markdown 语法。Markdown 语法提供了一系列简单的标记符号，如 #，*，- 等，它们可以在输出文档中生成标题、列表、图片和脚注等常见元素，满足简单的样式需求。使用 Markdown 既可以让作者免于复杂的排版之苦，也提供了一种格式标记的统一中介。本书的第 2.6 节详细介绍了 Markdown 语法。简而言之，R Markdown 在遇到这些符号时会将相关的文本转换成对应的格式。这里 ## R Markdown 是一个二级标题，**Knit** 是一个加粗的文本，&lt;http://rmarkdown.rstudio.com&gt; 是一个链接。 这段 Markdown 文本下面是另外一个 R 代码块： ```{r cars} summary(cars) ``` 这个 R 代码块的标签是 cars，内容是 summary(cars)。编译过程中，R Markdown 会运行这段代码内容，并将生成的结果插入到该段代码的下方，这个结果可以是文本，也可以是图片，表格等，例如第三个代码块 plot(pressure) 就生成了图片。 untitle.Rmd 的剩余内容是类似的 Markdown 文本和代码块。 2.4 R Markdown 的编译过程和组成元素 点击 Knit 按钮或调用 rmarkdown::render() 函数后，R 会启动一个新的进程，将源文档转换为输出文档。 之前提到过，Knit 按钮本质上就是对 rmarkdown 包中 render() 函数的封装。因此，理解 R Markdown 的编译过程就是理解 render() 调用了什么方法和工具完成了怎样的文档转换。 首先，render() 函数会读取 YAML 元数据，并根据它们设置的选项来调整输出文档的配置。 YAML 元数据读取完毕后，进入文档的正文部分。R Markdown 首先提取正文中的所有代码块，按顺序运行其中的代码，将运行结果插入到代码块的下方。代码的执行过程在底层由 knitr (Xie 2022c) 包控制，它将代码的运行结果置于合适的位置。之前笼统说的 “R Markdown 运行代码” 实质上就是 knitr 的工作。这一步结束后，knitr 生成了临时性的 .md 文件。包含了 Markdown 文本和代码运行结果。例如，untitled.Rmd 被转换为 untitled.md，内容为： --- title: &quot;Untitled&quot; output: html_document: keep_md: true --- ## R Markdown This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: ```r summary(cars) ``` ``` ## speed dist ## Min. : 4.0 Min. : 2 ## 1st Qu.:12.0 1st Qu.: 26 ## Median :15.0 Median : 36 ## Mean :15.4 Mean : 43 ## 3rd Qu.:19.0 3rd Qu.: 56 ## Max. :25.0 Max. :120 ``` ## Including Plots You can also embed plots, for example: ![](Untitled_files/figure-html/pressure-1.png) Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot. 这里的 .md 文件是一个纯文本文件，在内容上已经和最后的输出文档一致，但还欠缺最后的格式转换。接下来，R Markdown 会调用 Pandoc 软件负责下一步的转换。Pandoc 是一个开源的命令行程序，可以完成多种文档格式之间的互相转换，已经随 RStudio 下载安装好。这里，Pandoc 将 .md 文件 转换为 YAML 头部中 output 对应的输出格式。Pandoc 还读取了其他 YAML 头部中的设定，一些被插入文档内容 (如 title)，另一些选项则作为命令行参数，对转换过程做特定的控制。用以下代码验证 Pandoc 的安装版本： rmarkdown::pandoc_available() ## [1] TRUE rmarkdown::pandoc_version() ## [1] &#39;2.19.2&#39; 作为总结，对于 HTML 格式，rmarkdown::render = knitr + Pandoc。 PDF 输出格式还有额外的一步： tinytex 包或其他 LaTeX 发行版编译 Pandoc 生成的 .tex 文件，生成 PDF 文档。 实际写作中，R Markdown 用户几乎不需要直接与 knitr 或 Pandoc 打交道，大部分配置可以通过 YAML 元数据完成，但理解它们在 R Markdown 编译中的角色有利于在编译失败时更好地排错，同时为掌握更进阶的排版技巧打好基础。 图 2.9 概括了 R Markdown 完成以上工作的流程。 图 2.9: R Markdown 的编译过程 https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-process.html 了解完 R Markdown 的编译过程后，下面三节深入介绍了 R Markdown 源文档中的三种元素：YAML 头部，Markdown 文本和代码块。 2.5 YAML 头部 YAML 元数据中的每一个域 (field) 都定义了输出的一个方面，其中最重要的一个域是 output 所指定的输出格式，output 选项的值可以是 html_document、pdf_document、word_document 等，这些值对应了不同的输出格式，实质上都是 rmarkdown 包中的函数，例如 html_document 对应的函数是 rmarkdown::html_document()。下面是所有 rmarkdown 包中定义的输出格式： beamer_presentation context_document github_document html_document ioslides_presentation latex_document md_document odt_document pdf_document powerpoint_presentation rtf_document slidy_presentation word_document 作者还可以进一步设置某个输出格式的二级选项，例如： --- output: html_document: toc: true toc_float: true theme: united --- 可用的二级选项可以在对应的输出函数中找到，使用 ?rmarkdown::html_document 可以查看 html_document() 的文档，其中的每一个参数都是可在 YAML 头部中设置的二级选项。 output 选项的值还可以是一个列表，这样就可以同时生成多个文档。例如，下面的代码会同时生成 PDF、Word 和 HTML 文档。 output: html_document: toc: true toc_float: true code_folding: hide pdf_document: toc: true number_sections: true keep_tex: true latex_engine: xelatex tufte::tufte_handout: default 上面的文档有三种可选的输出格式，html_document，pdf_document 和 tufte_html。 在 html_document 格式中，toc: true 指定自动生成目录, toc_float: true 设置目录的显示方式为浮动侧边栏 (默认标题会固定在正式文字内容之前), code_folding: hide 可以折叠所有代码块，但读者可以在每个代码块右上角的选项卡展开内容，这是一个 HTML 输出格式特有的选项。9 pdf_document 格式同样设置了生成目录，number_sections: true 自动生成章节编号，keep_tex: true 保留 Pandoc 生成的 .tex 文件。latex_engine: xelatex 设置编译引擎为 XeLaTeX (默认为 pdflatex), 引擎设置对正确显示中文字体非常重要。 tufte::tufte_handout 是 rmarkdown 包之外的一个扩展输出格式：用户可以根据自己的需求定制输出格式，不限于 rmarkdown 包内置的格式。tufte::tufte_handout 是 tufte 包中的一个函数，模仿了统计学家 Edward Tufte 以及物理学家费曼的教科书的风格。举一反三，如果需要使用 foo 包中的输出格式 bar，它定义在 bar_document 中，那么 output 应该设置为 output: foo::bar_document，这里的 default 关键字表示使用默认的二级设置。使用多个输出格式时，没有二级选项的输出格式需要使用 default。下面的 YAML 元数据是不合法的： output: pdf_document: toc: true html_document # 这里需要 default 关键字 除了 output 之外，常见的 YAML 域包括 title (标题)、author (作者)、date (日期)、subtitle (副标题) 和 abstract (摘要) 等，它们的用法很简单，在 : 指定对应的值即可，参见下面的源文档： --- title: &#39;常用 YAML 选项&#39; date: &quot;2020-08-16&quot; author: - 张三 - 李四 output: rticles::ctex: toc: true subtitle: &#39;以 PDF 输出为例&#39; keywords: - 中文 - R Markdown abstract: &gt; 统计之都（Capital of Statistics, COS）论坛是一个自由探讨统计学和数据科学的平台。 欢迎对统计学、机器学习、数据分析、统计软件、可视化等领域感兴趣的朋友在此交流切磋。 首次使用论坛请阅读新手须知。 fontsize: &quot;10pt&quot; papersize: &quot;a5&quot; geometry: &quot;margin=1in&quot; biblio-title: 参考文献 bibliography: skeleton.bib link-citations: yes documentclass: ctexart --- # 第一部分 张三写的。 # 第二部分 李四写的。 这里，&gt; 可以让多行的字符串在输出中按一行输出，起到相反作用的是 | 号，它保留字符串中的换行符。fontsize, papersize, geometry, biblio-title, bibliography,link-citations, documentclass 等是生成 PDF 文档的通用选项，所以它们不是写在某个输出格式下面 (pdf_document 只是能生成 PDF 文档的格式之一)，而是顶层的元数据。类似这样的选项还有很多，读者可以在需要时自行搜索他们的用法。非 PDF 输出格式则会无视它们。 输出结果如 2.10 所示。 图 2.10: YAML 元数据对应的 PDF 输出 ymlthis 包提供了一个在 R Markdown 中插入 YAML 数据的图形化界面，可以在 RStudio 菜单栏的 Tools -&gt; Addins -&gt; Browse Addins 中启动，如图 2.11 所示。 图 2.11: ymlthis 包提供图形化输入 YAML 元数据的插件 2.6 Markdown 语法 Markdown 标记语言由 John Gruber 于 2004 年创建，以易读，可移植，跨平台等优势成为最受欢迎的技术写作工具之一。借助 Markdown，作者可以在纯文本文档中用特殊的标记符号表示格式，例如用井号 # 表示标题，用 * 星号表示加粗等。这样的统一中介使作者不必逐个为特定输出格式设置排版方案。 2.6.1 简单段内格式 Markdown 提供了很多简单的段内格式化 (inline formatting) 方法，一些基础的格式列举如下： 粗体: 前后各添加两个星号 **。如 **加粗** 在输出文档中变为 加粗 斜体：前后各添加一个星号 *。如 *斜体* 变为 斜体 代码样式: 前后各添加一个反引号 `。如 `代码` 变为 代码。如果内容本身有反引号，可以在两边添加同等数量的反引号，如 ``x`` 变为 `x` 用 &lt;链接地址&gt; 插入一个可点击的链接，如 &lt;https://example.com&gt; 显示为 https://example.com。带文字的超链接格式为： [显示文字](网页链接) 例如，[R Markdown 权威指南](https://bookdown.org/yihui/rmarkdown/) 显示为 R Markdown 权威指南。 2.6.2 换行 要在 Markdown 中换行，需在上一段的末尾添加两个或以上空格 (仅一个回车键不能换行)。例如： R is a free software environment for statistical computing and graphics. It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS. 生成: R is a free software environment for statistical computing and graphics. It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS. 更简单的办法是在两行间添加一个空行： R is a free software environment for statistical computing and graphics. It compiles and runs on a wide variety of UNIX platforms, Windows and MacOS. 2.6.3 段落格式 段落级别 (block-level) 的格式用于创建具有特定格式的整个段落。除了常规文本外，常见的段落元素包括标题，列表，块引用，代码块等。 2.6.3.1 标题 用引号 # 创建不同层级的标题，引号的数量表示标题的层级。如 # 一级标题 创建一级标题，## 二级标题 创建二级标题，### 三级标题 创建三级标题等。注意在井号和标题文字之间要保留一个空格。如果 YAML 元数据中的 number_sections 选项设置为 true，则章节会自动编号。如果想为某些章节取消标号，可以在标题后添加 {-} 或 {.unnumbered}, 例子如下： --- output: html_document: number_sections: true --- # 前言 {-} # 简介 # 方法 ## 方法 1 ## 方法 2 # 总结 # 附录 {-} 读者还需注意，对没有编号的标题使用交叉引用时，只能用 Markdown 链接 [文字](#label), 而不能用 \\@ref(label)，后者是基于编号的引用。 2.6.3.2 列表 在列表项之前添加减号 - 或星号 * 以创建列表，同样注意文字前的空格。缩进一个或多个列表项可创建嵌套列表。 - First - Second - Third - Indented - Indented - Fourth item 显示为： First Second Third Indented Indented Fourth item 还可以用数字编号创建有序列表，与上面的无序列表结合使用，如： 1. 第一 2. 第二 - 首先 - 其次 3. 第三 显示为 第一 第二 首先 其次 第三 2.6.3.3 块引用 用大于号 &gt; 创建一个块引用 (blockquote) &gt; 生活是很枯燥的。我的一生就是力求不要在平庸中虚度光阴。这些小小的案件让我遂了心愿。 在输出文档中渲染为： 生活是很枯燥的。我的一生就是力求不要在平庸中虚度光阴。这些小小的案件让我遂了心愿。 2.6.4 代码块 注意: 这里的代码块只是有特殊格式的文字块，不同于可运行的代码，我们也无法在输出文档中得到它们的运行结果。 在文字前后各添加三个反引号 ``` 可以创建一个代码块，如： ``` x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)) # 计算每个列表元素的均值 lapply(x, mean) ``` 显示为： x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)) # 计算每个列表元素的均值 lapply(x, mean) 可以在反引号后注明代码块的语言，在输出文档中提供更好的代码高亮支持，以相同的代码块为例： ```r x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)) # 计算每个列表元素的均值 lapply(x, mean) ``` 显示为： x &lt;- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE)) # 计算每个列表元素的均值 lapply(x, mean) 2.6.5 图片 插入图片的语法与超链接类似，只需要在前面多添加一个感叹号, 格式如下10 ![替代文字](图片链接) 例如, 用 ![R logo](https://www.r-project.org/Rlogo.png) 插入以下图片： R logo 2.6.6 表格 Markdown 还支持插入表格，语法如下： | 元素 | Markdown | | - | - | | 块引用 | `&gt; some quotes` | | 代码块 | ``` some code ``` | 渲染为 元素 Markdown 块引用 &gt; some quotes 代码块 some code 2.6.7 数学公式 R Markdown 支持用一对 $ 插入行内公式，例如 $f(k) = {n \\choose k} p^{k} (1-p)^{n-k}$ 渲染为 \\(f(k) = {n \\choose k} p^{k} (1-p)^{n-k}\\)。 两个 $$ 会创建块级公式，例如： $$ f(k) = {n \\choose k} p^{k} (1-p)^{n-k} $$ 输出为： \\[ f(k) = {n \\choose k} p^{k} (1-p)^{n-k} \\] 作者也可以使用 LaTeX 默认的数学环境，如： $$\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}$$ \\[ \\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array} \\] $$X = \\begin{bmatrix}1 &amp; x_{1}\\\\ 1 &amp; x_{2}\\\\ 1 &amp; x_{3} \\end{bmatrix}$$ \\[ X = \\begin{bmatrix}1 &amp; x_{1}\\\\ 1 &amp; x_{2}\\\\ 1 &amp; x_{3} \\end{bmatrix} \\] 2.6.8 总结 最后总结一下 Markdown 中几种常见元素的语法，源文档如下： # 一级标题 **粗体** 和 *斜体* `&gt;` 开启一段块引用 &gt; We study statistics with the main aim of solving problems in other disciplines. 添加空行分隔段落 床前明月光， 疑是地上霜 ## 二级标题 反引号插入行内代码和代码块: `rnorm(10)` ```r print(&quot;hello world&quot;) ``` 表格 | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 数学公式 $$ x^2 + y^2 = z^2 $$ ### 三级标题 插入链接: [统计之都论坛](https://d.cosx.org/) 插入图片 ![](../images/cos-logo.png) 图 2.12 展示了渲染为 PDF 后的效果。 图 2.12: Markdown 常见元素的显示效果 Markdown 中的特殊字符包括 #, *, -, ` 等，通常它们代表了特定的排版格式，当需要按字面意输出这些特殊字符时，可以在前面使用转义符 \\。 \\- 这一行不会显示为列表 值得一提的是，虽然 Markdown 本身是一种统一的标准，随着时间推移独立开发者们逐渐添加了不同的功能扩展，一些组织和公司在此基础上加以规范化，形成了不同的 Markdown 变体 (flavor)。R Markdown 中使用的是 Pandoc 式的 Markdown，即 Pandoc 支持的 Markdown 语法。其他平台支持的常见变体包括 ExtraMark Markdown 和 Github Markdown 等。如果某个特定语法在 R Markdown 中无法正常显示，很可能是 Pandoc Markdown 不支持这个语法。 一些 Markdown 编辑器提供了即时预览功能，方便读者进行交互性的练习。图 2.13 是一个在线编辑器的例子。 图 2.13: 支持实时预览的 Markdown 编辑器 https://dillinger.io/ 2.7 代码块和行内代码 在 R Markdown 中，R 代码有两种使用方式: 代码块和行内代码。 R 代码块以 ```{r} 开始，``` 结束，作者可以在源文档中插入任意个代码块 11。与 YAML 元数据控制文档的整体设置类似，可以用代码块选项 (chunk options) 来控制单个代码块的运行细节。例如生成图片时，可以用 fig.width 和 fig.height 选项来控制图片的宽度和高度。 ```{r pressure, fig.width=7, fig.height=5} plot(cars) ``` 有时作者只希望展示代码的运行结果，而隐藏具体实现细节，这时可以设置代码块选项 echo = FALSE，R Markdown 会照旧运行代码，但仅在输出文档中显示运行结果。如果文档中包含很多代码块，逐个设置选项较为繁琐。这时可以用 knitr 包提供的 knitr::opts_chunk$set() 函数为所有代码块统一设置全局选项。例如，在全文档中的第一个代码块中设置： ```{r setup, include=FALSE} knitr::opts_chunk$set( echo = FALSE, fig.width = 7, fig.height = 5, fig.align = &quot;center&quot; ) ``` ```{r cars} plot(cars) ``` 这样，cars 及后续的代码块就会继承 knitr::opts_chunk$set() 中的选项。通常，全局选项被放置在整个文档的第一个代码块中，且设置该代码块的选项为 include=FALSE，这样，这个代码块本身就不会在文档中显示出来了 12。 如果后续的代码块需要覆盖全局选项，也可以在代码块中重新设置选项。 ```{r cars, echo=TRUE, fig.width=10} plot(cars) ``` 现在 cars 代码块的选项为 echo = TRUE, fig.wdith = 10, fig.height = 5 和 fig.align = \"center\"。 一些时候可能不需要单独成段的代码块，而是想在 Markdown 文本的同一段嵌入代码的运行结果，这时可以使用行内代码 (inline code)。行内代码位于一对反引号内部，以 r 开头，空格后面是 R 的表达式 13，例如下面的文本： mtcars 数据集共有 `r nrow(mtcars)` 行。 在输出文档中变为： mtcars 数据集共有 32 行。 行内代码与定时任务结合使用，可以实现报告文档的自动更新。 行内代码的使用不限于正文，一个常见用法是动态更新文档的编译日期。在 YAML 元数据中可以将 date 设置为 R 表达式 Sys.Date()，这样每次编译时，R Markdown 都会将日期的值更新为当前编译的日期。 --- date: &quot;`r Sys.Date()`&quot; --- 2.7.1 代码块选项 读者可以在 https://yihui.org/knitr/options/ 查看所有代码块选项，这里列出一些重要选项和它们的取值类型。第 @ref(#chunk-options) 节展示了更多例子。 eval: 是否运行该代码块 echo: 是否显示代码块内容 results：如何处理代码块和运行结果 'hide': 隐藏代码块的运行结果。results = 'hide' 加上 echo = FALSE 等价于 include = FALSE 'asis': 将运行结果直接插入文档，不添加其他容器元素。默认情况下，knitr 在生成 .md 文件时会将代码的文字输出在放在 Markdown 的代码块 ``` 中 'markup' 默认设置 include: 是否显示代码块和运行结果，include = FALSE 等价于 echo = FALSE 和 results = 'hide' error：是否允许代码块包含错误代码。默认情况下，只要一个代码块运行失败，整个 R Markdown 文档就无法编译成功。当想要展示错误的代码写法时，可以用 error = TRUE 或 eval = FALSE message 和 warning： 是否显示代码块可能输出的提示和警告 collapse: 为 true 时，在输出文档中将代码块和运行结果放置在同一个块级元素中 fig.width 和 fig.height: 调整代码块生成图形时图形设备 (graphical device) 的大小。 kntir 首先通过图形设备将图片存储为文件 (例如 png, jpg)，随后在输出文档中引用这些文件。默认情况下 fig.width = 7, fig.height = 5。两个类似的选项是 out.width 和 out.height, 通常取值为百分比，表示图片占据一页的比例。例如, out.height = '80%' 表示图片占据容器高度的 80%。 fig.cap: 图片的标题 fig.align: 图片的对齐方式，有三种取值 \"left\": 靠左对齐 \"center\" 居中对齐 (本书的设置) \"right\": 靠右对齐 cache: 是否缓存代码块的运行结果。如果代码块涉及复杂的计算，cache = TRUE 可以让 knitr 把运行结果保存为 .rds 文件，并在下次编译时略过计算过程，直接读取 .rds 节省时间。只有代码块的内容发生变化时，knitr 才会重新计算并更新 .rds 文件。有时 knitr 的缓存机制会让人难以预测代码是否重新运行，只推荐必要时使用。 knitr 1.35 及以后版本支持在代码块内部用 #| 符号 设置代码块选项，例如： ```{r} #| echo = FALSE, fig.width = 10, #| fig.cap = &quot;这是一个很长很长很长的标题&quot; plot(cars) ``` 一些读者可能更喜欢 YAML 语法而不是用逗号分隔各选项，#| 实现了这一点： ``` #| echo: false #| fig.width: 10 plot(cars) ``` 需要注意的是，代码块内的选项优先级比常规选项更高，例如下面的代码段最终的选项为 echo = FALSE 和 collapse = FALSE ```{r, echo = FALSE, collapse = TRUE} #| collapse = FALSE ``` 2.8 文档元素 2.8.1 图片 默认情况下，代码块生成的图片在输出文档中被直接插入该代码块的下方。一个重要的 knitr 选项是 fig.cap，它可以为图片添加标题。例子如下： ```{r cars-plot, fig.cap = &quot;cars 数据集&quot;} plot(cars) ``` 生成的图片如图 2.14 所示。 图 2.14: cars 数据集 当一个代码块生成多个图片时，R Markdown 会把它拆分成多个代码块，每个代码块生成一个图片，效果如下： 如果同一个代码块生成多张图片，结果会被拆分到多个代码块中。 ```{r} plot(cars) plot(nhtemp) ``` 如果想要把多个图片放在同一个代码块中，可以使用代码块选项 fig.show = 'hold'，它告诉 R Markdown 不要拆分代码块，而是运行完全部代码后，把生成的图片依次附在下方。与 out.width 选项结合使用，可以将多个图片并排放在同一行中，效果如下： ```{r, fig.show = &quot;hold&quot;, out.width = &quot;50%&quot;} plot(cars) plot(nhtemp) ``` 对于非代码生成的外部图片，可以使用 Markdown 的图片语法 ![图片描述](图片路径) 或 knitr 包中的函数 knitr::include_graphics() 插入图片。例子如下： ```{r, out.width = &quot;90%&quot;, fig.cap = &quot;用 knitr::include_graphics() 插入图片&quot;} knitr::include_graphics(&quot;images/some-image.png&quot;) ``` 使用 include_graphics() 的好处是可以用代码块选项控制图片的细节。 2.8.2 表格 第 2.6.6 节介绍了用 Markdown 语法编写表格的方法。对于 R 用户，更简单的插入表格方法是使用 knitr 包中的 kable() 函数，它接受一个数据框，返回对应的表格。与图片的 fig.cap 选项类似，作者可以用 kable() 函数中的 caption 参数控制表格的标题。例如下面的代码块： ```{r iris-table} knitr::kable(head(iris), caption = &quot;iris 数据集&quot;) ``` 生成的表格如表 2.1 所示。 表 2.1: iris 数据集 speed dist 4 2 4 10 7 4 7 22 8 16 9 10 一个常见的用例是将表格数据存入 csv 文件中，随后在 R Markdown 中读取该文件并生成表格。例如： read.csv(&quot;some-data.csv&quot;) |&gt; knitr::kable(caption = &quot;some data&quot;) 2.8.3 分页符和分割线 LaTeX 命令 \\newpage 可以在文档中插入一个分页符。\\newpage 的使用不局限于 PDF 输出格式，R Markdown 会自动将其转换为其他格式中的分页符，支持的格式包括 HTML、PDF、Word、ODT 等。例如： --- title: 分页符和分割线 output: pdf_document: default word_document: default html_document: default odt_document: default --- # 第一章 \\newpage # 第二章 如果只想插入一条水平的分割线而不分页，可以插入三个减号 ---。 LaTeX 命令在其他输出格式中的转换是由自定义 Pandoc 中的 Lua Filters 实现的，有兴趣的读者在 R 中查询相关文档： vignette(&quot;lua-filters&quot;, package = &quot;rmarkdown&quot;) 2.8.4 目录 YAML 元数据中的 toc: true 是所有输出格式的通用选项，用以自动生成目录，toc_depth 控制显示深度。如： --- title: &quot;插入目录&quot; output: html_document: toc: true toc_depth: 2 --- 此时目录只会显示一级标题和二级标题，略过级别更低的标题。 html_document 和 bookdown::html_document2 等输出格式支持 toc_float 属性，为 true 时，目录变为侧边栏，并固定在屏幕左侧。toc_float 支持更多细节选项，包括： collapsed (默认为 true)：是否折叠二级标题以下的标题 smooth_scroll (默认为 true)：是否在鼠标点击目录时添加平滑滚动 例子如下： --- title: &quot;插入目录&quot; output: html_document: toc: true toc_float: collapsed: false smooth_scroll: false --- 2.8.5 参考文献 TODO：这一部分以后应当结合 Zotero 和 EndNote 等常用文献管理软件做适当扩展。 R Markdown 支持在输出文档末尾自动生成参考文献，并提供了很方便的引用格式。这项功能是通过 Pandoc 实现的，它有两种管理引用和参考文献的方式 默认情况下，Pandoc 会使用 [pandoc-citeproc](https://github.com/jgm/pandoc-citeproc) 程序按照 CSL (Citation Style Language) 语言的标准和特定的 CSL 风格文件组织参考文献和引用的格式。 读者还可以使用 natbib 包 (基于 LaTeX 的 bibtex包) 或 biblatex 包提供的格式。 作者可以用 YAML 元数据中的 citation_package 选项设置 LaTeX 中的引用包，常见的选择有 natlib 或 biblatex： output: pdf_document: citation_package: natbib bookdown::pdf_book: citation_package: biblatex citation_package 仅限于 PDF 输出格式。其他输出格式只能依靠 pandoc-citeproc，如果需要保持 PDF 格式和其他格式的一致性，就应该始终使用 pandoc-citeproc。 设置好引用格式后，还需要知道如何把参考文献的各个条目表达为数据形式。推荐读者用 BibTeX 数据库 (BibTeX Database) 管理 R Markdown 中的参考数据。BibTeX 数据库是一种纯文本文件，一般以 bib 为后缀，其中的每一个条目格式形如： @Manual{R-base, title = {R: A Language and Environment for Statistical Computing}, author = {{R Core Team}}, organization = {R Foundation for Statistical Computing}, address = {Vienna, Austria}, year = {2016}, url = {https://www.R-project.org/}, } 一个条目以 @type{ 开始，type 表示该条参考的类型，可以识 article, book, manual 等。在类型之后的是引用标签，如 R-base，其他项包含参考的作者，组织，地址，日期和链接等信息。每一个条目都至少包含名称，作者和时间等信息，为了使用 .bib 文件中的条目，需要用 YAML 元数据中的 bibliography 加载一个或多个 .bib 文件： output: pdf_document bibliography: [&quot;one.bib&quot;, &quot;another.bib&quot;, &quot;yet-another.bib&quot;] biblio-style: &quot;apalike&quot; link-citations: true 上面的例子引入了 one.bib，another.bib，yet-another.bib 三个 .bib 文件中的参考数据，biblio-style: 'apalike' 设置参考样式为美国心理学学会期刊样式 (American Psychology Association, APA)，link-cations: true 为引用添加指向参考文献的跳转链接。 用 bibliography 引入 .bib 后，便可以在文档中引用其中包含的任意条目，语法为 @key 或 [@key]，其中 key 为该参考条目类型之后的标签。如 @R-base 生成为 R Core Team (2022)，而 [@R-base] 生成 (R Core Team 2022)。 对 PDF 输出，Pandoc 会在最后一个章节后额外生成一节放置参考文献。对其他输出格式，可以在文档的最后用行内代码自动创建一个章节存放参考文献。例如，在源文档的最后插入： `r if (knitr::is_html_output()) &#39;# 参考文献 {-}&#39;` 被 @key 引用的参考条目会自动出现在最后的参考文献索引中，如果想在最后添加 .bib 中的全部条目，不论是否引用，可以设置 YAML 中的 notice 属性。例如： --- nocite: &#39;@*&#39; --- 2.8.6 引用 R 包 参考”文献”还可以包括文章使用的软件包。knitr 包提供了 write_bib 函数为 R 包生成 .bib 格式的参考条目： # 第二个参数可以是任意 .bib 文件 knitr::write_bib(c(&quot;base&quot;, &quot;knitr&quot;), &quot;&quot;, width = 60) ## @Manual{R-base, ## title = {R: A Language and Environment for Statistical ## Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2022}, ## url = {https://www.R-project.org/}, ## } ## ## @Manual{R-knitr, ## title = {knitr: A General-Purpose Package for Dynamic ## Report Generation in R}, ## author = {Yihui Xie}, ## year = {2022}, ## note = {R package version 1.39}, ## url = {https://yihui.org/knitr/}, ## } ## ## @Book{knitr2015, ## title = {Dynamic Documents with {R} and knitr}, ## author = {Yihui Xie}, ## publisher = {Chapman and Hall/CRC}, ## address = {Boca Raton, Florida}, ## year = {2015}, ## edition = {2nd}, ## note = {ISBN 978-1498716963}, ## url = {https://yihui.org/knitr/}, ## } ## ## @InCollection{knitr2014, ## booktitle = {Implementing Reproducible Computational ## Research}, ## editor = {Victoria Stodden and Friedrich Leisch and Roger ## D. Peng}, ## title = {knitr: A Comprehensive Tool for Reproducible ## Research in {R}}, ## author = {Yihui Xie}, ## publisher = {Chapman and Hall/CRC}, ## year = {2014}, ## note = {ISBN 978-1466561595}, ## url = {http://www.crcpress.com/product/isbn/ ## 9781466561595}, ## } 不提供第一个参数时。write_bib 会导出当前进程加载的全部 R 包的引用数据，作者可以在文档末尾插入如下代码段自动化生成 R 包对应的 .bib 文件： --- bibliography: [packages.bib, references.bib] --- # 总结 最后，... ```{r, include=FALSE} knitr::write_bib(file = &#39;packages.bib&#39;) ``` `r &quot;\\x60r if (knitr::is_html_output()) &#39;# References {-}&#39;\\x60&quot;` 2.8.7 交叉引用 交叉引用 (cross-reference) 可以为读者提供锚点链接，便于他们快速浏览文档中相关部分。rmarkdown 包提供的 html_document, pdf_document 等基础格式不支持交叉引用。作者可以转而使用 bookdown (Xie 2022a) 包提供的额外格式：bookdown::html_document2 和 bookdown::pdf_document2 等。 随后，作者需要为链接跳转的锚点设置一个标签，这样引用的时候才有地放矢。R Markdown 支持交叉引用章节标题、图片、表格和公式等元素，语法略有不同。 对于标题，Pandoc 会自动为章节标题设置标签。例如 # Hello World 对应的标签为 hello-world。随后就可以用 \\@ref(hello-world) 引用该标题，它会生成该章节对应的编号。对中文标题，Pandoc 可以用 # 标题 {#header} 的格式为该节添加自定义标签 header，随后用 \\@ref(header) 引用该节。例如本节标题设置了 ## 交叉引用 {#cross-reference}，\\@ref(cross-reference) 生成为 2.8.7。建议总是给中文标题设置一个简洁的英文标签，仅包含字母和连词符，例如： --- output: bookdown::pdf_document2 --- # 简介 {#introdcution} # 方法 {#methods} 我们可以分别用 \\@ref(introduction) 和 \\@ref(methods) 引用前两章的标题。 与章节标题不同，图片和表格的标签是它们所属代码块的标签。第 2.7 节中谈到可以用 ```{r label} 或 ```{r, label = \"label\"} 为代码块设置标签。当该代码块的输出包含图片或表格时，这个标签就可用于交叉引用。但仅有该标签还不够，交叉引用需要元素有自己的独立环境。这一点可以通过为图片和表格设置标题做到。图片可以用 fig.cap 选项，设置表格标题的方法取决于生成的函数，例如 knitr::kable 使用 caption 参数。 随后，可以用 \\@ref(fig:label) 引用图片，用 \\@ref(tab:label) 引用表格。 数学公式同样支持类似的标签引用，需要使用 LaTeX 中的 equation 环境，例如下面的公式： \\begin{equation} \\bar{X} = \\frac{\\sum_{i=1}^n X_i}{n} (\\#eq:mean) \\end{equation} 其中 (\\#eq:mean) 是公式标签，引用格式为 \\@ref(eq:mean)。 下面的例子展示了章节、图片、表格和公式的引用语法： --- title: &#39;交叉引用图片和表格&#39; output: bookdown::html_document2: default --- # 引用图片 {#ref-figure} ```{r cars-plot, fig.cap = &quot;一张散点图&quot;} plot(cars) ``` 引用图片需要为代码块设置标签，并有标题 `fig.cap`, 如图 \\@ref(fig:cars-plot) 所示。 下面的图片虽然设置了代码块标签，但没有 `fig.cap`，无法创建单独的图表环境，引用 \\@ref(fig:iris-plot) 失效。 ```{r iris-plot} plot(iris) ``` ## 引用表格 {#ref-table} 引用表格与图片类似，如表 \\@ref(tab:iris-table) 所示。 ```{r iris-table} knitr::kable(head(iris), caption = &quot;一个表格&quot;) ``` ## 引用公式 {#ref-equation} 第 \\@ref(ref-figure) 节和第 \\@ref(ref-table) 展示了图片和表格的交叉引用，下面是对公式的引用。 见公式 \\@ref(eq:mean)。 \\begin{equation} \\bar{X} = \\frac{\\sum_{i=1}^n X_i}{n} (\\#eq:mean) \\end{equation} 输出如图 2.15 所示。 图 2.15: 交叉引用图片和表格 有兴趣的读者可以查看上述生成的 .html 文件，会发现标签元素的容器有对应的 id 属性。同理，PDF 输出的 .tex 文件会插入对应的 \\label{} 指令，这也是交叉引用的跳转基础。 2.8.8 索引 为了方便读者快速浏览，除目录之外，作者还可以在文档的末尾插入索引。索引的生成需要使用 LaTeX 包，因此只有 PDF 输出文档才支持索引。首先，创建一个 .tex 文件引用 LaTeX 的 makeidx 包，然后在 R Markdown 文档中用 includes -&gt; before_body 选项引入这个 .tex 文件。例如，在 preamble.tex 中写入： \\usepackage{makeidx} \\makeindex 作者还需要在 R Markdown 文档的末尾插入 LaTeX 命令 \\printindex。随后就可以使用 \\index{} 创建一个索引条目。完整的源文档如下： --- title: &quot;插入索引&quot; documentclass: ctexart output: pdf_document: latex_engine: xelatex includes: in_header: preamble.tex --- 模型筛选指标包括 RMSE \\index{AIC}, AIC \\index{RMSE} 和 BIC \\index{BIC} 等。 \\printindex 生成的 PDF 文档如图 2.16 所示。 图 2.16: 在 PDF 文档中插入索引 2.8.9 动画 对 HTML 输出文档，R Markdown 支持 aniamtion.hook 选项 (依赖 gifski 包) 将多个图片合并成 gif 格式的动画。 ```{r, animation.hook=&quot;gifski&quot;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&quot;red&quot;, &quot;yellow&quot;), labels = NA) } ``` 为了在 PDF 输出中支持动画，首先需要安装 LaTeX 包 animate，并设置选项 fig.show = \"animate\"，这样创建的动画只能用 Acrobat Reader 显示。例子如下： --- title: PDF 中插入动画 output: pdf_document: extra_dependencies: animate --- 下面的动画职能在 Acrobat Reader 中显示 ```{r, fig.show=&#39;animate&#39;} for (i in 1:2) { pie(c(i %% 2, 6), col = c(&quot;red&quot;, &quot;yellow&quot;), labels = NA) } ``` 2.8.10 交互组件 HTML 输出文档支持基于 JavaScript 的交互组件。htmlwidgets R 包 (Vaidyanathan et al. 2021) 让 R 用户可以轻松实现实现对 JavaScript 库的接口。在此框架上开发的 R 包如 DT (R-DT?) (表格)，leaflet (Cheng, Karambelkar, and Xie 2022) (地图) 和 ，dygraphs (Vanderkam et al. 2018) (时间序列图) 为 HTML 输出格式提供了丰富的交互组件。读者可以在 https://www.htmlwidgets.org 了解更多使用和开发 HTML 组件的更多细节。图 2.17 是一个使用 leaflet 包插入交互地图的例子。 library(leaflet) leaflet() %&gt;% addTiles() %&gt;% setView(174.768, -36.852, zoom = 16) %&gt;% addPopups(lng = 174.768, lat = -36.852, popup=&quot;&lt;b&gt;R&lt;/b&gt; 的诞生地&quot;) 图 2.17: 用 leaflet 包插入交互地图 对于非 HTML 输出格式，R Markdown 会用 webshot (Chang 2022) 包将组件截取为静态图片后插入输出文档中。 2.8.11 音频和视频 可以在 HTML 输出中插入音视频等多媒体文件，如果读者使用的提供商支持在网页端界面，则只需要复制该段插入代码，例如下面的代码块插入了哔哩哔哩的视频： ```{=html} &lt;iframe src=&quot;https://player.bilibili.com/player.html?aid=629420179&amp;bvid=BV1ib4y1X7r9&amp;cid=304825282&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; style=&#39;width: 100%; height: 500px;&#39; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; ``` 这里的 =html 是针对 HTML 格式的特殊代码环境，代表其中的内容为原生 HTML 代码，直接插入生成的 HTML 文件中，效果如下： 如果音视频文件托管于其他服务器上，则可使用原生的 HTML audio 和 video 元素，例如： ```{=html} &lt;audio controls src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3&quot;&gt; &lt;/audio&gt; ``` 2.8.12 流程图 Graphviz 和 mermaid 是两个创建流程和网络图的通用软件。DiagrammeR (Iannone 2022) 包支持用 R 代码生成 Graphviz 或 mermaid 图。可以直接在 RStudio 中打开 Graphviz (.gv) 和 mermaid (.mmd) 文件，如图 2.18 所示。 图 2.18: RStudio 编辑器中的 Graphviz 和 mermaid 图文件 作者也可以直接使用 Graphviz 格式的字符串，如图 2.19 所示。 library(DiagrammeR) grViz(&quot;digraph { graph [layout = dot, rankdir = TB] node [shape = rectangle] rec1 [label = &#39;Step 1. 起床&#39;] rec2 [label = &#39;Step 2. 写代码&#39;] rec3 [label = &#39;Step 3. ???&#39;] rec4 [label = &#39;Step 4. 暴富&#39;] # edge definitions with the node IDs rec1 -&gt; rec2 -&gt; rec3 -&gt; rec4 }&quot;, height = 500) 图 2.19: 用 DiagrammeR 创建 Graphviz 流程图 作者可以在 grViz() 函数中用 @@ 嵌入 R 变量，如图 2.20 所示。 grViz(&quot; digraph graph2 { graph [layout = dot, rankdir = LR] # node definitions with substituted label text node [shape = oval] a [label = &#39;@@1&#39;] b [label = &#39;@@2&#39;] c [label = &#39;@@3&#39;] d [label = &#39;@@4&#39;] a -&gt; b -&gt; c -&gt; d } [1]: names(iris)[1] [2]: names(iris)[2] [3]: names(iris)[3] [4]: names(iris)[4] &quot;, height = 100 ) 图 2.20: 在 DiagrammeR::grviz 中使用 R 变量的值 除了流程图外，DiagrammeR 还可以创建网络图，如图 2.21 所示。 图 2.21: DiagrammeR 创作的网络可视化图 其他能生成流程图的 R 包包括：nomnoml、diagram、dagitty、ggdadg 和 plantuml 等。 2.9 RStudio 图形化编辑器 RStudio Desktop 1.4 及以后版本为 R Markdown 文档添加了图形编辑模式。在 RStudio 中打开任意 .Rmd 文件，点击右上方类似 “A” 的按钮 (图 2.22)，可进入可视化编辑器，界面如图 2.23 所示。 图 2.22: R Markdown 编辑模式切换按钮 图 2.23: R Markdown 图形编辑模式 图形化编辑器提供了丰富的菜单栏选项，用于可视化地插入常见文档元素。如图 2.24 所示。 图 2.24: 图形化编辑器提供了很多菜单栏选项 读者可以在 https://rstudio.github.io/visual-markdown-editing/ 了解更多图形化编辑器的知识。 参考文献 "],["rmarkdown-document.html", "第 3 章 使用 R Markdown 创建常用文档 3.1 HTML 文档 3.2 PDF 文档 3.3 PPT 幻灯片 3.4 Word 文档 3.5 创建新的文档格式", " 第 3 章 使用 R Markdown 创建常用文档 第 2.4 节介绍了 R Markdown 从源文档到输出的两步过程，分别是 R Markdown –&gt; Markdown，由 knitr (Xie 2022c) 完成； Markdown –&gt; 不同格式文档，由 Pandoc 完成。 Markdown 在发明之初的主要目的就是简化 HTML 内容的书写方式。例如要创建一个列表项，用 HTML 来写是 &lt;ul&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;/ul&gt; 而用 Markdown 来写则只需要 - 列表项 又如要表示一段引用，用 HTML 来写是 &lt;blockquote&gt;text&lt;/blockquote&gt;，用 Markdown 来写则只需要 &gt; text。 Pandoc 大大扩展了 Markdown 的语法。更重要的是，Pandoc 使得将 Markdown 文档转换为多种输出格式成为可能。尽管这些文档大体可以按照背后的实现方式，分为 HTML、PDF 和 Microsoft Office 等三大类型，但是根据应用场景的差异，会有多种多样的具体样式。 鉴于每种样式通常会通过不同的 R Markdown 扩展软件包来实现，所以其设置和使用方面会有自身的特点。因此，接下来的一部分内容将依次介绍常用文档格式的使用方法。而本章则主要介绍将 R Markdown 源文件输出为各种常用文档格式的功能。 3.1 HTML 文档 HTML 即超文本标记语言（Hyper Text Markup Language），该技术是互联网最重要的基础设施之一，是网上精彩纷呈内容的主要依托。HTML 文档不仅能够展示文字、图片、表格、公式等常规页面元素，而且还可以呈现音乐、视频、交互动画等丰富多样的多媒体内容。而同样的任务则是其它常见的文档格式如 PDF、Microsoft Word 等所不能完成的。因为 Markdown 技术在设计之初的输出格式就是 HTML，所以 HTML 文档不仅仅是最常用 R Markdown 输出格式，同时也拥有最丰富的功能，因此是在学习 R Markdown 技术的过程中首先需要了解这一部分内容。 严格意义上说，采用 R Markdown 和 HTML 技术呈现的网站、幻灯片等也都属于 HTML 格式的文档，不过这些形式的内容通常包含了多个 .html 格式的文件，而这里介绍如何通过 R Markdown 源文件生成一份独立的 .html 格式的文件。 前面提过，R Markdown 生成 HTML 文档的过程有一个中间步骤，就是 Markdown + HTML 模板。HTML 模板包括预定义的文档结构、 CSS 样式表和 JavaScript 动态网页功能等，所以最终渲染得到的 HTML 文档的一些功能可能依赖于特定 HTML 模板才能实现。对于一般用户而言，不了解这方面的知识并不影响正常使用 R Markdown 创建 HTML 文档。但是如果用户对此有所了解，那将有利于了解 HTML 文档的实现途径。 默认情况下，R Markdown 的 HTML 文档使用 rmarkdown::html_document 模板。除此之外， rmarkdown 之外的其它软件包也提供了各种不同类型的 HTML 模板文件（如 bookdown::html_document2，pagedown::html_paged 等）。因此，在这一部分将首先从 R Markdown 到 html_document 文档开始。 要创建一个 html_document，只需要在 R Markdown 的开头加入 YAML 格式的元数据。 --- title: &quot;文档标题&quot; author: &quot;作者&quot; date: &quot;创建时间&quot; output: html_document --- 在元数据中，还可以加入各种各样设置，从而改变文档的格式。例如下面的设置将为文档添加一个自动目录。 --- title: &quot;文档标题&quot; author: &quot;作者&quot; date: &quot;创建时间&quot; output: html_document: toc: true --- 3.1.1 目录和标题 R Markdown 文件中使用的目录都是自动目录，是根据文档的层次结构（一级标题、二级标题等）自动生成的。这一部分介绍如何在 HTML 文档中设置自动目录。 3.1.1.1 显示目录 在开头的元数据中，使用 toc: true 可以打开文档的目录。目录会从 HTML 的标题自动生成，目录的层级由 toc_depth 的值确定（默认为 3）。例如： --- title: &quot;标题&quot; output: html_document: toc: true toc_depth: 2 --- 在上面的例子中，目录中将包含 HTML 文档中的一级标题和二级标题。 3.1.1.2 悬停目录 当把 toc_float 设为 true 的时候，目录会在侧边栏悬停。这样就可以随时借助目录在一篇比较长的文档中跳转了。 --- title: &quot;标题&quot; output: html_document: toc: true toc_float: true --- 通过改变 toc_float 的选项，可以控制侧边栏的折叠和动画。其中： collapsed （默认为 true）控制文档第一次打开时目录是否被折叠。如果为 true 则只显示高级别的标题（二级标题及以上元素）； smooth_scroll （默认为 true）控制页面滚动时，标题是否会随之变化。 --- title: &quot;标题&quot; output: html_document: toc: true toc_float: collapsed: false smooth_scroll: false --- 3.1.1.3 显示标题编号 使用 number_sections 可以在标题开头加上编号。一级标题编号为 “1 一级标题”，二级标题为”1.1 二级标题”。 --- title: &quot;标题&quot; output: html_document: toc: true number_sections: true --- 3.1.1.4 使用标签页展示小标题的内容 在 HTML 文档中使用标签页非常简单，只需要在标题后附加 {.tabset} 标签即可。 ## 季度报表（应用 `.tabset` 标签） {.tabset} ### 按产品汇总 （具体的报表内容） ### 按区域汇总 （具体的报表内容） 在此基础上，添加相关的额外标签还可以控制标签的样式和行为。其中： .tabset-fade 将为标签切换过程加入淡入淡出的动画效果； .tabset-pills 将为标签文字加上预设的 .tabset-pills 样式（图 3.1）。 图 3.1: 标签的默认样式及 .tabset-pills 样式 3.1.2 主题和样式 3.1.2.1 可选的文档主题样式 为了满足颜值党的差异化需求，html_document 自带了多个不同的主题。这些主题来自于 Bootswatch。可用的主题名称包括 default，cerulean，journal，flatly，darkly，readable，spacelab，united，cosmo，lumen，paper，sandstone，simplex 和 yeti 等等。 主题使用 theme 参数设置： --- title: &quot;标题&quot; output: html_document: theme: darkly --- darkly 主题样式的效果如图 3.2 所示，感兴趣的读者可以自行尝试其它样式。 图 3.2: 应用 darkly 主题后的文档样式 如果设置为 theme: null，那么将不会应用任何主题，此时可以通过指定自定义的 CSS 样式表来进行格式化。 --- title: &quot;标题&quot; output: html_document: theme: null css: style.css --- 3.1.2.2 可选的代码高亮样式 代码高亮也有可选的多种样式，包括 default，tango，pygments，kate，monchrome，espresso，zenburn，haddock，breezedark 和 textmate 等。 在元数据中，使用 highlight 参数指定代码高亮样式。下面的示例中将代码高亮设为 tango，更多的代码高亮样式见图 3.3。 --- title: &quot;标题&quot; output: html_document: highlight: tango --- 图 3.3: 可选的代码高亮样式 跟上面的 theme 属性一样，highlight 也可以设为 null，这样的话代码将不显示高亮。 3.1.2.3 自定义样式表 不论有没有应用主题和代码高亮，用户都可以使用 css 参数指定附加样式表。附加样式表中的定义优先级更高，当被应用到特定元素上去之后，可以改变元素的外观。 --- title: &quot;标题&quot; output: html_document: theme: null highlight: null css: styles.css --- 如果在 styley.css 中定义了两个名为 #nextsteps 和 .emphasized 的新样式，分别用于指定 HTML 文档中 id = \"nextsteps\" 和 class = \"emphasized\" 这两种元素的外观。 #nextsteps { color: blue; } .emphasized { font-size: 1.2em; } 那么，就可以通过在行尾大括号中添加元素 id 和 CSS 类的方法，对某个二级标题（此处为“这里强调一下下一步”）应用这个样式： ## 这里强调一下下一步 {#nextsteps .emphasized} 如果要应用多个 CSS 配置文件，可以这样写： output: html_document: css: [&quot;style-1.css&quot;, &quot;style-2.css&quot;] 3.1.2.4 通过 CSS 代码块定义样式 除了像上面那样导入一个预定义的样式表，还可以直接在 R Markdown 中添加新的 CSS 定义。不过这种方法只适合针对个别元素进行个性化设置，如果 CSS 代码有很多行，或者想要在其它 R Markdown 文件中中交叉使用同样的定义，那么将其放在自定义样式表文件中会更加合适（参见 3.1.2.3）。 --- title: &quot;对代码块使用自定义的 CSS 样式&quot; output: html_document --- 首先定义一个新样式 `watch-out`。 ```{css, echo=FALSE} .watch-out { background-color: lightpink; border: 3px solid red; font-weight: bold; } ``` 使用代码块属性 `class.source` 可以将新样式指定给这一区块。 ```{r class.source=&quot;watch-out&quot;} mtcars[1:5, &quot;mpg&quot;] ``` 图 3.4: 一个具有浅红色背景和深红色边框的代码块 3.1.2.5 使用丰富多样的内置 CSS 样式 大多数时候，用户并不需要自己定义 CSS 样式，因为 HTML 内置的主题中已经包含了丰富且高级的内置样式。 默认情况下，R Markdown 输出的 HTML 文档中，已经内嵌了 Bootstrap 框架14，因此可以使用一系列预定义的 CSS 样式。其中，可用的背景样式就包括 \"bg-primary\"，\"bg-success\"，\"bg-info\"，\"bg-warning\" 和 \"bg-danger\" 等。 只需要在代码块属性中使用 class.source 标签，就可以应用这些预定义的 CSS 样式。 --- title: 改变代码块的样式 output: html_document --- 当你对一个数据框取子集的时候，其输出跟选取的列的数目有关。 如果选取了 2 个以上的列，则输出仍然是一个数据库； 如果选取了 1 个列，则输出的结果将会是一个向量。 因此，我们对这个操作应用了 `bg-danger` 和 `bg-warning` 的样式。 ```{r class.source=&quot;bg-danger&quot;, class.output=&quot;bg-warning&quot;} mtcars[1:5, &quot;mpg&quot;] ``` 为了确保始终能够得到数据框，则需要添加 `drop = FALSE` 参数。 为了显示这个结果，我们应用了 `bg-success` 样式。 ```{r df-drop-ok, class.source=&quot;bg-success&quot;} mtcars[1:5, &quot;mpg&quot;, drop = FALSE] ``` 以上生成的 HTML 输出如图 3.5 所示。 图 3.5: 在代码块上应用内置 CSS 样式 3.1.2.6 代码折叠 当 Knitr 的代码块参数 echo = TRUE 时，R 代码将会输出到最终生成的文档中。 如果不需要显示源代码，可以直接设为 echo = FALSE。 如果既想要保留代码但又让其默认不显示， 则可以通过 code_folding: hide 参数来实现。 --- title: &quot;代码折叠&quot; output: html_document: code_folding: hide --- code_folding: hide 将折叠所有的代码块，用户可以通过点击来查看折叠的代码。如果想让部分代码块在一开始就显示，则可以在代码块选项中使用 class.source = 'fold-show'（图 3.6）。 --- title: &quot;代码的折叠和显示&quot; output: html_document: code_folding: hide --- ```{r} 1 # 折叠的 ``` ```{r class.source = &#39;fold-show&#39;} 2 # 显示的 ``` ```{r} 3 # 还是折叠的 ``` 图 3.6: 代码块的折叠和显示。图中每个代码区块旁边都有一个按钮，可以控制相应代码区块的显示方式；文档的右上角也有一个按钮，可以控制文档中全部代码区块的显示方式。 这种操作也可以反向进行，即默认显示全部的代码区块，然后再将部分代码区块设为折叠。如下配置即可： --- output: html_document: code_folding: show --- ```{r} 1 # 代码默认是显示的 ``` ```{r class.source = &#39;fold-hide&#39;} 2 # 这一块代码将被折叠 ``` 如图 3.6 所示，在页面和每一个代码块的右上方有一个按钮。页面右上方的按钮可以控制全部代码块的显示和隐藏，代码块右上方的按钮则可以控制对应代码块的显示和隐藏。 3.1.2.7 设置代码块内容可滚动 如果想限制代码块的高度，特别是代码执行过程中输出内容的高度，还可以从相应内容的 CSS 样式上着手，即通过 class.output 和 class.source 来定义内容的高度。 下面是一个限制设定代码区块高度后，再通过滚动查看完整内容的例子： --- title: 可以滚动的代码和输出 output: html_document --- ```{css, echo = TRUE} pre { max-height: 300px; overflow-y: auto; } pre[class] { max-height: 100px; } ``` 我们首先定义了上述 CSS 规则，用来限制代码块的高度。 ```{r} # 假如这里有 N 多行的代码 if (1 + 1 == 2) { # 然后再打印一个非常长的数据 print(mtcars) # 如果不够长的话，再加上这行注释可能就够了 } ``` 现在添加一个新的 CSS 类 `scroll-100`，以用来限制代码块的输出高度为 100 像素。 然后，将这个类赋值给代码块中的 `class.output` 参数。 ```{css, echo=FALSE} .scroll-100 { max-height: 100px; overflow-y: auto; background-color: inherit; } ``` ```{r, class.output=&quot;scroll-100&quot;} print(mtcars) ``` 因为代码块是位于 &lt;pre class=\"sourcecode\"&gt; 标签内的，所以 pre[class] 操作符将限制代码块的高度为不超过 100 像素。 而将 class.output 设为 scroll-100 则限制输出部分的高度为不超过 100 像素。最终效果如图 3.7 所示。 图 3.7: 可以滚动的代码块 3.1.3 图片和数据框 3.1.3.1 设置图片的属性 下列参数可以调整生成的 HTML 文档中图片的属性： fig_width，fig_height 指定图片显示时的宽和高（默认为 7 × 5，单位英寸）； fig_retina 开启视网膜屏幕优化（默认为 2，设为 null 时关闭优化）； fig_caption 控制是否渲染图注； dev 设置图片输出设备，默认为 png。可以设置多个图片输出设备。 --- title: &quot;标题&quot; output: html_document: fig_width: 7 fig_height: 6 fig_caption: true dev: c(&quot;png&quot;,&quot;pdf&quot;) --- 在代码框属性中，仍然可以通过 fig.height，fig.width，fig.asp 等参数来指定生成图片的高度、宽度和宽高比。 3.1.3.2 插入外源图片 虽然在 R Markdown 中可以使用 Markdown 语法和 HTML 语法插入图片，但是推荐使用 knitr::include_graphics() 的方式来完成这一操作。例如： ```r knitr::include_graphics(&quot;https://r-project.org/Rlogo.png&quot;) ``` &lt;img src=&quot;https://r-project.org/Rlogo.png&quot; style=&quot;display: block; margin: auto;&quot; /&gt; 使用这种方法插入外源图片，可以方便地添加图注（使用 fig.cap 参数），以及设置图片的宽高等属性（图 3.8）。 图 3.8: 插入外源图片的推荐方式 3.1.3.3 输出数据框 数据框是常见的数据结构，通过设置 df_print 参数，可以调整数据框的输出格式。可用的参数如表 3.1 所示。 表：(#tab:df-print) html_document 可以被设置的 df_print 参数及其对应的含义。 取值 说明 default 使用 print.data.frame 函数 kable 使用 knitr::kable 函数 tibble 使用 tibble::print.tbl_df 函数 paged 使用 rmarkdown::paged_table 来创建一个分页的表格 除了几种预定义的样式外，df_print 还可以接受一个自定义函数精确控制打印表格的细节。例如，kable 样式也可以通过自定义函数定义： --- output: html_document: # 等同于 df_print: kable df_print: !expr print.me &lt;- function(x, ...) { knitr::knit_print(knitr::kable(x, ...))} --- !expr 可以在 YAML 元数据插入代码，详情可见文档 ?yaml::yaml.load() 。自定义函数 print.me() 将被用于打印数据框输出。 如果数据框的打印函数较为复杂，不适于插入 YAML，另外一种办法是覆盖 knitr::knit_print() 函数在 data.frame 对象上的方法，如下所示： --- output: html_document --- ```{r setup, include=FALSE} library(kableExtra) library(knitr) print.me &lt;- function(x, ...) { x |&gt; kbl(digits = 2, align = &quot;l&quot;, booktabs = T) |&gt; kable_styling(fixed_thead = T, position = &quot;float_right&quot;) |&gt; kable_paper(&quot;striped&quot;, full_width = T, fixed_thead = T, html_font = &quot;Helvetica&quot;, font_size = 11 ) |&gt; row_spec(0, color = &quot;yellow&quot;, background = &quot;#5b705f&quot;, font_size = 12) %&gt;% scroll_box(width = &quot;700px&quot;, height = &quot;300px&quot;) %&gt;% asis_output() } registerS3method(&quot;knit_print&quot;, &quot;data.frame&quot;, print.me) ``` ```{r} head(cars) ``` 图 3.9: 用自定义函数控制数据框的打印格式 3.1.3.4 分页打印数据框时的附加参数 若把 df_print 参数设为 paged，数据框将支持行列的分页，效果如图 3.10 所示。 --- title: &quot;发动机测试和汽车道路测试&quot; output: html_document: df_print: paged --- ```{r} mtcars ``` 图 3.10: HTML文档中分页显示的数据框 表 @ref(#tab:paged) 列出了这种情况下可以使用的附加参数。 表 3.2: 分页 HTML 表格的附加可用参数。 参数名 说明 max.print 显示的总行数 rows.print 一页显示的行数 cols.print 一页显示的列数 cols.min.print 最少显示几列 pages.print 下方显示页面导航链接的数目 paged.print 设为 FALSE 则不输出分页的表格 rownames.print 设为 FALSE 时不显示行的名称 这些参数可以在代码块中使用。 ```{r cols.print=3, rows.print=3} mtcars ``` 3.1.4 组件和内容 3.1.4.1 理解 HTML 文档的依赖关系 R Markdown 输出 HTML 文档时依赖于软件包提供的 HTML 模板。 实际上，HTML 文档的样式和功能很大程度上依赖于一些 CSS 样式和 JavaScript 库的支持。 这里面包括 Bootstrap15，JQuery 等优秀的开源项目。前者是一个通用的网站开发框架，后者是一个通用的 JavaScript 库。 默认情况下，R Markdown 输出的 HTML 文档是一个单一的 .html 文件。这是由 self_contained: true 控制的。.html 文件中，会使用 data: 存储包括 JavaScript、CSS、图片和视频在内的全部资料。这样的一个封装，使得用户可以像分享 PDF 或 Word 文档那样分享文件，同时享受超链接、动态效果等一系列 HTML 特性。 如果指定 self_contained: false，那么 HTML 文档将会将自身的依赖文件单独存放。 --- title: &quot;标题&quot; output: html_document: self_contained: false --- 默认情况下，在 .html 文件同一目录会生成同名的 _files 文件夹，存放相应的依赖文件。下面是默认情况下一份 HTML 文档所包含的依赖文件。 +---anchor-sections-1.0 +---bootstrap-3.3.5 | +---css | | \\---fonts | +---fonts | +---js | \\---shim +---header-attrs-2.5 +---highlightjs-9.12.0 +---jquery-1.11.3 \\---navigation-1.1 存放这些依赖文件的文件夹位置可以由 lib_dir: xxx 指定，例如： --- title: &quot;标题&quot; output: html_document: self_contained: false lib_dir: libs --- 依赖文件的内容会随配置变化，例如当在 YAML 配置中加入 df_print: paged 之后，依赖文件中会增添一个pagedtable-1.1 子文件夹。 依赖文件夹按照 库名 + 版本号 的规则命名。R Markdown 会自动负责引用和维护这些依赖文件，因此绝大部分情况下用户不需要关心依赖文件的具体内容。 当单个文档体积较小，同时又有多个类似的文档的时候，如果每个文档都生成自己的那一份依赖文件就会浪费磁盘空间。这种情况下，将库文件统一存储在指定的 libs 文件夹，可以实现库文件公用。 对于一些体积较大的依赖库，R Markdown 不会将其下载到用户的电脑上，而是通过远程 CDN 链接引入。例如第 @ref(#html-mathjax) 中的 MathJax 库。 3.1.4.2 MathJax 库的配置 HTML 文档需要 MathJax 脚本来渲染 Latex 和 MathML 公式16，调用 MathJax 的方式则可以通过 mathjax 参数来调整。 \"default\"：默认配置，会通过 HTTPS 链接从 RStudio 的 CDN 网络服务器上调用； \"local\"：与 self_contained: false 联合使用时，会将 MathJax 库文件保存在本地目录中； 还可以将 mathjax 的值设置成一个 URL 链接，指向可用的 MathJax 库文件地址； null：完全不使用 MathJax。 例如，使用 MathJax 的本地拷贝可以如下配置： --- title: &quot;标题&quot; output: html_document: mathjax: local self_contained: false --- 为 MathJax 配置一个新的可用来源。 --- title: &quot;标题&quot; output: html_document: mathjax: &quot;http://example.com/MathJax.js&quot; --- 不使用 MathJax。 --- title: &quot;标题&quot; output: html_document: mathjax: null --- 3.1.4.3 是否保留 Markdown knitr 处理 R Markdown 文件时，会先生成一个 Markdown 文件（*.md），随后再由 Pandoc 转换成 HTML 文档。如果需要保留这个 Markdown 文件，可以使用 keep_md 选项。 --- title: &quot;标题&quot; output: html_document: keep_md: true --- 3.1.4.4 使用自定义的 HTML 模板 使用 template 选项，可以配置 Pandoc 转换时使用的模板。 --- title: &quot;标题&quot; output: html_document: template: another_template.html --- Pandoc 模板遵循特定的格式，有关的进一步信息可以在 Pandoc 模板 页面获得。 下面是一个 HTML 模板的示例： &lt;html&gt; &lt;head&gt; &lt;title&gt;$title$&lt;/title&gt; $for(css)$ &lt;link rel=&quot;stylesheet&quot; href=&quot;$css$&quot; type=&quot;text/css&quot; /&gt; $endfor$ &lt;/head&gt; &lt;body&gt; $body$ &lt;/body&gt; &lt;/html&gt; 这其中包括一些变量，如 $title$，$body$ 等。这些变量由 Pandoc 定义，完整的变量列表可以参考 Pandoc 的官方文档。 这样的 HTML 模板使得高度定制化的输出成为可能。例如，可以在 &lt;head&gt; 区域加入任意的 CSS 样式， JavaScript 代码，以及其它的开源库。 另外，还可以定义一些新变量来控制文档的格式化。例如，定义一个布尔值 draft 来确定文档是一个草稿还是最终版本。 &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; .logo { float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;logo&quot;&gt; $if(draft)$ &lt;!-- 使用 draft.png 以表明这是一份草稿 --&gt; &lt;img src=&quot;images/draft.png&quot; alt=&quot;您正在阅读的是一份草稿&quot; /&gt; $else$ &lt;!-- 在最终版本中插入正式 LOGO --&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;您正在阅读本文档的正式版本&quot; /&gt; $endif$ &lt;/div&gt; $body$ &lt;/body&gt; draft 变量可以通过 YAML 元数据来赋值。这样根据 draft 设定的不同值，R Markdown 可以编译出具有不同 LOGO 图像的 HTML 文档，从而可以直观的显示读者目前看到的这份文档是一个草案还是最终版本。 --- title: &quot;一份重要的报告&quot; draft: true output: html_document: template: my-template.html --- 说明：rmarkdown 软件包默认使用自带的 HTML 模板，一些方面与 Pandoc 默认的模板存在差异。如果有 template: null 的话，则 Pandoc 的模板会被使用。 3.1.4.5 包含其它文件 使用 includes 选项，可以在 HTML 文档的不同位置嵌入其它的 HTML 格式内容。可选的位置包括在 HTML 文档的 header、body 前/后等17。 --- title: &quot;标题&quot; output: html_document: includes: in_header: header.html before_body: doc_prefix.html after_body: doc_suffix.html --- 这种方式可以很方便的为文档加入一些第三方功能和公用的元件。例如在 in_header 中导入预定义的 CSS 样式表和 Javascript 脚本，在 before_body 中加入导航栏，在 after_body 中加入一个底栏等。 下面的例子中，即添加了一个简单的底栏。将其中内容保存到一个 HTML 文件中，放在 after_body 后面即可。 &lt;div class=&quot;footer&quot;&gt;Copyright &amp;copy; R Markdown 指南 2021&lt;/div&gt; 除了以上几种常用的位置，还可以在任意地方插入 HTML 内容。实现这一功能的途径至少有两种。 一是使用 htmltools::includeHTML() 方法： ```{r, echo=FALSE, results=&#39;asis&#39;} htmltools::includeHTML(&quot;file.html&quot;) ``` 二是使用 xfun::file_string() 方法： ```{r, echo=FALSE, results=&#39;asis&#39;} xfun::file_string(&quot;file.html&quot;) ``` 需要注意的是，导入的 HTML 文件必须是 HTML 片段 (见第 3.1.4.6 节)，而不能是一个完整的 HTML 文档。完整的 HTML 文件中有 &lt;html&gt; 标签，解析时会造成错误。比如下面就是一个无效的例子： &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; 父 HTML 文件。 &lt;!-- htmltools::includeHTML() 将插入下列 HTML 代码 --&gt; &lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; 子 HTML 文件。 &lt;/body&gt; &lt;/html&gt; &lt;!-- 上面的内容即插入的 HTML 代码，插入后新文档的解析会出错 --&gt; &lt;/body&gt; &lt;/html&gt; 3.1.4.6 生成 HTML 片段 HTML 片段是一个不完整的 HTML 文件，通过输出格式 html_fragment 控制。例如： --- title: &quot;输出一个 HTML 片段&quot; output: html_fragment --- HTML 片段可以有标题和代码区域，但是不包含任何 CSS 定义。 ```{r} head(mtcars) ``` 上面文档的编译输出是： &lt;p&gt;HTML 片段可以有标题和代码区域，但是不包含任何 CSS 定义。&lt;/p&gt; &lt;pre class=&quot;r&quot;&gt;&lt;code&gt;head(mtcars)&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt; &lt;code&gt; ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 &lt;/code&gt; &lt;/pre&gt; 以上 HTML 片段导入本节后的内容是： HTML 片段可以有标题和代码区域，但是不包含任何 CSS 定义。 head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 HTML 片段的内容到此结束。 HTML 片段仅包括用于显示内容的最小代码，不包含 &lt;html&gt;, &lt;body&gt; 等标签，也不携与主题或代码高亮相关的依赖文件。这样的好处是可以将它们嵌入到其它人意 HTML 文档中，而不会造成标签冲突。嵌入对象不一定是 R Markdown 生成的，例如可以为博客网站嵌入一个 R Markdown 生成的图表片段， 3.1.4.7 使用自定义的浏览器图标 通过在 in_header 部位导入 HTML 内容，可以为 HTML 文档设定一个自定义的浏览器图标。 将下面的内容保存到一个名为 header.html 的文档中。 &lt;link rel=&quot;shortcut icon&quot; href=&quot;{path to favicon file}&quot; /&gt; 然后通过 includes 导入文件的内容，则可以改变浏览当前文档时的浏览器图标。 output: html_document: includes: in_header: header.html 3.1.4.8 共用 YAML 配置文件 当前目录中的 _output.yml 文件是一个配置文件，其中的设置可以被目录下所有的 R Markdown 文档公用。需要注意的是，该文件中的内容会在编译时加载到 output 选项中，因此 _output.yml 不应该定义 output 选项，而应该直接设置 output 选项中的子选项。如下所示： html_document: self_contained: false theme: united highlight: textmate 错误的做法是在 _output.yml 中定义 output 选项： --- # 错误：这里不需要 output output: html_document: self_contained: false theme: united highlight: textmate --- 3.1.4.9 允许下载源文件 当分享一个 R Markdown 生成的 HTML 文档给他人的时候，对方可能还需要提供 .Rmd 源文件。在头文件中配置 code_download 参数可以在 HTML 文档中嵌入源文件。 output: html_document: code_download: true 打开 code_download 选项后，页面中会出现一个下载按钮，点击下载按钮即可获得源文件。 3.1.4.10 嵌入数据或其它文件 嵌入 .Rmd 源文件可能还不足以重现 R Markdown 中结果，通常还会需要原始数据等其它内容。要将这些内容嵌入 HTML 文档中，也是很容易实现的。 这一功能通过 xfun 软件包(Xie 2022f) 实现，依赖于 htmltools 和 mime 软件包。要使用这一功能，首先确保这两个软件包可用。 xfun::pkg_load2(c(&quot;htmltools&quot;, &quot;mime&quot;)) 现在，就可以随意嵌入各种文件了。 ```{r echo=FALSE} # 不但可以嵌入一个文件 xfun::embed_file(&#39;source.Rmd&#39;) # 还可以嵌入多个文件 xfun::embed_files(c(&#39;source.Rmd&#39;, &#39;data.csv&#39;)) # 甚至一个目录也不在话下 xfun::embed_dir(&#39;data/&#39;, text = &#39;Download full data&#39;) ``` 不仅如此，还可以用正则表达式批量嵌入文件。 # 嵌入当前目录下所有的 Rmd 和 csv 文件 xfun::embed_files(list.files(&quot;.&quot;, &quot;[.](Rmd|csv)$&quot;)) 当嵌入多个文件时，R Markdown 首先将这些文件压缩成 Zip 格式，然后将 Zip 文件嵌入到 HTML 文档中。 3.2 PDF 文档 这一部分讲述将 R Markdown 输出为 PDF 的功能。PDF 是便携式文档格式（Portable Document Format）的缩写，这是一种常见的文档格式， 特别是在文件、学术论文中广泛使用。它具有文件体积小、保真度高和安全的特点。 R Markdown 并不能直接输出 PDF 文档，而是会输出 LaTeX 文件，LaTeX 文件经过处理后生成 PDF。因此，使用 R Markdown 输出 PDF 文件时，可以充分发挥 LaTeX 的优势。在需要的时候，可以直接使用 LaTeX 代码编写内容，应用 LaTeX 的包和模板，添加标题、脚注、子图等。 不过，LaTeX 技术对于大多数人可能都还比较陌生，而在生成 PDF 文档的过程中，很多问题都跟 LaTeX 的配置有关。这几乎是不可避免的，因此在开始正式的内容前，需要确保已经安装了 TinyTex 以及一些依赖的 LaTeX 组件。具体的安装步骤和疑难解答请参见前文（2.2.1），此处不再赘述。 3.2.1 从 R Markdown 到 PDF 文档 要输出 PDF 文档，只需要在 R Markdown 开头的 YAML 配置中指定 pdf_document 即可。 --- output: pdf_document --- 只需要这样一个改动，就可以得到一份 PDF 文档。 3.2.2 在 PDF 文档中使用中文的注意事项 如果这份 PDF 中仅含有英文，那么不需要做额外的设置。 但是对于中文用户而言，可能会出现错误。这是因为，PDF 所依赖的 LaTeX 系统对中文的支持与 HTML 不同，需要做一些合适的设置。包括导入中文语言支持的 LaTeX 模块 ctex，以及使用一个对 Unicode 支持更好的 xelatex 引擎。 下面就是一份中文 PDF 文档的示例。 --- title: &quot;这是一个 R Markdown 生成的 PDF 文档&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document: latex_engine: xelatex header-includes: - \\usepackage{ctex} --- 既然你在看这本书，想必你想制作的 PDF 文档难免会包括中文。 要想让 PDF 更好的支持中文，需要做一些额外的设置。 包括设置一个对 Unicode 支持更好的 `xelatex` 引擎，以及在 PDF 文档开始的配置部分 使用中文语言支持软件包 `ctex`。 我们接下来将会分别介绍这些功能。 将这份 R Markdown 编译后，将会生成一份 PDF 文档。 3.2.3 与 HTML 文档相通的设置 下面的这些设置与前文介绍的 HTML 文档中相应配置的用法基本相同，参考第 3.1 节。 3.2.3.1 显示目录 使用 toc 在 PDF 文档中加入目录，toc_depth 控制目录的深度。这点与 HTML 文档的用法一致18。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： toc: true toc_depth: 2 --- 如果 toc_depth 没有指定，则默认索引到二级标题（在 HTML 文档中默认索引到三级标题）。 使用 number_sections 可以在标题前面加入编号。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： toc: true toc_depth: 2 number_sections: true --- 3.2.3.2 图片相关的配置 fig_width 和 fig_height 用于控制图片默认的宽和高（默认为 6.5 x 4.5 英寸）。 fig_crop 控制 pdfcrop 的效果，功能是去掉图片边缘的空白（默认为 true）。 pdfcrop 是一个 LaTeX 组件，默认并没有被 tinytex 安装。推荐用户运行 tinytex::tlmgr_install(\"pdfcrop\") 来安装它。同时，pdfcrop 依赖于系统中的存在的 ghostscript，因此还需要安装 ghostscript 才能正常使用 pdfcrop。 fig_caption 控制是否为图片添加图注（默认为 true）。 dev 控制用于渲染图片的图像设备（默认为 pdf）。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： fig_width: 7 fig_height: 6 fig_caption: true --- 3.2.3.3 打印数据框 通过 df_print 控制数据框打印的原理在 PDF 中与 HTML 相同，见表 3.1。 3.2.3.4 代码高亮 与 HTML 文档相同，这里可用 highlight 参数配置代码高亮的样式（见第 3.1.2 节）。例如： --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： highlight: tango --- 3.2.4 LaTeX 选项 很多 LaTeX 选项都可以通过 YAML 头部传递给 PDF 编译工具。 3.2.4.1 通用文档部件 一个 LaTeX 文档的结构如下： \\documentclass{article} % 序言/preamble \\begin{document} % 主体/body \\end{document} 在这个文档中，首先通过 \\documentclass{} 指定了文档的类，然后在序言部分（preamble）导入一些 LaTeX 的包（组件）和进行必要的设置，接下来在 \\begin{document} 后开始文档的主体内容。 一个 R Markdown 文档基本上都是在配置主体部分（body）的内容。 如果需要在序言部分加入一些内容，则可以使用 includes 选项。该选项包括 3 个 部分：in_header，before_body 和 after_body。每一个都支持一个或多个文件路径。 in_header 指定文件的内容将会被添加到序言部分，before_body 和 after_body 指定文件的内容会分别被添加到文档主体的前面和后面。 一个常见的应用是在序言部分加入自定义 LaTeX 命令或环境，例如下面的 LaTeX 命令可以为正文中的每一个超链接的链接地址添加脚注： % 在添加脚注前先保存 \\href 的值 % \\let\\oldhref\\href \\renewcommand{\\href}[2]{#2\\footnote{\\url{#1}}} 将上面的代码保存到 preamble.tex 文件中，用 in_header 选项将其添加到序言部分： output: pdf_document: includes: in_header: &quot;preamble.tex&quot; 不过，Pandoc 默认的 LaTeX 模板中已经内嵌了这一用法，所以实际上可以直接设置 links-as-notes 为 true 即可。 output: pdf_document: links-as-notes: true 在本书的 PDF 版本中，就使用了这种方法来添加页眉、页脚等内容。 3.2.4.2 选择 LaTeX 模板 通过 template 可以指定输出 PDF 文档时采用的 LaTeX 模板。 --- output: pdf_document: template: quarterly-report.tex --- 3.2.4.3 配置 LaTeX 模板的参数 每个 LaTeX 模板会有很多参数，用来指定文档的语言、字体、文字大小、页边距等内容。 表 3.3 列示了常见的一些参数，完整的参数则可以在 Pandoc 手册 中查看。 表 3.3: 在 YAML 配置中可用的 LaTeX 变量 变量名称 说明 lang 文档的语言代码 fontsize 文字大小 （如 10pt，11pt，12pt） documentclass LaTeX 文档类型 （如 article） classoption 文档类型的选项（如 oneside） geometry 页边距（如 margin=1in） mainfont, sansfont, monofont, mathfont 文档的字体（仅在使用 xelatex 和 lualatex 时可用） linkcolor, urlcolor, citecolor 内部链接、外部链接和引文链接的颜色 使用这些参数的时候，需要将其写在 YAML 头信息的最顶层，例如： --- title: &quot;这是一个PDF&quot; output: pdf_document fontsize: 11pt geometry: margin=1in --- 3.2.5 使用 LaTeX 包处理参考文献 默认情况，文档中的引用使用 pandoc-citeproc 来处理，这种方法不限制输出文档的类型，适用性最广。 不过，在 LaTeX 系统中也有非常优秀的引用工具，例如 natbib 和 biblatex。 如果想使用它们，只需要在 citation_package 中指定即可19。 --- output: pdf_document: citation_package: natbib --- 3.2.6 LaTeX 的渲染引擎 PDF 文档默认通过 pdflatex 渲染。其它可用的引擎还包括 pdflatex，xelatex和lualatex等。 不同的引擎可通过 latex_engine 来选择。 一般情况下，使用 xelatex 或者 lualatex 的主要理由是它们对 Unicode 的支持更加优秀，以及它们更容易使用系统中已有的字体20。 --- output: pdf_document: latex_engine: xelatex --- 3.2.7 保留生成的 TeX 中间文件 R Markdown 首先转化为 TeX 文件，然后才能转化为 PDF 文档。默认情况下，PDF 文档生成后，TeX 文档将会被删除。通过改变 keep_tex 的设置，可以保留生成的 TeX 文档（可用于向某些杂志投稿）。 --- output: pdf_document: keep_tex: true --- 3.3 PPT 幻灯片 本章讲述使用 R Markdown 生成幻灯片（俗称“PPT”）的技巧。 幻灯片可以被看做一个精简的文档，它的基本单位是单独的一页，每页含有标题、内容和其它元素。R Markdown 文档可以直接输出为 HTML 或者 PDF 格式的幻灯片，并且可以通过额外的软件包丰富幻灯片的具体样式。这一部分将首先介绍 R Markdown 基础幻灯片的使用，然后介绍如何使用 xaringan 软件包创建更加具有科技感的幻灯片。 使用基础幻灯片不需要安装额外的包。 R Markdown 支持 4 种不同样式的幻灯片，分别是 ioslides，Slidy，Beamer 和 PowerPoint。 在 RStudio 中，可以通过菜单中的 “New File -&gt; R Markdown…” 打开如下一个窗口（图 3.11），然后选择 “OK” 后即可新建一个幻灯片。 以上介绍的 5 种幻灯片格式中（含 xaringan），ioslides、Slidy 和 xaringan 都是基于 HTML 技术实现的（文档扩展名为 .html），Beamer 是基于 LaTeX 实现的（文档扩展名为 .pdf），PowerPoint 则是基于微软 Office 的文档格式实现的（文档扩展名为 .pptx）。 图 3.11: 新建 R Markdown 时可选的幻灯片格式 3.3.1 ioslides 幻灯片 首先看 ioslides 幻灯片。新建的幻灯片，也是一个 R Markdown 文档，在它的头部 YAML 中， output: ioslides_presentation 设定了其输出格式。 --- title: &quot;Ioslides Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: ioslides_presentation --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` 这个文档经过编译后，得到的幻灯片如图 3.12 所示。 由此可见，在 R Markdown 幻灯片中，源文件中的 ## 代表一张幻灯片的开头和标题， ## 后面的内容是这一张幻灯片中的内容。R Markdown 会自动将命令和输出的内容添加到幻灯片中。 图 3.12: 新建文件编译后生成的 ioslides 幻灯片 除了 ##，使用 --- 也能开始一张新的幻灯片，并最终生成一个不带标题的幻灯片。 另外，还可以通过 “|” 来为幻灯片添加副标题。例如下面的例子： ## 起床 | 今天准备干点什么呢 3.3.1.1 使用快捷键控制显示模式 ioslides 幻灯片支持以下快捷键更改播放时的模式： 'f'：全屏模式，幻灯片将会占满屏幕。 'w'：宽屏模式，幻灯片将会以宽屏模式显示。 'o'：预览模式，幻灯片将会缩小并同时显示多个。 'h'：启用代码高亮模式，突出显示指定的几行代码。具体使用方法下面介绍。 'p'：显示演讲者备注，演讲者备注需要以指定的方式添加。具体使用方法下面介绍。 按下 'Esc' 键将会退出以上所有模式。 3.3.1.2 依次显示列表中的项目 使用 incremental 选项可以控制列表项目依次出现，相当于添加了简单的播放动画。 --- output: ioslides_presentation --- # ioslides 幻灯片 {data-background=ioslides-presentation.png data-background-size=cover} 一级标题产生了一个背景为灰色的幻灯片，我们为它加入了背景图片。 ## 列表项的内容 | 这里加入了一个副标题 默认情况下，整个幻灯片将会同时显示。 - Bullet 1 - Bullet 2 - Bullet 3 ## 列表项的内容 {.smaller} 但是 `&gt;` 可以作用于列表，这样以下内容将会在播放时依次出现（点击鼠标或者使用键盘）。 &gt; - Bullet 1 &gt; - Bullet 2 &gt; - Bullet 3 ## 下面的内容将会依次显示 {.build} 幻灯片标题后面的 `{.build}` 将会为这张幻灯片添加一个效果。首先显示这一段话，然后才显示下面的列表。 - 这个列表中的项目并不会依次显示 - 而是会作为一个整体出现 接下来的列表，因为使用了 `&gt;` 方法，其中的项目则可以依次出现。 &gt; - 先出现这个 &gt; - 然后才是这个 ## Future Steps {#future-steps .emphasized} 在 `style.css` 中，添加下列定义。 ```{css} #future-steps { color: blue; } .emphasized { font-size: 1.5em; } ``` 这几个字特别重要。 ## 代码高亮 大家看，这两步运算非常关键。 ```{r} cat(&#39;接下来进入计算过程&#39;) ### &lt;b&gt; x &lt;- 10 y &lt;- x * 2 ### &lt;/b&gt; cat(&#39;计算完毕&#39;) ``` 为所有幻灯片添加这样的效果有时候显得有点过分，所以 R Markdown 还提供了针对个别幻灯片 添加依次呈现效果的方法，即在前面加上一个 &gt; 号。 &gt; - 项目 1 &gt; - 项目 2 3.3.1.3 幻灯片适配宽屏幕显示器 在配置中使用 widescreen 可以将幻灯片样式改为宽屏。 --- output: ioslides_presentation: widescreen: true --- 3.3.1.4 幻灯片播放速度 ioslides 幻灯片翻页时会有淡入淡出的效果，使用 transition 可以控制效果的时长。 transition 设置为 \"default\"，\"slower\"，\"faster\"，或者一个以秒为单位的数字（如0.5）均可。如下所示： --- output: ioslides_presentation: transition: slower --- 3.3.1.5 依次显示幻灯片元素 每一张幻灯片的标题都可以加上 .build 属性，这样幻灯片的内容在播放的时候将会一块块的依次显示出来。 这一点与 incremental 属性有些类似，不过后者针对的是列表中的项目，而前者针对的是 一段话，一整个列表。 ## 下面的内容将会依次显示 {.build} 首先显示这一段话，然后才显示下面的列表。 - 这个列表中的项目并不会依次显示 - 而是会作为一个整体出现 接下来的列表，因为使用了 `&gt;` 方法，其中的项目则可以依次出现。 &gt; - 先出现这个 &gt; - 然后才是这个 3.3.1.6 设置幻灯片的背景图像 幻灯片中可以使用 data-background 添加背景图片，并使用其它的相关属性来 配置背景图片的行为，如 data-background-size， data-background-position， data-background-repeat 等等。 ## 添加背景图像 {data-background=foo.png data-background-size=cover} 这些配置来自于 CSS 中图片的属性，background，background-size，background-position， 以及 background-repeat 等。用户可能需要对 CSS 有所了解，才能准确把握这些属性的用途。 3.3.1.7 使用自定义 CSS 因为 ioslides 幻灯片本质上是一个 HTML 文档，所以可以像 HTML 文档一样通过自定义 CSS 来设定幻灯片中不同元素的样式。 要在幻灯片中附加一个自定义样式表，可以使用 css 属性。 --- output: ioslides_presentation: css: styles.css --- 为某一张幻灯片中添加样式的方式，也是通过大括号语法完成的。 ## Future Steps {#future-steps .emphasized} 这张幻灯片中的所有元素将会应用 CSS 定义的样式。 在 style.css 中，添加下列定义。 #future-steps { color: blue; } .emphasized { font-size: 1.2em; } 这种方式并不会影响幻灯片的标题，而是会影响这一张幻灯片中其它内容。 最终，这张幻灯片中所有的文字都会显示为蓝色、120% 的大字号。 3.3.1.8 突出显示部分代码 为了强调关键代码的作用，可以使用特定的注释来高亮它们。例如： ### &lt;b&gt; x &lt;- 10 y &lt;- x * 2 ### &lt;/b&gt; 在播放时，当按下键盘上的快捷键 'h' 时，高亮的代码将会突出显示，其它部分的代码则会变淡。 3.3.1.9 添加 LOGO 使用 logo 可以为幻灯片添加一个 LOGO 图片。默认情况下，这个 LOGO 将会以 85 x 85 像素显示在标题幻灯片上，并且缩小后显示在后面每一张幻灯片的左下角。 --- output: ioslides_presentation: logo: logo.png --- 使用自定义的 CSS 可以修改首页 LOGO 的显示效果。例如： .gdbar img { width: 300px !important; height: 150px !important; margin: 8px 8px; } .gdbar { width: 400px !important; height: 170px !important; } 左下角的 LOGO 显示样式同样可以使用 CSS 定义。例如： slides &gt; slide:not(.nobackground):before { width: 150px; height: 75px; background-size: 150px 75px; } 3.3.1.10 幻灯片的布局 如果想居中显示幻灯片的内容，可以在标题后面加入 .flexbox 和 .vcenter 的属性。 ## 统统居中显示 {.flexbox .vcenter} 使用 CSS class 的方法为美化幻灯片非常灵活。但是在标题中应用样式不能精确到一张 幻灯片中的某个具体元素。因此要实现幻灯片的复杂布局，只能使用类似 HTML 的语法。 居中显示某一段文字，可以采用下面的语法。 &lt;div class=&quot;centered&quot;&gt; 这部分文本将会居中显示。 &lt;/div&gt; 如果要以左右两栏的形式展示某一张幻灯片中的内容，可以使用下面的语法21。 &lt;div class=&quot;columns-2&quot;&gt; ![](image.png) - 项目 1 - 项目 2 - 项目 3 &lt;/div&gt; 3.3.1.11 文字颜色 使用 HTML 语法还可以修改其它的属性，比如文字的颜色。只需要将颜色以 CSS 类的形式赋值给元素即可。例如： &lt;div class=&quot;red2&quot;&gt; 这部分文本将显示为红色。 &lt;/div&gt; 可用的颜色包括 red，blue，green，yellow，grey等，以及它们的变体如 red2，blue3，green4等等 3.3.1.12 打印幻灯片 打印幻灯片可以在浏览器中进行，目前保真度最高的浏览器可能是 Google Chrome。 此外，使用 Chrome 中 “另存为 PDF” 的功能，还可以将幻灯片保存为一份 PDF 文档。 在 R 语言终端，使用 pagedown::chrome_print() 函数也可以完成这一操作（便于自动化和批处理）。 不过需要事先安装 pagedown 软件包(R-pagedown?)。 3.3.1.13 其它功能 ioslides 幻灯片中，通用的 R Markdown 语法通常可用，包括 HTML 文档输出中的配置， 图片的属性设置，数学公式，数据库的打印，中间文件的保留，外部文档的引入等等。 3.3.2 Slidy 幻灯片 Slidy 是 HTML 幻灯片的另一个规范。 要通过 R Markdown 创建一个 Slidy 幻灯片，只需要将文档输出设为 slidy_presentation 即可。 --- title: &quot;Slidy Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: slidy_presentation: font_adjustment: +1 footer: &quot;Copyright (c) 2021, Cosname&quot; duration: 45 --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown {.smaller} This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets {.bigger} - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` Slidy 幻灯片的内容设置基本与 ioslides 幻灯片相似，不过其默认样式与之有异。 一份 Slidy 幻灯片大体是这样的（图 3.13）。 图 3.13: Slidy 幻灯片 3.3.2.1 使用快捷键控制显示模式 Slidy 中也可以通过快捷键控制显示模式，不过其按键定义与 ioslides 不同。 'c'：显示幻灯片目录。Slidy 会自动生成目录，默认可以通过点击页脚左下角的 “Contents” 访问。 'f'：是否显示页脚的开关。 'a'：显示全部幻灯片的开关。 's'：缩小字体大小。 'b'：放大字体大小。 3.3.2.2 设置页脚内容 在 YAML 配置中使用 footer 可以为幻灯片设置页脚显示的内容。 --- output: slidy_presentation: footer: &quot;Copyright (c) 2021, Cosname&quot; --- 使用 duration 还可以方便的在页脚添加一个计时器（单位为分钟）。 --- output: slidy_presentation: duration: 45 --- 3.3.2.3 其它功能 Slidy 幻灯片继承了 HTML 文档中的多数功能（3.1），以及 ioslides 中的列表内容依次显示等功能（参见 3.3.1）。 3.3.3 Beamer 幻灯片 Beamer 是一个功能强大且灵活的 LaTeX 类，用于创建美观的幻灯片。 要从 R Markdown 创建 Beamer 幻灯片，只需要在 YAML 头文件中将输出格式设定为 beamer_presentation 即可。可以使用一级标题 # 和二级标题 ## 新建幻灯片 （使用 --- 也可以创建一张新的没有标题的幻灯片）。例如： --- title: &quot;Beamer Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: beamer_presentation: latex_engine: xelatex header-includes: - \\usepackage{ctex} --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## Beamer 幻灯片中的中文支持 要使用中文，需要做适当的配置，包括应用 `ctex` 包（支持中文的 LaTeX 包）和使用 `xelatex` 引擎。 与 HTML 格式的幻灯片相比，这可能是制作 Beamer 演示文稿时唯一需要额外做出配置的地方了。 ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` Beamer 幻灯片编译后的文件是一个 PDF 文档，图 3.14）。 图 3.14: Beamer 幻灯片示例 3.3.3.1 Beamer 幻灯片的中文支持 如果要生成中文的 Beamer 幻灯片，参考 3.2.2 中的设置。 3.3.3.2 Beamer 幻灯片的主题 Beamer 支持多个幻灯片主题，在 R Markdown 中使用 theme，colortheme 和 fonttheme 设定。 例如： --- output: beamer_presentation: theme: &quot;AnnArbor&quot; colortheme: &quot;dolphin&quot; fonttheme: &quot;structurebold&quot; --- 这个主题为标题幻灯片添加了页眉和页脚，显示作者、主题、日期和页码等信息，如图 3.15 所示。 图 3.15: 应用主题后的 Beamer 幻灯片 Beamer 支持数十个主题和颜色样式，在 这里 可以查看可用的选项。 (TODO?): (此部分可以扩展) 3.3.3.3 Beamer 幻灯片的边界 slide_level 参数用来指定一张幻灯片开始的位置。默认情况下，二级标题会被识别为一张幻灯片的开始，但是可以将它改为其它的大纲等级。 --- output: beamer_presentation: slide_level: 2 --- 3.3.3.4 Beamer 幻灯片的其它功能 Beamer 幻灯片从 HTML 文档中继承了目录内容、图片属性、样式、数据框打印、组件、 模板、Pandoc 参数和分享等功能（参加 3.1），从 PDF 文档和 ioslides 幻灯片中继承了列表动画、保留 TeX 文件等功能（参见 3.2, 3.3.1）。 3.3.4 PowerPoint 幻灯片 要制作 PowerPoint 幻灯片，只需要将输出格式设置为 powerpoint_presentation 即可。 这需要满足 rmarkdown 版本 ≥ v1.9，Pandoc 版本 ≥ 2.0.5 的条件22。 --- title: &quot;PowerPoint Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: powerpoint_presentation --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` R Markdown 生成的 PowerPoint 幻灯片如图 3.16）所示。 图 3.16: PowerPoint 幻灯片 PowerPoint 幻灯片采用的幻灯片标记与 Beamer 相同，默认为 3 级标题。使用 slide_level 可以控制新建一张幻灯片所需要的大纲等级。此外，使用 --- 可以新建一张没有标题的幻灯片。另外，R Markdown 中包括的图片和表格都会自动的被放到一张新的幻灯片中。也就是说，除了幻灯片的标题、图片/表格的标注之外，其它所有元素都不能与二者共存。这一点与其它格式幻灯片的行为有明显不同。 一般情况下，PowerPoint 幻灯片中的图片会被自动缩放到适合幻灯片的大小。如果自动缩放无效，那么对于静态图片可以使用 width 和 height 来分别设置，例如：![caption](foo.png){width=40%}。对于 R 语言生成的动态图形，则可以使用代码块的参数 fig.width 和 fig.height 来定义宽和高。 PowerPoint 幻灯片中可以使用的 Markdown 标记（参见 2.6）包括粗体、斜体，脚注，列表，LaTeX 数学表达式， 图片，表格等。 3.3.4.1 两栏布局 正如 Beamer 幻灯片的高级应用需要借助于 LaTeX 语法一样， PowerPoint 幻灯片的高级应用需要借助于对 Pandoc 的深入了解。 使用 Pandoc 的语法，可以设置一个多栏的布局（请参见 Pandoc 的用户手册）： :::::: {.columns} ::: {.column} 左侧栏目的内容 ::: ::: {.column} 右侧栏目的内容 ::: :::::: 3.3.4.2 自定义模板 PowerPoint 幻灯片的模板可以用 reference_doc 来设置。 模板中的样式将会被应用到 R Markdown 生成的 PowerPoint 幻灯片中。 --- title: &quot;使用自己喜欢的 PowerPoint 模板&quot; output: powerpoint_presentation: reference_doc: my-styles.pptx --- 3.3.4.3 其它功能 PowerPoint 幻灯片从 HTML 文档中继承了目录内容、图片属性、样式、数据框打印、组件、 模板、Pandoc 参数和分享等功能（参加 3.1）。 目前并不支持播放列表项目时候的动画效果。 3.3.5 Xaringan 幻灯片 虽然 R Markdown 提供的基础幻灯片已经能够实现了基本的幻灯片功能，而且没有额外的学习成本， 但是，善于制作精良幻灯片的“忍者”通常使用一个额外的包来创建幻灯片，这个包的名字叫做 xaringan。 xaringan 这个名字来源于火影忍者中的写轮眼 “Sharingan” （图 3.17）23。写轮眼有两大能力： 洞察眼 催眠眼 其实做演示就是将自己的洞见传递给听众；好的演讲通常有催眠效果，因为它可以深度震撼人心24。 图 3.17: 幻灯忍者：写轮眼 与其它工具相比，xaringan 创建的幻灯片样式更加精美，功能更加丰富，且具有高度的可定制性（图 3.18）。 图 3.18: xaringan 幻灯片的实例 3.3.5.1 Xaringan 的安装和入门 要创建“写轮眼”幻灯片，需要先安装 xaringan 软件包(Xie 2022e)）。 if (!requireNamespace(&quot;xaringan&quot;)) { install.packages(&quot;xaringan&quot;) } 安装完成之后，在 RStudio 中新建 R Markdown 文件，并在左侧选择 “From Template”，然后选择 “Ninja Presentation (Simplified Chinese)”。填写必要信息之后，即可创建一个新的“写轮眼”幻灯片（图 3.19）。 图 3.19: 创建一个新文档 然后点击 Knit 按钮编译文档，或者点击 RStudio 插件 “Infinite Moon Reader” 在 RStudio 里实时预览幻灯片（每次保存文档的时候，它会自动重新编译）。 原理： xaringan 将 R Markdown 的查克拉注入了 remark.js。浏览器中的幻灯片是 remark.js 渲染出来的，而它的 Markdown 源文档是从 R Markdown 生成的（实际上主要是 knitr）。 3.3.5.2 Xaringan 幻灯片的自动播放 播放设置 nature 下面的 autoplay 选项可以用来自动播放幻灯片，它的取值是毫秒，例如：每 30 秒播放一张片子： output: xaringan::moon_reader: nature: autoplay: 30000 nature 下面的 countdown 选项可以为每一页幻灯片添加一个（倒数）计时器，取值同样为毫秒，例如每一页片子都用 60 秒倒计时： output: xaringan::moon_reader: nature: countdown: 60000 3.3.5.3 Xaringan 幻灯片的快捷键 点击按键 h 或者 ? 之后可以看到所有快捷键示意图（图 3.20） knitr::include_graphics(&quot;images/xaringan-help.png&quot;, dpi = NA) 图 3.20: 展示所有快捷键 p 进入演讲者模式（可以看见自己写的注释，比如：提醒自己要讲的笑话，图 3.21）。 图 3.21: 进入演讲者模式 点击按键 c 可以复制幻灯片到新窗口。演讲时可以在自己面前的屏幕上显示演讲者模式，把新窗口中正常的幻灯片拖到大屏幕投影上给观众看（见图 3.22）。 图 3.22: 复制幻灯片到新窗口 3.3.6 Xaringan 幻灯片的扩展包 3.3.6.1 配置 Xaringan 幻灯片的主题 Aden-Buie 写了一个叫做 xaringanthemer 包(R-xaringanthemer?)的包，可以更改写轮眼幻灯片的主题，使用起来也非常方便，接下来看教程。 可以从 CRAN 或者 Github安装 xaringanthemer 包。 # 通过 CRAN 安装 install.packages(&quot;xaringanthemer&quot;) # 通过 Github 安装 # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;gadenbuie/xaringanthemer&quot;) 创建完新文档后，将 xaringan-themer.css 文件添加到 xaringan 幻灯片的 YAML 中。 output: xaringan::moon_reader: css: xaringan-themer.css 然后，在 chunck 中加载 xaringanthemer 并 设置主题 即可。下面给出一个简单的例子（图 3.23）， 展示了设置主题后的界面预览。当然该包还给出了很多其他主题，下面给出一些主题模板预览。 library(xaringanthemer) style_mono_accent( base_color = &quot;#1c5253&quot;, header_font_google = google_font(&quot;Josefin Sans&quot;), text_font_google = google_font(&quot;Montserrat&quot;, &quot;300&quot;, &quot;300i&quot;), code_font_google = google_font(&quot;Fira Mono&quot;) ) 图 3.23: xaringanthemer 包提供的主题示例 3.3.6.2 Xaringan 幻灯片自动匹配 ggplot 主题 xaringanthemer 包提供了 theme_xaringan() 函数，可用于修改 ggplot2 生成图片的主题，使图片与幻灯片主题中所配置的颜色和字体保持一致。 另外，xaringanthemer 建立在 showtext 包 (R-showtext?) 的基础上，可以使用更多的字体（包括系统提供的字体和网上的字体）。有关更多详细信息，可以在 ?scale_xaringan 和 vignette(“ggplot2-themes”)中找到（图 3.24）。 library(ggplot2) ggplot(diamonds) + aes(cut, fill = cut) + geom_bar(show.legend = FALSE) + labs( x = &quot;切割工艺质量&quot;, y = &quot;产品数量&quot;, title = &quot;钻石切割工艺质量与产品数量&quot;) + theme_xaringan(background_color = &quot;#FFFFFF&quot;) + scale_xaringan_fill_discrete() 图 3.24: xaringanthemer 包提供的 ggplot2 色板 3.3.6.3 Xaringanthemer 的自动补全功能 xaringanthemer 包对 Tab 键十分友好，该功能可以在查找每个主题中调整模板的函数。对应的 gif 演示可见官网教程。 图 3.25: xaringanthemer 支持自动补全功能 3.3.6.4 Xaringanthemer 提供的可选主题 该包提供各式各样的主题模板，可以根据喜好选择自己想要的主题，在正文开头加入以下代码，就会得到相应的模板了！这里给出 6 个模板函数以及对应的界面预览图，更多模板可见https://pkg.garrickadenbuie.com/xaringanthemer/articles/themes.html。 记得在使用以下函数前，先加载 xaringanthemer 包。 style_mono_light() style_mono_light(base_color = &quot;#23395b&quot;) 图 3.26: Moon Light 模板 style_mono_dark() style_mono_dark(base_color = &quot;#cbf7ed&quot;) 图 3.27: Mono Dark 模板 style_mono_accent() style_mono_accent(base_color = &quot;#43418A&quot;) 图 3.28: Mono Accent 模板 style_mono_accent_inverse() style_mono_accent(base_color = &quot;#43418A&quot;) 图 3.29: Mono Accent Inverse 模板 style_duo() style_duo(primary_color = &quot;#1F4257&quot;, secondary_color = &quot;#F97B64&quot;) 图 3.30: Duo 模板 style_solarized_light() style_solarized_light() 图 3.31: Solarized Light 模板 3.3.6.5 扩展 xaringan 幻灯片的功能 xaringanExtra 包(Aden-Buie and Warkentin 2022) 扩展了 Xaringan 幻灯片的功能，涵盖了很多写轮眼的并不具备的常用功能，具体如下所示： 并列方式展示演示文稿 在线编辑演示文稿 分享幻灯片样式 通过广播向观众实时播放幻灯片 在演示幻灯片上进行涂鸦 幻灯片切换时有声音提示 加入幻灯片切换动画 将选项卡面板加入幻灯片中 给幻灯片添加全局 logo 添加搜索框 使用 Tachyons CSS 实用程序工具包 添加网络摄像头进行实时视频 使用剪贴板添加一键式代码复制 从幻灯片开始就播放 GIF 调整幻灯片的大小以填充浏览器窗口 添加额外的 CSS 样式 这里仅仅列出了一些平时使用比较多的功能，在项目的 官方网站 另外列出了该软件包更多的特性。 可以从 GitHub 安装最新版本的 xaringanExtra。 # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;gadenbuie/xaringanExtra&quot;) 3.3.6.6 并列方式展示 Xaringan 幻灯片 使用方法：将以下代码块添加到幻灯片 R Markdown 文件中，之后对该 R Markdown 文件进行重新渲染。 ```{r xaringan-tile-view, echo=FALSE} xaringanExtra::use_tile_view() ``` 渲染后在幻灯片的放映界面中按 O 键（ Overview 的第一个字母）即可得到以下界面，再按 O 键即可回到默认形式。 图 3.32: 并列方式展示演示文稿 该功能类似 PowerPoint 中的幻灯片浏览模式。黄色的框表示当前所在的位置，可以通过鼠标直接切换到想要的位置。这个功能非常方便实用，而且操作简单，只要加入前面的代码就可以了。 3.3.6.7 在线编辑 Xaringan 幻灯片 这个功能无敌！可以在放映的幻灯片上直接书写内容，实时更新。主要是使用 .can-edit [...] 实现。 使用方法：只需将下面代码加入创建的 rmd 文档中： ```{r xaringan-editable, echo = FALSE} xaringanExtra::use_editable(expires = 1) ``` 使用 .can-edit[] 使幻灯片组件可编辑。 ## .can-edit[可以在此修改幻灯片的标题] 每当将幻灯片重新加载到浏览器中时，.can-edit 类的可编辑字段将被重置。如果要存储已编辑并使它们在浏览器会话之间持久存在，请为每个可编辑字段提供一个 .key-&lt;NAME&gt; 类。例如： ## .can-edit.key-firstSlideTitle[可以在此修改幻灯片标题并将修改后的标题保存到当前会话中] 对于更复杂的 HTML 元素，最好仅使一部分文本可编辑，例如 你好 .can-edit[张三]，欢迎光临！ 或者使用占位符文本。 ## 我所钟爱的东西 .can-edit.key-likes[ - 好东西甲 - 好东西乙 ] 官方给出了 gif 的演示。在教学的时候非常合适，可以增加与学生，观众的互动。 3.3.6.8 在 Xaringan 幻灯片上涂鸦 使用方法：只需在 rmd 文件中加入下面代码，重新编译即可得到这个效果。 ```{r xaringan-scribble, echo=FALSE} xaringanExtra::use_scribble() ``` 单击铅笔图标或按 S 键进行绘图。按 S 或启动绘图模式切换涂鸦工具箱。也可以使用橡皮擦来删除线条或单击“清除（trash）”按钮清除当前幻灯片上的所有涂鸦。 注意，当更改幻灯片时，图纸将保持在每张幻灯片上。在绘图模式下不能更改幻灯片。事实上，可以使用 ← 和→ 键来撤消或重做您的图纸。 如果想将幻灯片与涂鸦一起保存，最好的方法是从浏览器中打印演示文稿，官方给出了 gif 演示。 3.3.6.9 切换时 Xaringan 幻灯片时播放声音提示 使用方法：只需在 R Markdown 文件中加入下面代码，重新编译即可得到这个效果。当然，官方也给出了 gif 演示。 ```{r xaringan-slide-tone, echo=FALSE} xaringanExtra::use_slide_tone() ``` 3.3.6.10 Xaringan 幻灯片加入动画 使用方法：在 R Markdown 文件中加入下面代码 ```{r xaringan-animate-css, echo=FALSE} xaringanExtra::use_animate_css() ``` 然后将 animated 类和所需动画添加到对应的幻灯片中。下面给出一个代码的例子： 注意：退出动画只应用于退出时的幻灯片。 --- class: animated slideInRight fadeOutLeft ## 这张幻灯片将会…… - 一开始从屏幕右侧出现 - 并将会从屏幕左侧消失 这时，该张幻灯片将从右边滑入。如果想使所有幻灯片使用同一个转化形式，可以使用：use_animate_all()，代码如下（建议加到正文前部）。除此之外，官方给出了 gif 演示。 ```{r xaringan-animate-all, echo=FALSE} xaringanExtra::use_animate_all(&quot;slide_left&quot;) ``` 3.3.6.11 在 Xaringan 幻灯片使用选项卡 使用方法：在 R Markdown 文件中加入下面代码 ```{r xaringan-panelset, echo=FALSE} xaringanExtra::use_panelset() ``` 然后，创建一个包含若干个 .panel[] 的 .panelset [...]。每个 .panel [] 应该具有 .panel-name [] 和想写的内容，例如： .panel[.panel-name[NAME] 在此输入你的内容 ] 下面是演示幻灯片中使用的例子。 --- ## 我是庄闪闪 .panelset[ .panel[.panel-name[R Code] 欢迎关注[庄闪闪的R语言手册]呀！ ```{r panel-chunk,fig.align=&#39;center&#39;,out.width=&quot;60%&quot;} library(ggplot2) (g &lt;- ggplot(mpg) + aes(hwy, cty, color = class) + geom_point()) ``` ] .panel[.panel-name[Plot] &lt;center&gt;&lt;img src=&quot;https://octodex.github.com/images/labtocat.png&quot; height=&quot;300&quot; /&gt;&lt;/center&gt; ] ] 图 3.33 给出了上面代码的结果。官网给出了 gif 演示。 图 3.33: 将选项卡面板加入幻灯片中 要定制面板的外观，可以使用直接在幻灯片的 R 块中调用 style_panelset_tabs()。将下面代码加到前面的代码块下，这时代码块的颜色发生了变化。 ```{r echo=FALSE} xaringanExtra::style_panelset_tabs(foreground = &quot;honeydew&quot;, background = &quot;seagreen&quot;) ``` 3.3.6.12 给 Xaringan 幻灯片添加 LOGO 使用方法：在 R Markdown 文件中加入下面代码 ```{r xaringan-logo, echo=FALSE} xaringanExtra::use_logo( image_url = &quot;https://gitee.com/zhuang_liang_liang0825/other/raw/master/%E6%B8%A9%E5%B7%9E%E5%A4%A7%E5%AD%A6logo.png&quot; ) ``` 这时，所有幻灯片右上角都加上了对应的 LOGO 啦！如果想在某几张不显示 LOGO，可以使用 hide_logo 隐藏特定幻灯片的徽标，具体例子如下（图 3.34）： 图 3.34: 给幻灯片添加全局 logo 3.3.6.13 播放 Xaringan 幻灯片时使用摄像头 使用方法：在 R Markdown 文件中加入下面代码，然后重新渲染。 ```{r xaringan-webcam, include = FALSE} xaringanExtra::use_webcam() ``` 之后点击 w 键（记得用浏览器打开哦！）就会得到以下界面（图 3.35）。这里镜头的位置可以任意拖动。 图 3.35: 添加网络摄像头进行实时视频 当通过视频会议进行陈述时，包括演讲者的视频，或者在录制一节课或讲座时，这个功能真的非常好用！ 3.3.6.14 调整 Xaringan 幻灯片的大小 使用方法：在 R Markdown 文件中加入下面代码，然后重新渲染。 ```{r xaringan-fit-screen, echo=FALSE} xaringanExtra::use_fit_screen() ``` 使用快捷键 Alt / Option + F 使幻灯片适合屏幕，并忽略幻灯片比例（重新加载幻灯片以恢复正常）。官网给出了 gif 的演示。 3.4 Word 文档 要从 R Markdown 生成 Word 文档，可以使用输出格式 word_document。如果希望在文档中包含交叉引用，可以考虑输出格式 bookdown::word_document2，详细说明可见这。 --- output: word_document: default bookdown::word_document2: default # for cross-references --- 关于 Word 输出的最常见问题有： 如何将自定义 Word 模板应用于文档？ 如何在原始 R markdown 文件中纳入 Word 中所做的更改？ 如何更改单个文档元素的样式？ 本章将一一解答以上问题。 3.4.1 创建 word 模板 在 Rstudio 中打开一个新的 R 脚本并选择 Ducument 中的 Word（图 3.36）。 图 3.36: 新建 R Markdown 时可选的 word 格式 这时对应 R Markdown 文档中的 YAML 头所包含的内容为： --- title: &quot;标题&quot; author: &quot;张三&quot; date: &quot;6/26/2021&quot; output: word_document --- 之后就可以在这个模板下，将正文部分进行修改，并通过 Knit 进行编译。之后会跳出编译好的结果，通过系统默认应用打开。这就是基于 word 模板的工作流程。 3.4.2 自定义 Word 模板 可以将 Word 模板 文档中定义的样式应用到从 R Markdown 生成的新 Word 文档。 这种模板文档也称为“参考样式文档”。 关键之处：必须先通过 Pandoc 创建此模板文档，再更改其中的样式定义。 然后将此模板的路径传递给 word_document 的 reference_docx 选项，例如： --- output: word_document: reference_docx: &quot;template.docx&quot; --- template.docx 文档必须从 Pandoc 生成。 可以从具有 word_document 输出格式的任意 R Markdown 文档创建此模板（该文档的实际内容无关紧要，但它应该包含想要设置样式的元素类型）。 然后打开.docx 文件，并编辑样式。 图 3.37: 查找特定文档元素的样式。 图 3.37 说明了可以通过 Word 中的“主页”选项卡打开“样式”窗口。当将光标移动到文档中的特定元素时，样式列表中的项目将被突出显示。如果想修改任何类型元素的样式，可以单击突出显示项的下拉菜单，将看到如图 3.38 的对话框。 图 3.38: 修改 Word 文档中元素的样式。 修改完样式后，可以保存文档（使用一个不会被意外覆盖的文件名），并将其作为以后 Word 文档的模板。 当 Pandoc 使用该参考模板，并渲染出新的 Word 文档时，它会读取模板中的样式并将它们应用到新文档中。 如果想了解更多关于如何创建自定义样式 Word 模板的详细教程的话。可以观看一段短视频 https://vimeo.com/110804387，或者阅读这篇文章 https://rmarkdown.rstudio.com/articles_docx.html。 有时，查找元素的样式名称并不简单，可能有多种样式应用于同一个元素，并且只会在样式列表中看到其中一个突出显示。这时，可能需要通过猜测或在线搜索才能确定要修改的实际样式。例如：需要点击“管理样式”按钮 （图3.37 中样式列表底部从左到右的第三个按钮）。之后找到对应的样式并进行修改，例如，添加边框 （见图 3.39）。 图 3.39: 修改 Word 文档中的表格样式。 3.4.3 R Markdown 和 Word 之间的双向工作流程 虽然从 R Markdown 生成 Word 文档很容易，但当其他人编辑 Word 文档并且必须手动将更改移植回原始 R Markdown 时，事情会变得特别痛苦。幸运的是，Noam Ross 为这个问题提供了一个非常不错的解决方案。 redoc 包 (https://github.com/noamross/redoc) 允许生成和修改一个 Word 文档，并将修改后的 Word 文档转换回 R Markdown。 注意，截至撰写本文时（2020 年 6 月），redoc 包仍处于测试阶段，并且作者已暂停开发。如果想尝试一下，可以从 GitHub 安装这个包： remotes::install_github(&quot;noamross/redoc&quot;) 安装包后，在输出格式中加入 redoc::redoc: --- output: redoc::redoc --- 这种输出格式会生成一个 Word 文档，实际上存储的是原始 Rmd 文档，因此可以将 Word 文档转换回 Rmd。 Word 中的跟踪更改将转换为使用 CriticMarkup 语法 (http://criticmarkup.com) 编写的文本。 例如，{++ important ++} 表示在文本中插入“重要”一词。 可以通过 redoc::dedoc() 函数将 redoc::redoc 生成的 Word 文档转换为 Rmd，例如 redoc::dedoc(\"file.docx\") 会生成 file.Rmd。 在此过程中，可以通过“track_changes”参数决定如何处理 Word 中的跟踪更改，例如，可以接受或拒绝更改，或将跟踪更改转换为 CriticMarkup。 建议使用 track_changes = 'criticmarkup' 以避免跟踪更改的永久丢失。 在编辑 Word 文档时，应该编辑_不是_由 R Markdown 中的代码块或内联 R 表达式自动生成的部分。 例如，如果表是由代码块中的 knitr::kable() 自动生成的，则不能编辑它，因为当通过 dedoc() 将 Word 转换为 Rmd 时，此类更改将丢失。为避免意外编辑代码块的自动结果，可以在 redoc::redoc 格式中将选项 highlight_outputs 设置为 true，这意味着自动输出的内容将在 Word 中突出显示（带有背景颜色）。 换句话说，就是告诉的合作者，他们不应触碰 Word 文档中这些突出显示的部分。 注意： redoc 包仍处于测试阶段，目前还不清楚它的未来，所以这里的介绍较为简短。如有疑问，建议阅读 GitHub 上的文档。 3.4.4 个人风格元素 由于 Markdown 的简单性，可以将一些全局样式应用到 Word 文档中（参见 3.4.1 部分），但是对单个元素进行样式设置并不简单，例如：更改单词的颜色、段落居中。 为了在 R 中处理 Office 文档更加容易，David Gohel 于 2018 年开始开发 officedown 包 (Gohel and Ross 2022)，目的是在 R Markdown 中加入一些 officer (Gohel 2022) 特性。 在撰写本文时，该软件包原始版本已在 CRAN 上发布，但仍处于测试阶段。 可以从 CRAN 或 GitHub 安装它： # 通过 CRAN 来安装 install.packages(&quot;officedown&quot;) # 或者通过 GitHub 安装 remotes::install_github(&quot;davidgohel/officedown&quot;) 安装包后，在 R Markdown 文档中通过以下代码加载它： ```{r, setup, include=FALSE} library(&quot;officedown&quot;) ``` officedown 包中输出格式为 rdocx_document，默认情况下，是基于 rmarkdown::word_document 并具有其他一些功能，例如：样式表和绘图。该包还允许通过 officer 包设置特定 Word 元素的样式。 例如，可以通过 officer::fp_text() 函数 创建样式，并通过内联 R 表达式 ftext() 将样式应用于一段文本： --- title: 带有officedown的样式文本 output: officedown::rdocx_document: default --- ```{r} library(officedown) library(officer) ft &lt;- fp_text(color = &#39;red&#39;, bold = TRUE) ``` # 检验 **officedown** 包是 `r ftext(&#39;awesome&#39;, ft)`! 除了 officer 中的功能，officedown 还允许使用一些特殊的 HTML 注释来执行 officer 任务。 例如，函数 officer::block_pour_docx() 可用于将外部 Word 文档 导入当前文档，或者可以使用 R Markdown 中的 HTML 注释： &lt;!---BLOCK_POUR_DOCX{file: &#39;my-file.docx&#39;}---&gt; 这相当于内联 R 表达式： `r knitr::inline_expr(&quot;block_pour_docx(file = &#39;my-file.docx&#39;)&quot;)` 通过使用 officedown 和 officer 包还可以进行其他操作： 插入分页符； 将内容放在多列布局中； 更改段落设置； 插入目录； 更改页面方向（横向或纵向）。 如果想了解更多有关 officedown 的信息，可以通过以下文档 https://davidgohel.github.io/officedown/ 查阅信息。 3.5 创建新的文档格式 第 2.5 节介绍了 R Markdown 中输出格式的本质，每一个输出格式都是一个函数。html_document 或 pdf_documnet 等格式分别对应了 rmarkdown 包中的函数 rmarkdown::html_document 和 rmarkdown::pdf_document。在 YAML 元数据中指定输出格式的时候，实际上是在设置相应函数的参数。 因此，可以通过创建新的函数来创建新的文档格式。同时，为了方便新格式的使用和分发，人们还会经常开发一个对应的 R 包，随后就可以通过 output: mypackage::myformat 来使用新的文档格式。 3.5.1 从现有文档格式衍生新格式 创建新的文档格式最简单的办法就是基于现有的文档格式衍生出新的文档格式。rmarkdown内嵌的文档格式都是高度可定制的，包含众多可用参数。只需要为这些参数赋值，就可以创建出一个新的文档格式出来。 下面的例子针对季度报告创建了一个新格式 quarterly_report。这个函数是基于 rmarkdown 的内嵌函数 html_document 工作的。 quarterly_report &lt;- function(toc = TRUE) { # 查找软件包的安装位置 pkg_resource &lt;- function(...) { system.file(..., package = &quot;mypackage&quot;) } # 在软件包的子目录中找到新文档格式依赖的文档模板 css &lt;- pkg_resource(&quot;reports/styles.css&quot;) header &lt;- pkg_resource(&quot;reports/quarterly/header.html&quot;) # 调用 html_document 函数并指定其参数 rmarkdown::html_document( toc = toc, fig_width = 6.5, fig_height = 4, theme = NULL, css = css, includes = rmarkdown::includes(before_body = header) ) } 这个新的输出格式实现了下列几项功能： 提供了一个参数 toc 来决定是否显示文档目录（参数最后被传递给了 html_document）； 指定了图片默认的长度和高度（这可以避免文档中的图片出现大小参差不齐的现象）； 指定了一个新的 CSS 样式表，同时也禁用了默认的 Bootstrap 主题样式表； 在每一份文档中都添加了一个标准的头文件。 值得一提的是，第三项和第四项功能依赖于软件包提供的外部文件。也就是说，在 quarterly_report 函数中，分别获取了 \"mypackage\" 的软件包中携带的 CSS 文件和一个 HTML 文档，然后分别将 CSS 定义传递给了 html_document 函数的 css 和 includes 参数。后者使用了一个 rmarkdown::includes() 函数，从而将这个 HTML 文档（片段）作为文档 before_body 的内容嵌入到使用该格式的文档中去。 3.5.2 自定义输出格式 在基于现有格式衍生新输出格式之外，也可以从底层出发创建出一个完全的新格式。 为此需要了解文档格式的底层工作原理，简单来说 R Markdown 的输出格式由下列几个部分构成： 一系列的参数来确保 knitr 将 Rmd 文件正确的编译为 Markdown 格式的文档； 另外的一些参数来指导 Pandoc 将 Markdown 文档转换为其它输出格式（如 HTML）； 其它的一些标记或过滤器（通常用于处理输出格式的支持文件）。 可以使用 rmarkdown 软件包中的函数 output_format() 来创建一个新的输出格式。下面是一个例子： simple_html_format &lt;- function() { # 这里使用了完整的引用方式来使用 output_format、knitr_options 和 # pandoc_options 等 3 个函数。 rmarkdown::output_format( knitr = rmarkdown::knitr_options(opts_chunk = list(dev = &quot;png&quot;)), pandoc = rmarkdown::pandoc_options(to = &quot;html&quot;), clean_supporting = FALSE ) } 在这个函数中，knitr 和 Pandoc 的参数分别由两个参数指定，其内容可以相当的复杂（参见 ?rmarkdown::knitr_options 和 ?rmarkdown::pandoc_options 了解更多）。而 clean_supporting 则控制是否清理文档编译过程中使用的临时文件。 output_format() 函数中还有一个 base_format 参数用来指定一个原有的输出格式，并在此基础上进行配置（相当于衍生格式）。 如果有其它的一些支持文件无法通过 includes 参数指定，那么还需要使用 output_format()中的其它参数来帮助处理这些文件（例如，使用 intermediates_generator 来将它们拷贝到文档的输出目录中去）。 学习创建一个新的文档输出格式最好的方法可能是阅读原有格式的源代码，例如从 rmarkdown 的两个基础格式 html_document 和 pdf_document 开始，其源代码的位置在 https://github.com/rstudio/rmarkdown/tree/master/R。如果新格式需要用到 Pandoc 模板，则请参见 ?? 及 Pandoc 的使用手册。 3.5.3 使用新的文档输出格式 R 包是 R Markdown 新格式最常见的分发方式。假设 quarterly_report 函数定义在名为 mypackage 的 R 包中，则使用方法如下： --- title: &quot;文档标题&quot; output: mypackage::quarterly_report: toc: true --- 其中，toc: true 对应了 quarterly_report(toc = TRUE)。 参考文献 "],["rmarkdown-working.html", "第 4 章 基于 R Markdown 工作与学习 4.1 发邮件：blastula 4.2 制作 R 包：fusen 4.3 制作简历：datadrivencv 4.4 写书和记学习笔记：bookdown 4.5 制作网站：blogdown 4.6 制作科技论文的支撑材料", " 第 4 章 基于 R Markdown 工作与学习 4.1 发邮件：blastula 使用者有的时候可能需要批量发送定制版邮件，有些软件提供了相应选项，利用 R Markdown 也可以实现这一功能。具体而言，借助 blastula 包 (R-blastula?)，可以将 R Markdown 文档呈现在电子邮件正文并发送电子邮件。要将 R Markdown 文档呈现到电子邮件中，需要在文档中使用输出格式 blastula::blastula_email，例如： --- title: 周报 output: blastula::blastula_email --- 尊敬的客户， 以下是对 `iris` 数据的分析： ```{r} summary(iris) plot(iris[, -5]) ``` 若感兴趣请及时回复。 祝好， 张三 这个将 R Markdown 文档会通过函数 blastula::render_email() 来呈现，输出将被传递给 blastula::smtp_send()，它将发送电子邮件。需要注意的是，smtp_send() 需要一个电子邮件服务器和使用者的凭证（credentials）。 如果使用 RStudio Connect，还可以 在https://solutions.rstudio.com/examples/blastula-overview/ 上找到更多的例子，包括自动的、有条件的和参数化的电子邮件。 4.2 制作 R 包：fusen R 语言的日常使用离不开 R 包，而对于很多使用者来说，亲手制作 R 包无疑是一项有趣的工作，它不仅可以封装一些自己常用的函数，大大加速日常的工作，还可以将自己的创意通过 GitHub 或者 CRAN 发布，让更多的人了解并使用，从而给自己带来极大的成就感，甚至于获得实质性的成就25。 相信有着很多制作 R 包经验的使用者都被其繁琐的制作流程所困扰。通常情况下，制作一个 R 包需要完成如下几个内容： R 函数 函数注释 函数示例 DESCRIPTION 文件 NAMESPACE 文件 vignette 文档（可选） 很多高级开发人员厌倦了在 R 文件、测试文件、vignette 文件之间频繁切换，特别是在更改函数参数的时候，开发者需要更改示例，并在多个地方进行单元测试，很容易漏了某一个地方。而使用 fusen (R-fusen?) 制作 R 包则减少了这些困扰，使用者只需要在同一个文件中完成 R 包，与一个函数相关的所有内容都在一个地方，减少了遗漏的风险。 而对于更多未曾接触过 R 包制作的人来说，制作 R 包这个任务初听起来似乎较为复杂，会“劝退”很多人。fusen 则为那些以前从未写过 R 包但知道如何使用 R Markdown 的使用者提供了亲手创建 R 包的机会，这个包可以帮助他们迈出第一步。 使用 fusen 制作 R 包需要以下几个步骤： 通过 RStudio 选项 File &gt; New Project &gt; New directory &gt; Package using {fusen} 来创建项目； 选择模板：首次使用可以选择模板 teaching，或者直接使用函数 create_fusen(\"path/to/new/project\", template = \"teaching\")；希望更多自定义功能的用户可以选择模板 full。 编写并运行模板内的对应内容。 下面以 teaching 模板为例进行详细介绍，而 full 模板在 teaching 模板的基础上添加了诸如发布到 GitHub、包含数据文件等功能，原理上是相同的，模板内部也有详细的解释可供阅读。 在选择模板 teaching 后，会自动生成 Rmd 文件 flat_teaching.Rmd，其中第一个代码框为： 调用 testthat 包 (Hadley Wickham 2022) 可以帮助使用者更好地测试代码。 下一个代码框可以帮助使用者对创建的包进行描述并进行授权，其中包含了标题（Title）、描述（Description）以及作者信息（Authors）等内容，一个简化的内容如下： fill_description(fields = list(Title = &quot;My Awesome Package&quot;)) usethis::use_mit_license(&quot;Sébastien Rochette&quot;) 接下来需要按照模板的引导来编写函数，例如模板提供了示例函数： ```{r function-add_one} #&#39; Add one to any value #&#39; #&#39; @param value A numeric value #&#39; #&#39; @return Numeric. value + 1 #&#39; @export add_one &lt;- function(value) { result &lt;- value + 1 return(result) } ``` add_one() 函数的注释使用了 roxygen 语法，以 #' 开头的每一行代表了这个函数的一个特征，其中包括： @param：函数涉及的参数，书写的格式为 @param 参数 参数解释，每个参数对应一个 @param； @return：函数输出内容的解释； @export：输出以上内容所必须的命令。 除此之外，常用的其它参数包括： @title：函数的详细名称； @description：函数功能的解释； @details：使用函数的细节； @examples：函数的示例，但是使用 fusen 制作 R 包时可以直接在对应函数下方添加以 examples 为名称的代码框： ```{r examples-add_one} add_one(12) add_one(56) ``` 这样就会自动在其上方的函数描述中加入对应的示例。在示例后面还需要加入测试函数来确保函数可以正常运行，这里的 test_that() 函数就来自于一开始调用的 testthat 包： ```{r tests-add_one} test_that(&quot;add_one works&quot;, { expect_equal(add_one(12), 13) expect_equal(add_one(56), 57) }) ``` 需要注意的是，如果想一个包中包含多个函数，则需要对每个函数都添加 function、examples 和 tests 代码框，并将其放入不同的章节中（即在模板中新添加一个以 # 为开头的章节，如 # Add two to any value）。另外，由于相应功能的代码框会在名称部分加以区分，所以对于不同函数，需要在代码框名称后面添加标记，例如本节例子中的 function-add_one、examples-add_one 和 tests-add_one。 最后，需要运行以下代码来将 Rmd 文件转化成一个完整的包。 fusen::inflate( flat_file = &quot;dev/flat_teaching.Rmd&quot;, vignette_name = &quot;Get started&quot;, check = TRUE ) 更多关于 fusen 包的细节请参见 https://github.com/ThinkR-open/fusen/。 4.3 制作简历：datadrivencv 无论是在找工作、申请高校，还是在制作个人网站时，简历都是必不可少的，一个形式简洁、内容丰富的简历可以让读者在短时间内了解一个人。但是在制作简历时，往往会在寻找模板、调整格式上下很多功夫，尤其是在更新简历时，往往需要进行大量的调整，甚至于从头再来。 就像 R Markdown 制作的初衷是帮助使用者将注意力集中于内容上一样，datadrivencv 包 (R-datadrivencv?) 的目标也是将内容与输出分离，利用 R Markdown 的特性，可以使用相同的代码同时生成简历的交互式 HTML 以及 PDF 版本，这将大大减轻制作以及维护简历的工作量。 由于 datadrivencv 包目前没有发布到 CRAN 上，只能通过 GitHub 来下载： # install.packages(&quot;devtools&quot;) # 可能需要安装的依赖包：remotes::install_github(&#39;mitchelloharawild/icons@v0.1.0&#39;) devtools::install_github(&quot;nstrayer/datadrivencv&quot;) 使用 datadrivencv 包的第一步是使用 use_data_driven_cv() 函数： datadrivencv::use_datadriven_cv( full_name = &quot;Nick Strayer&quot;, data_location = &quot;https://docs.google.com/spreadsheets/d/14MQICF2F8-vf8CKPF1m4lyGKO6_thG-4aSwat1e2TWc&quot;, pdf_location = &quot;https://github.com/nstrayer/cv/raw/master/strayer_cv.pdf&quot;, html_location = &quot;nickstrayer.me/cv/&quot;, source_location = &quot;https://github.com/nstrayer/cv&quot; ) 其中的参数有： full_name：使用者的姓名； data_location：保存所有数据的电子表格的路径。可以是指向包含四种数据类型的多个工作表的谷歌工作表的 URL，也可以是指向包含四个包含必要数据的 .csv 文件夹的路径，例如 data_location = \"data/cv_data/\" 。这四个文件夹命名需要分别为 entries.csv、language_skills.csv、text_blocks.csv以及contact_info.csv，分别包含作者的工作经历、编程语言能力、简历不同模块的简介以及联系方式。这四个文件的模板可以从 https://github.com/cosname/rmarkdown-guide/tree/master/data/cv_data 中下载； pdf_location：发布简历 PDF 版本的网址； html_location：发布简历 HTML 版本的网址； source_location：构建简历的代码的位置，填写作者提供的 https://github.com/nstrayer/cv 即可。 函数的更多细节可以通过运行 ?datadrivencv::use_datadriven_cv 来查看。当运行这个函数时，会在当前工作目录中添加一系列文件： cv.rmd：一个 R Markdown 文件，其中包含了制作简历的各个部分。可以通过编辑这个文件来满足具体的个人需求； dd_cv.css：建立在默认 Pagedown “resume” 模板上的一组自定义 CSS 样式，可以根据需要进行编辑； render_cv.r：同时构建 PDF 和 HTML 两种格式的简历的脚本； cv_printing_functions.r：执行将电子表格数据转换为 markdown 或 HTML 并使输出用于 PDF 打印的一系列函数。 在得到上述四个文件，并且按照模板填写完毕相应的 .csv 文件夹后，用 RStudio 打开 cv.rmd 并点击 Knit 即可得到 HTML 格式的简历。如果想进一步生成 PDF 格式的简历，运行 render_cv.r 中的相应函数即可： # 编译 HTML 版本的简历 rmarkdown::render(&quot;cv.rmd&quot;, params = list(pdf_mode = FALSE), output_file = &quot;cv.html&quot;) # 编译 PDF 版本的简历到 HTML 版本中，从而可以在 HTML 版本中下载 tmp_html_cv_loc &lt;- fs::file_temp(ext = &quot;.html&quot;) rmarkdown::render(&quot;cv.rmd&quot;, params = list(pdf_mode = TRUE), output_file = tmp_html_cv_loc) # 用 Pagedown 将 HTML 转换至 PDF，生成 PDF 文件 pagedown::chrome_print(input = tmp_html_cv_loc, output = &quot;cv.pdf&quot;) 现在这个包还存在着诸多问题，例如提供的简历模板较少、对中文的支持较差等问题，有待进一步优化，但也给了使用者更自由的空间。更多细节请参考 https://github.com/nstrayer/datadrivencv。 4.4 写书和记学习笔记：bookdown 用 R Markdown 还可以实现记笔记甚至写书的功能，本书的写作过程就是通过 R Markdown 进行，其中关键在于 bookdown 包 (Xie 2022a)。这个包被设计为创建由多个 R Markdown 文档组成的长篇文档。例如，如果想写一本书，可以在自己的 R Markdown 文件中编写每个章节，并使用 bookdown 将这些 R Markdown 文件编译成一本书。 对于 RStudio 的用户来说，最简单的开始方法是通过 File -&gt; New Project -&gt; New Directory -&gt; Book Project using bookdown，用 IDE 创建一个 bookdown 项目，正如图 4.1 所示。 如果不使用 RStudio 或者喜欢在控制台工作，也可以通过调用函数 bookdown:::bookdown_skeleton('your-book-dir') 产生相同的结果。 图 4.1: 在 RStudio 中创建一个 bookdown 项目。 为了演示用法，下面提供了一个最小的示例，包含同一个目录中的三个文件： directory |- index.Rmd |- 01-intro.Rmd |- 02-analysis.Rmd 下面将显示每个文件的内容并解释它们的作用： index.Rmd: --- title: &quot;一个最小的 bookdown 项目&quot; site: bookdown::bookdown_site output: bookdown::gitbook --- # 前言 {-} 内容 第一个文件通常被称为 index.Rmd。它应该是提供 YAML 前端内容的唯一 R Markdown 文件，它还应该包含一个特殊的 YAML 字段 site: bookdown::bookdown_site，以便 rmarkdown 知道使用 bookdown 来构建所有 R Markdown 文件，而不是呈现单个 R Markdown 文件。可以使用任何 bookdown输出格式，例如 bookdown::gitbook、 bookdown::pdf_book、 bookdown::word_document2 以及 bookdown::epub_book。 接下来的两个 R Markdown 文件是两个章节： 01-intro.Rmd: # 第 1 章 这是第 1 章。 02-analysis.Rmd: # 第 2 章 这是第 2 章。 要呈现这些 R Markdown 文件，应该调用 bookdown::render_book('index.Rmd') 而不是 rmarkdown::render()。在底端，bookdown 在默认情况下会将所有 R Markdown 文件合并为单个 R Markdown 并编译它。文件按字母顺序合并。这就是为什么在上面的例子中为文件名添加数字前缀的原因。 事实上，可以通过很多设置来自定义一个 bookdown 项目。关于 bookdown 的更全面的概述，可以查看 R Markdown Definitive Guide 的第十八章 “Creating New Formats” (Xie, Allaire, and Grolemund 2018a)。完整文档请参见书籍 bookdown (Xie 2016)。 需要注意的是，本节提供例子内容为英文，若需要编译含中文的文档，则需要加入特殊的命令，如 documentclass: ctexbook，一个简单的中文书例子请参见： https://github.com/yihui/bookdown-chinese。 4.5 制作网站：blogdown 4.5.1 blogdown 简介 在当今的互联网时代世界，无论从事什么职业，个人网站几乎成为了一张人手必备的的“电子名片”。谢益辉开发的 blogdown 包提供了一种功能全面，且设置简单快速的个人网站架设途径。 基于 R Markdown 的 blogdown 包为个人用户提供一种轻便快速的建立个人静态网站的方案。不同于市面上多数的网站建立方案，静态网站有着众多好处，如文件体型小，铺设速度快，所以更换服务器时更加省时省力。与此同时，blogdown 依赖 R Markdown 文件为基础来生成网站。而 R Markdown 文件本身支持众多强大功能，包括文本的书写，编辑与排版（包括对 \\(LaTeX\\) 的支持），数据分析，交互性插件（如交互性图表）等。 本书的这个小节将通过一个对新手十分友好的案例来手把手的展示如何快速建立一个可满足日常基本需求的网站，以便用户可快速上手 R 的 blogdown 包。 4.5.2 具体操作 4.5.2.1 安装 blogdown 在开始之前，用户需要确认个人主机已经安装最新版本的 R 和 RStudio。 首先，通过以下一行命令从 CRAN 安装 blogdown 包： # 安装 blogdown install.packages(&quot;blogdown&quot;) 4.5.2.2 创建项目 一个网站可被视为一个 R 项目。想要创建一个新的网站项目，只需要按照下图提示，在 RStudio 菜单栏依次选择文件，新项目，新目录 （File -&gt; New Project -&gt; New Directory）。完成后，选择用 blogdown 建设网站 （Website using blogdown），即可看到一个网站项目的具体设置界面。 图 4.2: 在 RStudio 中创建一个新网页项目 图 4.3: 基于 blogdown 创建一个新网页项目 设置好目录名，只需点击创建项目（Create Project），RStudio 即会通过 blogdown 包来自动生成一个网站项目。 4.5.2.3 网站铺设 用户可以便捷的通过 RStudio 的基础功能在本地浏览自己的网页项目。用户既可以直接在控制台 （Console） 键入 blogdown::serve_site()，或在 RStudio 上方的插件 （Addins） 选项选择铺设网站 （Serve Site）。 图 4.4: 通过控制台在本地浏览你的网站 图 4.5: 通过插件的铺设选项在本地浏览你的网站 然后 RStudio 应会显示与下图相似的页面。 图 4.6: 在本地铺设网站 显示本地铺设成功后，用户既可以通过图形交互页面，点击在本地浏览器打开（在 RStudio 右上角的 Show in new window）来通过本地浏览器在本地浏览刚刚编辑好的网页。只要网页项目在本地浏览器中被打开后，之后任何在源文件上的改动都会自动在浏览器中进行实时加载，所以并不需要在每次改动后重复点击铺设 (knit) 网站。 4.5.2.4 内容编辑 位于 RStudio 的右下角，用户可以通过进入内容 content 文件夹来查看并编辑当下网站项目的所有内容页。作为一个初始例子，这里首先打开 2020 年 12 月 01 日的一个文件 content/post/2020-12-01-r-rmarkdown/index.Rmd。 可以注意到，打开的 Rmarkdown/Rmd 文件的最上方是含有标题 title，作者 author 等字眼的代码部分，而这个部分被称为 YAML 代码区 （用于设定网页形态）。 当编辑具体网页内容时，用户只需要在 YAML 代码区下方的空白部分进行编写即可。 接下来，这里展示如何在网页中添加代码。如下图所示，只需添加一个 R 代码块，然后输入以下内容，代码就会自动展示在网页上。 library(ggplot2) summary(Orange) ## Tree age circumference ## 3:7 Min. : 118.0 Min. : 30.0 ## 1:7 1st Qu.: 484.0 1st Qu.: 65.5 ## 5:7 Median :1004.0 Median :115.0 ## 2:7 Mean : 922.1 Mean :115.9 ## 4:7 3rd Qu.:1372.0 3rd Qu.:161.5 ## Max. :1582.0 Max. :214.0 ggplot(Orange, aes(x = age, y = circumference, color = Tree)) + geom_point() + geom_line() + guides(color = &quot;none&quot;) + theme_bw() 此时，如果编辑中的网站项目已经在本地浏览器中打开，用户只需要点击左上角的保存，几秒后即可在浏览器内看到如下图的内容。如果此时用户并没有在本地浏览网页，点击编译 knit，网站便会在本地的 RStudio 自动生成。 图 4.7: 给 Rmd 文件添加 R 代码 4.5.2.5 网站配置 除了通过编辑 Rmd 文件来实现网站内容的编辑外，用户还可以通过修改 config.yaml 文件内的设定来自定义自己的网站。 例如，打开 config.yaml 文件后，用户可能会看到如下内容： baseurl: / title: A Hugo website theme: hugo-lithium ignoreFiles: - \\.Rmd$ - \\.Rmarkdown$ - _cache$ - \\.knit\\.md$ - \\.utf8\\.md$ permalinks: post: /:year/:month/:day/:slug/ menu: main: - name: About url: /about/ - name: GitHub url: https://github.com/rstudio/blogdown - name: Twitter url: https://twitter.com/rstudio 只需在相应的部分进行编辑，用户就可以根据个人的需求自定义自己的网站，如： title: 我的网站 ：将网站标题修改为“我的网站” name: Weibo url: 你的微博url ：在菜单中添加个人 Weibo 信息页面的链接 4.5.2.6 小结 目前为止，此节已经展示了如何创建并编辑一个个人化 blogdown 网站的三条基本知识： 通过 RStudio 的铺设 Serve Site 功能 或在控制台内键入 blogdown::serve_site() 来在本地浏览自己的网站。 通过编辑 config.yaml 文件来自定义自己的网站（标题，菜单栏，主题等）。 通过编辑处于目录夹中 content 文件夹内的 Rmd 文件来编辑具体的网页信息。通过进阶的学习，用户还可以通过修改自定义 Rmd 文件的位置来改变他们在网站上显示的结构。 4.5.2.7 部署 那么下一步是什么？选择自然有很多，但最重要的莫过于通过部署编辑完成的网站，以便让他人可以通过互联网直接浏览网站上的内容。 就像之前简短提到过的，因为静态网站本质上就是一个文件夹，所以静态网站与大多数动态网站相比较的一个重要优点就是部署更加简单且快速。那么如何选择用于部署的服务器呢？权衡过上手友好度以及性价比后，Netlify (https://www.netlify.com/) 是一个很不错的选择。 4.5.2.8 Netlify Netlify 提供的免费服务功能多元，足够满足大多数用户的需求，且部署也十分简单。就算用户之前没有部署网站的经验，也只需创建一个 GitHub 账户，并使用此账户注册并登陆属于用户个人的 Netlify 账户。登陆成功后，只需将网站项目目录中由 blogdown 生成的名为公共 Public/ 的文件夹拖入 Netlify 部署页面即可。 图 4.8: 在网站项目文件夹中找到名为Public的文件夹 图 4.9: 将此文件夹拖拽入部署页面的部署区域即可完成部署 一般只需几秒钟，网站就会被成功部署在 Netlify 的服务器上，并可以通过一个格式为 random-word-12345.netlify.com 的域名访问。此域名是 Netlify 自动生成的一个子域名，并支持通过设置修改至自己偏好的字眼。Netlify 提供的一体化部署服务省去了用户在其他服务器上实现自定义设置时往往需要面对的许多麻烦。 不过需要注意的是，每次在本地的 RStudio 编辑完个人网站后，用户需要在控制台输入以下代码来更新你的公共文件夹 Public/。只有在更新完成后，才可以通过在 Netlify 上次最新版本的 Public/ 文件夹来部署你改动过后的网站。 blogdown::build_site() 4.6 制作科技论文的支撑材料 数据驱动是当前科学研究的重要发展趋势。中国科学院生化所吴家睿教授认为，数据驱动的研究范式不仅能够避免研究者可能的主观偏见，而且可以帮助其发现在假设或者现有理论范围之外的全新知识。这种方式不需要假设，主要目的是去获取研究对象的相关信息，克服了假设驱动的研究范式对决定论和因果关系的偏执，进而形成了开放式研究的认识论新体系。 在这样的背景下，越来越多的期刊都鼓励或者要求作者开放研究中使用的原始数据和分析过程，给了 R Markdown 一个新的用武之处。 4.6.1 建议文件结构 论文的支撑材料通常存放在 GitHub 这一类的开源网站上，其文件结构通常是： |--+ data：子文件夹，用于存放分析使用的数据； |--+ figures：子文件夹，用于存放生成的图片； |--+ functions：子文件夹，用于存放一些需要重复调用的函数； |- supplementary.Rproj：R 项目文件； |- README.md：使用 Markdown 语法的 README 文件，用于说明项目相关信息； |- analysis.Rmd：使用 R Markdown 语法的分析文件（可以有多个）。 analysis.Rmd 是支撑材料中的核心文件。它是一个常规的 R Markdown 文档。举例来说，下面的头文件中分别指定了 3 种不同的输出样式。 --- title: Your Title author: &quot;your@email.com&quot; date: &quot;2022-5-15&quot; output: html_document: toc: yes toc_depth: 3 toc_float: collapsed: no smooth_scroll: no md_document: variant: markdown_github pdf_document: toc: yes toc_depth: &#39;3&#39; --- 为了让生成的图片能够妥善的存放到 figures 文件夹，需要在头文件后面添加一些设置。 ```r knitr::opts_chunk$set( fig.width = 8, fig.asp=0.618, dpi = 300, warning = FALSE, fig.path = &quot;figures/Figure-&quot; ) ``` 这里将图片的默认宽度和比例分别设置为 8 英寸和 0.618（黄金分割比例），并设置图片分辨率为 300 dpi；与此同时，不显示 R 运行过程中的警告信息；此外，还将图片输出的路径指定到 figures 文件夹中。 4.6.2 分析报告的正文 报告的正文仁者见仁智者见智，不过通常会包含以下几个部分（因为研究论文更多的发表在英文期刊上，所以这里的报告示例使用了英文标题）。 ## Required Packages ## Data Processing ## Main Results ## Supporting Results 这基本上是按照数据分析的逻辑组织的，所以就不再赘述了。 如果文档中不涉及动态网页内容，推荐把 R Markdown 文档输出为 Markdown ，因为这样读者可以直接在 GitHub 网站查看相应的结果。 具体做法： 在头文件中加入 output: github_document； 使用下面的命令将 Rmd 文件编译为 Markdown 文件。注意这里指定了 GitHub Flavored Markdown（gfm）作为输出格式。 library(rmarkdown) render(&quot;analysis.Rmd&quot;,md_document(variant = &quot;gfm&quot;)) 参考文献 "],["rmarkdown-interaction.html", "第 5 章 使用 R Markdown 创建动态交互文档 5.1 Web 交互界面：Shiny 小程序 5.2 交互式仪表盘：Dashboards 5.3 在 R package 中使用 R Markdown", " 第 5 章 使用 R Markdown 创建动态交互文档 5.1 Web 交互界面：Shiny 小程序 Shiny 小程序是由 R 驱动的交互式 Web 应用程序。基于 Shiny 的 Web 应用程序（Shiny App）用途十分广泛，功能也很强大，实现的方式也多种多样。本书主要介绍与 R Markdown 文档应用相关的一部分知识，欲了解更多请参见 Shiny 官网。 Shiny 包是由 R 驱动的交互式 Web 应用程序。如果读者想从 R Markdown 文档中调用 Shiny 代码，只需在 YAML 元数据中添加 runtime: shiny 即可。由于 Shiny 构建 Web 应用程序功能十分强大，本书只介绍部分的 Shiny 知识。在阅读本章之前，如果不了解该包，可以先通过以下网站 https://shiny.rstudio.com 进行大致了解。 5.1.1 入门指南 在 YAML 元数据中加入 runtime: shiny，可以将任何基于 html 的 R Markdown 文档变成 Shiny 文档，例如： --- title: &quot;Shiny Document&quot; output: html_document runtime: shiny --- 注意，R Markdown 文档的输出格式必须是 HTML 格式。也就是说，文档最后生成的是一个 Web 页面（*.html 文件）。 注意： 非 html 格式，如 pdf_document 和 word_document 将不能与 Shiny 同时运行。另外，一些演示格式也是 HTML 格式，比如ioslides_presentation 和 slidy_presentation，它们是可以与 Shiny 相结合的。 当然，也可以通过 RStudio 构建一个新的 Shiny 文档。步骤如下：File -&gt; new File -&gt; R Markdown 并选择 Shiny，具体见图 5.1。 图 5.1: 在 RStudio 中创建一个新的 Shiny 文档。 如果读者想在 RStudio 中运行 Shiny 文档，需要单击工具栏上的 “Run Document” 按钮（当 RStudio 检测到这是 Shiny 文档时，它会自动将 Knit 按钮替换为 Run Document）。如果读者没有使用 RStudio，或者想在 R 控制台运行文档进行故障排除，可以调用函数 rmarkdown::run() 并将文件名传递给它。 可以在文档中嵌入 Shiny 的输入和输出。如果输入发生变化时，输出将自动更新。例如，创建一个名称为 rows 的数字输入（ numericInput ），然后在输出中通过 input$rows 引用其值： numericInput(&quot;rows&quot;, &quot;How many cars?&quot;, 5) renderTable({ head(cars, input$rows) }) 图 5.2: 增加 Shiny 文档中表中的行数 在上面的示例中，输出代码包含在 renderTable() 中。 Shiny 中还有许多其他渲染功能，可用于图片、结果输出等。 下面使用 renderPlot() 输出可交互柱状图： ```{r, echo=FALSE, eval = FALSE} sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, 30, min = 1, max = 50) renderPlot({ x = faithful[, 2] # Old Faithful Geyser data bins = seq(min(x), max(x), length.out = input$bins + 1) # 用指定的格子大小绘制可交互的直方图 hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) ``` 图 5.3: Shiny 文档输出可交互的直方图 5.1.2 Shiny 部署 如果在本地运行一个 Shiny 文档时，默认情况下它会使用本地 R 会话，并且只有运行的人能与该文档进行交互。如果希望与没有安装 R 的用户共享文档，或者不希望在本地运行文档，则必须将文档部署到服务器上，并共享文档的 URL。那么其他人只需要一个 web 浏览器就可以访问文档。 有两种方法可以部署 Shiny 文档。1. 使用 RStudio 提供的托管服务；2. 搭载到自己的服务器上。 5.1.2.1 ShinyApps.io 读者可以把 Shiny 文档发布到 ShinyApps (https://shinyapps.io) 进行托管。 需要满足以下两个条件： 在 ShinyApps 上注册账号。 安装了最新版本的 rsconnect 包。安装方式如下： install.packages(&quot;rsconnect&quot;) 然后，对需要部署的 Shiny 文档所对应的工作目录中执行以下语句： rsconnect::deployApp() RStudio 用户也可以在运行 Shiny 应用后，点击窗口右上角的 Publish 按钮(图 5.4)。 图 5.4: 部署 Shiny 文档到 ShinyApps.io. 上 如果目录中有一个名为 index.Rmd 的文件，它将用作该目录的默认文档。如果想访问 Rmd 文档，则应在 URL 中指定 Rmd 文件的显式路径。 例如，部署到 ShinyApps 的 index.Rmd 的 URL 可以采用以下形式 https://example.shinyapps.io/appName/，而 test.Rmd 的 URL 可以采用以下形式 https://example.shinyapps.io/appName/test.Rmd。 5.1.2.2 Shiny Server / RStudio Connect 除此之外，Shiny Server （https://www.rstudio.com/products/shiny/shiny-server/） 和 RStudio Connect（https://www.rstudio.com/products/connect/） 都可以发布 Shiny 文档，但是读者需要熟悉有关 Linux 的知识。由于该内容较为复杂与丰富，超出本书读者的需求，所以在此不做过多介绍。 5.1.3 嵌入 Shiny 应用程序 除了在 R Markdown 中嵌入单个 Shiny 的输入和输出外，还可以在文档中嵌入一个独立的 Shiny 应用程序。有两种方法可以做到这一点： 使用 shinyApp() 函数内部定义应用程序; 使用 shinyAppDir() 函数引用外部应用程序。 注意：这两个函数在 shiny 包中，当在 YAML 元数据指定 runtime: shiny 时，它们会被自动加载。因此，读者不必调用 library(shiny) 来加载 shiny。 5.1.3.1 内部定义应用程序 下面例子将 Shiny 应用程序写在了 Rmarkdown 内部中： shinyApp( ui = fluidPage( selectInput(&quot;region&quot;, &quot;Region:&quot;, choices = colnames(WorldPhones)), plotOutput(&quot;phonePlot&quot;) ), server = function(input, output) { output$phonePlot = renderPlot({ barplot(WorldPhones[,input$region]*1000, ylab = &quot;Number of Telephones&quot;, xlab = &quot;Year&quot;) }) }, options = list(height = 500) ) 注意：使用 height 参数来确定嵌入式应用程序应该占用多少高度。 5.1.3.2 外联应用程序 下面例子展示嵌入了一个定义在另一个目录中的 Shiny 应用程序。 shinyAppDir( system.file(&quot;examples/06_tabsets&quot;, package=&quot;shiny&quot;), options = list(width = &quot;100%&quot;, height = 700) ) 5.1.4 Shiny 小部件 Shiny 小部件让使用者能够使用一个函数调用创建包含在 R Markdown 文档中的可重复使用的 Shiny 组件。还可以直接从控制台调用 Shiny 小部件(在创作过程中很有用)，并在 RStudio Viewer 窗格或外部 Web 浏览器中显示它们的输出。 5.1.4.1 shinyApp() 函数 Shiny 窗口小部件的核心是使用 shinyApp() 函数创建的微型应用程序。使用者无需像传统的 Shiny 应用程序那样，既要创建用户界面（UI），又要创建服务器端（Server）。而是将 UI 和 Server 定义作为参数传递给 shinyApp() 函数。 本书会在第 5.1.3.1 节中给出了一个示例。 接下来，先给出最简单的 Shiny 小部件类型———返回 shinyApp() 的 R 函数。 5.1.4.2 例子：k-means 聚类 rmdexamples 包 (https://github.com/rstudio/rmdexamples) 包含以上形式实现的 Shiny 小部件示例。 kmeans_cluster() 函数接受单个数据集（dataset）参数，并返回一个小部件来显示 k-Means 聚类的结果。读者可以在 R Markdown 文档中使用它： library(rmdexamples) kmeans_cluster(iris) 图 5.5 展示了在运行文档时小部件的样子。 图 5.5: 在数据集上应用 k-Means 聚类的 Shiny 小部件。 下面是 kmeans_cluster() 函数的源代码： kmeans_cluster = function(dataset) { library(shiny) vars = names(dataset) shinyApp( ui = fluidPage( fluidRow(style = &quot;padding-bottom: 20px;&quot;, column(4, selectInput(&#39;xcol&#39;, &#39;X Variable&#39;, vars)), column(4, selectInput(&#39;ycol&#39;, &#39;Y Variable&#39;, vars, selected = vars[2])), column(4, numericInput(&#39;clusters&#39;, &#39;Cluster count&#39;, 3, min = 1, max = 9)) ), fluidRow( plotOutput(&#39;kmeans&#39;, height = &quot;400px&quot;) ) ), server = function(input, output, session) { # 将选定的变量组合到一个新的数据框中 selectedData = reactive({ dataset[, c(input$xcol, input$ycol)] }) clusters = reactive({ kmeans(selectedData(), input$clusters) }) output$kmeans = renderPlot(height = 400, { res = clusters() par(mar = c(5.1, 4.1, 0, 1)) plot(selectedData(), col = res$cluster, pch = 20, cex = 3) points(res$centers, pch = 4, cex = 4, lwd = 4) }) }, options = list(height = 500) ) } 5.1.4.3 小部件的大小和布局 Shiny 小部件可以嵌入在不同的地方，包括标准的全宽页面、页面内的小列，甚至在 HTML5 幻灯片中。为了让小部件的大小和布局在上文所述的文档中稳定工作，作者建议小部件的总高度不高于 500 像素。当然，还可以在创建小部件的函数中添加一个显式的 height 参数（默认值为 500）。 5.1.5 Shiny 文档间的链接 可以使用 Markdown 链接语法并指定文档的相对路径，链接到其他 Shiny 文档上，例如： [另一个Shiny文档](another.Rmd)。如果在一个页面上单击指向另一个 Rmd 文档的链接，该 Rmd 文档将作为当前交互式 Shiny 文档启动。 默认情况下，只能链接到调用 rmarkdown::run() 的文件所在目录中的 R Markdown 文件（例如，无法连接到 ../foo.Rmd）。 但是，可以使用 rmarkdown::run() 的 dir 参数来定义根目录。 5.1.6 Shiny 文档的渲染 5.1.6.1 延迟渲染 Shiny 文档通常在每次 R Markdown 文档渲染时都会显示。这时，较大或计算量较大的文档可能需要一些时间来加载。 如果文档包含不需要立即渲染的交互式 Shiny 组件，可以在 rmarkdown::render_delayed() 函数中封装 Shiny 代码。这个函数保存它的参数，直到文档呈现完成并显示给用户，然后计算它，并在计算完成时将其注入输出文档。 例如，以下代码中，首先渲染出数值输入的结果，加载完文档并显示给用户之后， render_delayed() 才会执行内部代码，并将其加载到文档中。 numericInput(&quot;rows&quot;, &quot;How many cars?&quot;, 5) rmarkdown::render_delayed({ renderTable({ head(cars, input$rows) }) }) 5.2 交互式仪表盘：Dashboards 本节将介绍通过 flexdashboard 包 (Iannone, Allaire, and Borges 2020) 设计一个仪表盘的方法。 仪表盘在业务风格的报告中特别常见。它们可以用来展示报告的概要和关键内容。仪表盘的布局通常是基于网格搭建的，各个组件排列在各种大小的“盒子”中。 使用 flexdashboard 包，读者可以 通过 R Markdown，展示一组数据的可视化图表。 嵌入各种各样的组件，包括 HTML 小部件、R 图形、表格数据和文本注释等内容。 可以指定按行或列进行布局(各组件会自动调整大小以填满浏览器，并且在移动设备上也十分适配)。 可以创建区域来呈现可视化图形和相关注释。 使用 Shiny 驱动动态可视化图表。 5.2.1 Dashboards 入门 首先，安装 flexdashboard 包： install.packages(&quot;flexdashboard&quot;) 其次，通过点击 File -&gt; New File -&gt; R Markdown 对话框在 RStudio 中创建文档，并选择 “Flex Dashboard” 模板。操作界面如图 5.6 所示： 图 5.6: 创建新的 dashboard 文件。 注：如果没有使用 RStudio 进行操作，那么也可以从 R 控制台创建一个新的 flexdashboard 的 R Markdown 文件，具体操作如下： rmarkdown::draft( &quot;dashboard.Rmd&quot;, template = &quot;flex_dashboard&quot;, package = &quot;flexdashboard&quot; ) 本章只介绍一些基本特性和用法。如果读者想更进一步了解 flexdashboard，可以查看它的完整文档： https://rmarkdown.rstudio.com/flexdashboard/ 。 仪表盘有许多与 HTML 文档相同的特性，比如图形选项，外观和风格，MathJax 公式，头部和正文前后内容和 Pandoc 参数，等等。除此之外，也建议浏览 R 帮助页面 ?flexdashboard::flex_dashboard 来了解更多 flexdashboard 选项和其特性。 当然 RStudio 官网也给出了该包 介绍 与案例，读者可以基于案例到学习实现快速入门。 5.2.2 Dashboards 排版 关于仪表盘布局的总体规则是： 一级标题：生成页面； 二级标题：生成列（或行）； 三级标题：生成框（包含一个或多个仪表盘组件）。 下面给出一个简单的例子： --- title: &quot;入门例子&quot; output: flexdashboard::flex_dashboard --- ```{r setup, include=FALSE} library(flexdashboard) ``` 第一列 -------------------------------------------------- ### 图表 A ```{r} ``` 第二列 -------------------------------------------------- ### 图表 B ```{r} ``` ### 图表 C ```{r} ``` 注意，第一行文本（第一列）下的一系列破折号是二级标题的另一种 Markdown 语法形式，即： 第一列 -------------------------------------------------- 等同于 ## 第一列 这里使用一系列减号，只是为了让二级标题在源文档中更为显眼罢了。读者可以根据自身喜好，选择任意一种语法形式。 默认情况下，二级标题在仪表板上生成列，三级标题在列中自上而下排列。所以在默认情况下，不必在仪表盘上设置列，因为它默认一列一列自上而下排列显示。 注意：二级标题的内容将不会显示在输出中。二级标题仅用于布局（例如，例子中的“第一列” 不会显示在输出中），因此二级标题的实际内容一点都不重要。相比之下，一级标题和三级标题更加重要。 图 5.7 显示了上述示例的结果，一共是两列，第一列为 “图表 A”，第二列为 “图表 B” 和 “图表 C”。 注：本例中，作者并没有在代码块中加入任何 R 代码，因此框内都是空的。在实际使用中，读者可以编写任意的 R 代码来生成 R 图、HTML 小部件或其他组件，并将其加入到框中。 图 5.7: 简单仪表盘布局示例。 5.2.2.1 基于行的布局 通过修改 orientation 选项将默认布局（列导向）改为以行导向的布局，例如： output: flexdashboard::flex_dashboard: orientation: rows 此时，二级结构将会按照行进行排列，三级结构会按照行中的列进行排放。将上述例子修改后，输出结果如图 5.8 所示： 图 5.8: 基于行布局的结果。 5.2.2.2 节属性 二级结构头部还可以加入一些属性，例如：设置列宽度为 350。 窄栏 {data-width=350} -------------------------------- 在基于行布局的情况下，可以为行设置 data-height 属性。而基于列布局的情况下，可以使用 {.tabset} 使得三级结构以制表符的形式排列，例如： 两个选项卡 {.tabset} ------------------ ### 选项卡 A ### 选项卡 B 结果如图 5.9 所示： 图 5.9: 以制表符的形式排列。 5.2.2.3 多页 如果 R Markdown 文档中有多个一级结构的内容时，这时仪表盘会将每个一节结构分别显示为单独页面。下面给出一个简单的例子： --- title: &quot;多页显示&quot; output: flexdashboard::flex_dashboard --- 图形 {data-icon=&quot;fa-signal&quot;} ===================================== ### 图 A ```{r} ``` ### 图 B ```{r} ``` 表格 {data-icon=&quot;fa-table&quot;} ===================================== ### 表 A ```{r} ``` ### 表 B ```{r} ``` 图 5.10: 仪表盘上的多个页面情况。 注：多个等号是一级标题的另一种 Markdown 语法（也可以使用单个井号 # 表示）。 从图 5.10 可以看到： 页面标题显示在仪表盘顶部的导航菜单中。一级结构单独构成一个页面。 本例中，还做了一个小拓展，通过 data-icon 属性将图标应用于页面标题中。当然也可以从该网址 https://fontawesome.com 找到其他可用图标。例如，图 5.11 给出部分可用图标。 图 5.11: 网站中部分可用图标。 5.2.2.4 故事板 除了基于列或行布局外，还可以通过故事板（storyboard）进行布局，呈现一些可视化图形或其他说明。下面给出一个简单的例子： --- title: &quot;故事板&quot; output: flexdashboard::flex_dashboard: storyboard: true --- ### 散点图 ```{r} plot(cars, pch = 20) grid() ``` --- 可以添加一些评论。 ### 直方图 ```{r} hist(faithful$eruptions, col = &#39;gray&#39;, border = &#39;white&#39;, main = &#39;&#39;) ``` --- 可以添加一些评论。 图 5.12: 基于故事板布局的结果。 如图 5.12 所示，读者可以通过顶部的左右导航按钮来浏览所有故事板内容。 5.2.3 Dashboards 组件 仪表盘布局中可以包含各种各样的组件，包括： 基于 HTML 小部件的交互式 JavaScript 数据可视化图形。 R 图形，包括基础、栅栏和网格图形； 表格（可选选项包括：排序，过滤和分页等）； 数值框（展示重要数据）； 仪表盘； 文本注释； 导航栏（提供与仪表盘相关的更多链接）。 注：无论输出格式如何，前三个组件在大多数 R Markdown 文档中均可使用。 而后四个组件是仪表盘特有的，本节主要介绍后四个组件。 5.2.3.1 数值框 如果希望在仪表盘中包含一个或多个数值，那么读者可以使用 flexdashboard 包中的 valueBox() 函数来实现这个需求。下面给出一个简单的例子： --- title: &quot;数值框&quot; output: flexdashboard::flex_dashboard: orientation: rows --- ```{r setup, include=FALSE} library(flexdashboard) # 这些计算函数只是简单的例子 computeArticles = function(...) return(45) computeComments = function(...) return(126) computeSpam = function(...) return(15) ``` ### 每日文章数 ```{r} articles = computeArticles() valueBox(articles, icon = &quot;fa-pencil&quot;) ``` ### 每日评论数 ```{r} comments = computeComments() valueBox(comments, icon = &quot;fa-comments&quot;) ``` ### 每日垃圾邮件数 ```{r} spam = computeSpam() valueBox( spam, icon = &quot;fa-trash&quot;, color = ifelse(spam &gt; 10, &quot;warning&quot;, &quot;primary&quot;) ) ``` 图 5.13: 仪表盘上并排的三个值。 图 5.13 展示了三个并排的仪表，每个仪表都显示了一个数值和标题。这里重点解释下第三个代码块（### 每日垃圾邮件数）。这里的 valueBox() 函数定义了一个值( spam )和一个图标( icon = \"fa-trash\" )。并使用 color 设置参数框的颜色。内部使用了一个 ifelse() 语句，使得不同值表示不同的颜色。当然，可用的颜色还包括： \"info\", \"success\" 和 \"danger\"（默认值为： \"primary\"）。也可以指定任何有效的 CSS 颜色（例如：\"#ffffff\"， \"rgb(100, 100, 100)\" 等）。 5.2.3.2 仪表 在指定数值范围内显示仪表上的数值。例如，下面展示了三个仪表并排的结果（见图 5.14）。 --- title: &quot;仪表&quot; output: flexdashboard::flex_dashboard: orientation: rows --- ```{r setup, include=FALSE} library(flexdashboard) ``` ### 接触率 ```{r} gauge(91, min = 0, max = 100, symbol = &#39;%&#39;, gaugeSectors( success = c(80, 100), warning = c(40, 79), danger = c(0, 39) )) ``` ### 平均额定值 ```{r} gauge(37.4, min = 0, max = 50, gaugeSectors( success = c(41, 50), warning = c(21, 40), danger = c(0, 20) )) ``` ### 取消数 ```{r} gauge(7, min = 0, max = 10, gaugeSectors( success = c(0, 2), warning = c(3, 6), danger = c(7, 10) )) ``` 图 5.14: 三个仪表并排放在仪表盘上。 这个示例需要解释以下几点： 通过 gauge() 函数设置一个仪表盘。其内部三个参数需要确定：value， min 和 max （可以是任何数值）。 可以指定一个可选的符号（symbol）和值一起显示（本例中， “%” 用来表示百分比）。 可以使用 gaugeSectors() 函数指定一组自定义的颜色扇区，默认颜色为绿色。扇区选项（sectors）可以指定三个值的范围（success, warning 和 danger） 使得仪表盘的颜色根据它的值变化而变化。 5.2.3.3 文本注释 可以通过以下方式在仪表盘中包含额外的叙述说明： 在页面顶部加入相应文本内容。 定义不包含图表，而是仅包含任意内容（文本、图像和方程等）的指示板。 如图 5.15 所示，顶部包含了一些内容说明和右下角包含了一个只有内容的指示板： --- title: &quot;文本注释&quot; output: flexdashboard::flex_dashboard: orientation: rows --- 英国 1974-1979 年每月死于支气管炎、肺气肿和哮喘的人数 （来源于：P. J. Diggle, 1990, Time Series: A Biostatistical Introduction. Oxford, table A.3） ```{r setup, include=FALSE} library(dygraphs) ``` 行 {data-height=600} ------------------------------------- ### 总肺癌死亡数 ```{r} dygraph(ldeaths) ``` 行 {data-height=400} ------------------------------------- ### 男性死亡人数 ```{r} dygraph(mdeaths) ``` &gt; 1974-1979 年英国每月死于肺病的人数。 ### 备注 本例使用了 dygraphs 包。该包为绘制时间序列数据提供了丰富的工具。 图 5.15: 仪表盘上的文本注释。 注意：仪表盘中的每个组件都可以包括标题和注释部分。三级结构 (###) 后面的文本为标题；&gt; 开头的文本是注释。 5.2.3.4 导航栏 默认情况下，仪表盘的导航栏包括：标题（title）、作者（author）和日期（date）。当仪表盘有多个页面时（第 5.2.2.3 节），导航条左侧还包含指向各个页面的链接。当然，也在可以仪表盘上添加社交链接。 除此之外，使用 navbar 选项可以在导航栏中添加自定义链接。例如，在导航栏中添加 “关于” 链接： --- title: &quot;导航栏&quot; output: flexdashboard::flex_dashboard: navbar: - { title: &quot;关于&quot;, href: &quot;https://example.com/about&quot; } --- 这时得到的界面如图 5.16 所示： 图 5.16: 导航栏中添加自定义链接。 注意：导航栏必须包括标题或图标（或两者都包含）。还可以使用 href 作为导航目标。如果想调整文本对齐方式，可以使用 align 参数 （默认情况下为右对齐）。 5.2.4 Dashboards 与 Shiny 在仪表盘中添加 Shiny，可以通过交互界面手动更改参数，并显示实时结果。或者当仪表盘的数据发生变化时，让仪表盘进行实时更新（请参阅 shiny 包中的 reactiveFileReader() 和 reactivePoll() 函数）。这是通过将 runtime: shiny 添加到标准仪表盘文档来实现的，然后添加一个或多个输入控件或响应表达式来动态驱动仪表板内组件的外观。 在 flexdashboard 中使用 Shiny 可以将一个静态的 R Markdown 报告变成一个交互式文档。需要注意的是，交互式文档需要部署到 Shiny 的服务器上，以便广泛共享（而静态 R Markdown 文档是可以附加到电子邮件或从任何标准 Web 服务器提供的独立 Web 页面）。 注意，shinydashboard 包提供了用 Shiny 创建仪表板的另一种方法。 5.2.4.1 入门指南 在仪表盘中添加 Shiny 组件的步骤如下： 在文档顶部 YAML 元数据中添加 runtime: shiny。 在仪表盘第一列添加 {.sidebar} 属性，使其成为 Shiny 控件输入的控制台 注：这一步不是必须的，但这是基于 Shiny 仪表盘的经典布局。 根据需求，添加 Shiny 的输入和输出。 当代码中包含绘图函数时（例如：hist()），得将它们封装在 renderPlot() 中。这有利于界面在布局更改时，自动调整尺寸大小。 5.2.4.2 Shiny 仪表盘的一个示例 图 5.17 给出了 Shiny 仪表盘的一个示例： --- title: &quot;间歇泉喷发&quot; output: flexdashboard::flex_dashboard runtime: shiny --- ```{r global, include=FALSE} # 在全局块中加载数据，以便仪表盘的所有用户可以共享 library(datasets) data(faithful) ``` 列 {.sidebar} -------------------------------------------------- 美国怀俄明州黄石国家公园的 Old Faithful 间歇泉在喷发和喷发之间的等待时间。 ```{r} selectInput( &quot;n_breaks&quot;, label = &quot;条形数：&quot;, choices = c(10, 20, 35, 50), selected = 20 ) sliderInput( &quot;bw_adjust&quot;, label = &quot;带宽调整：&quot;, min = 0.2, max = 2, value = 1, step = 0.2 ) ``` 列 -------------------------------------------------- ### 间歇泉喷发持续时间 ```{r} renderPlot({ erpt = faithful$eruptions hist( erpt, probability = TRUE, breaks = as.integer(input$n_breaks), xlab = &quot;Duration (minutes)&quot;, main = &quot;Geyser Eruption Duration&quot;, col = &#39;gray&#39;, border = &#39;white&#39; ) dens = density(erpt, adjust = input$bw_adjust) lines(dens, col = &quot;blue&quot;, lwd = 2) }) ``` 图 5.17: 基于 Shiny 的交互式仪表盘。 其中，仪表盘的第一列包含了 {.sidebar} 属性和两个 Shiny 的输入控件；第二列包含了绘制图表的 Shiny 代码。 注意：文档顶部标记为 global 的 R 代码块在全局环境中都可以被调用。这将为用户带来更好的启动性能，强烈推荐大家使用。 5.2.4.3 输入栏 通过添加 {.sidebar} 属性设置一个默认布局为左对齐，250 像素宽度的左侧边栏。 在搭建多个页面的仪表盘时，如果想创建一个应用于所有页面的工具条。这时，可以使用一级结构来定义侧边栏。 5.2.4.4 拓展 下面给出一些学习 Shiny 和创建交互式文档的资源： Shiny 官方网站( http://shiny.rstudio.com) ：包含大量的文章、教程和示例。 Shiny 网站上的文章“Introduction to Interactive Documents”，这是一个很好的入门指南。 关于部署交互式文档，读者可以使用 Shiny Server 或 RStudio Connect：https://www.rstudio.com/products/shiny/shiny-server/。 5.3 在 R package 中使用 R Markdown 5.3.1 写软件包的文档 如果有开发 R 包的经验，或者项目中编写的自定义函数需要清晰的文档和严格的测试，那么可以考虑将项目制作成一个 R 包。如果不知道如何创建一个 R 包，则可以很容易地在 RStudio IDE 中通过点击菜单 File -&gt; New Project 开始，选择项目类型为 R Package。此外，第 4.2 节还介绍了如何使用 R Markdown 开发 R 包，可以大大加速 R 包开发过程。 使用 R 包来管理项目有很多好处。例如，可以将数据集放在 data/ 文件夹中，在 R/ 下写 R 代码，生成文档到 man/（例如，使用 roxygen2 包(R-roxygen2?)），并将单元测试添加到 test/ 中。当涉及到 R Markdown 报告时，可以将它们作为 vignettes/ 下的软件包长文档来编写。在这些长文档中，可以加载数据集并调用包中的函数。当构建包时（通过 R CMD build 或 RStudio 命令），长文档将被自动编译。 要在 R Markdown 中创建一个包的长文档，最简单的方法是通过 RStudio 菜单 File -&gt; New File -&gt; R Markdown -&gt; From Template（见图5.18）。然后从 rmarkdown 包中选择 Package Vignette，将得到一个长文档的模板。在更改模板的标题、作者和其他元数据之后，就可以开始编写报告的内容了。 图 5.18: 在 RStudio 中创建一个包的长文档。 或者，也可以安装包 usethis (R-usethis?) 并使用其中的函数 usethis::use_vignette() 来创建一个长文档框架。下面是软件包长文档的 YAML 前端内容通常情况下的样子： --- title: &quot;Vignette Title&quot; author: &quot;Vignette Author&quot; output: rmarkdown::html_vignette vignette: &gt; %\\VignetteIndexEntry{Vignette Title} %\\VignetteEngine{knitr::rmarkdown} %\\VignetteEncoding{UTF-8} --- 需要注意的是，需要在 title 字段和 \\VignetteIndexEntry{} 命令中更改长文档的标题。除了长文档中的上述信息外，还需要在包的 DESCRIPTION 文件中做另外两件事： 在 DESCRIPTION 文件中指定 VignetteBuilder: knitr。 在 DESCRIPTION 文件中添加 Suggests: knitr, rmarkdown。 长文档的输出格式不一定非得是 HTML，也可以是 PDF，所以也可以使用 output: pdf_document。创建除 HTML 和 PDF 之外的任何其他输出格式也可以，比如 beamer_presentation 和 tufte::tufte_html。然而，目前 R 只识别 HTML 和 PDF 格式的长文档。 5.3.2 R 包中的 R Markdown 模板 第 5.3.1 节的图 5.18 给出了从 rmarkdown 包中检索可编辑的 Package Vignette（HTML）模板的过程。这个 R Markdown 文件预先填充了适用于 R 包长文档的元数据。 类似地，任何包都可以包含 R Markdown 模板，包的用户可以通过 RStudio IDE（如图 5.18 所示）或使用 rmarkdown::draft() 函数访问这些模板。 5.3.2.1 模板使用样例 模板是共享自定义结构、样式和内容的有效的方法，很多 R 包都使用了模版文档都方式提高代码的复用率。 许多模板通过预填充 YAML 元数据来添加结构和样式，例如 rmarkdown 包的 Package Vignette （HTML）模板。类似地，rmdformats 包(R-rmdformats?)提供了许多模板，这些模板将不同的自定义的样式函数传递给 output 选项。 其他模板演示了包所需的文档结构。例如，pagedown 包(R-pagedown?)包含了许多海报、简历和其他页面布局的模板。类似地，xaringan 包的 Ninja Presentation 模板(Xie 2022e)展示了许多不同幻灯片格式选项的语法。 模板也可以展示包的特性和语法。例如，flexdashboard 包(Iannone, Allaire, and Borges 2020)和 learnr 包(R-learnr?)都包含了带有代码块的模板，这些代码块分别调用包中的函数来创建示例仪表板或教程。 类似地，模板也可以包含样板内容。例如，rticles 包(Allaire, Xie, Dervieux, et al. 2022)提供了许多这样的模板，以使 R Markdown 输出符合不同学术期刊所需的风格和内容指导。样板内容在组织设置中也很有用，比如生成季度报告的团队。 5.3.2.2 模版设置 usethis 包(R-usethis?)可以创建 R Markdown 模版。运行 usethis::use_rmarkdown_template(\"Template Name\") 将自动创建所需的目录结构和文件（模板名应自己提供）。 如果想手动设置模板，可以在 inst/rmarkdown/templates 目录下创建一个子目录。在这个目录中，需要保存至少两个文件： 一个名为 template.yaml 的文件，它为 RStudio IDE 提供了基本的元数据，比如模板的可读名称。这个文件至少应该有 name 和 description 字段，例如： name: 模板样例 description: 这个模板做了什么 如果想在模板被选用时创建一个新目录，可以包含 create_dir: true，如果模板依赖于额外的资源，这也是有用的。例如，learnr 包的模板 设置了 create_dir: true，而 flexdashboard 包的模板则使用默认的 create_dir: false。可以尝试在 RStudio 中打开这两个模板，以注意到不同的用户提示。 保存在 skeleton/skeleton.Rmd 下 R Markdown 文档。这可能包含希望放入 R Markdown 文档中的任何内容。 可供选择的是，skeleton 文件夹可能还包括其他资源，如模板使用的样式表或图像。这些文件将与模板一起被加载到用户的计算机中。 建立自定义 R Markdown 模板的更多细节，请参阅 RStudio 扩展 的网站，以及 R Markdown Definitive Guide 的第十七章 “Document Templates”(Xie, Allaire, and Grolemund 2018a)。 参考文献 "],["rmarkdown-operation.html", "第 6 章 R Markdown 的操作技巧 6.1 表格操作进阶 6.2 块选项 6.3 结合其他语言 6.4 输出钩子 (*) 6.5 缓存 (*) 6.6 其它使用 knitr 的小技巧 (*)", " 第 6 章 R Markdown 的操作技巧 6.1 表格操作进阶 在日常报告中，表格是展示结果的主要方式之一，例如下表展示了某中学某次考试的学生成绩： grade &lt;- data.frame( 姓名 = c(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;), 语文 = c(89, 90, 85), 数学 = c(93, 97, 91), 英语 = c(92, 85, 97) ) knitr::kable(grade) 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 读者可以通过 knitr::kable() 函数的各项参数调整默认的表格外观，例如 align 参数可以调整表格的对齐方式，caption 参数可以添加表格的标题，一个改进版如表 6.1 所示： knitr::kable(grade, align=&#39;cccc&#39;, caption = &#39;考试成绩&#39;) 表 6.1: 考试成绩 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 除了居中操作以及添加标题外，在制作表格时还会产生各种各样的特定需求，例如合并单元格、添加底色等。本节将系统地介绍在 R Markdown 中生成表格和进一步对其个性化的方法，主要包括下列内容： 介绍 knitr::kable() 的用法和主要参数； 使用 kableExtra (Zhu 2021) 包扩展表格样式 提供其它生成表格的 R 包以供读者参考 6.1.1 利用函数 knitr::kable() 生成复杂的表格 在 R Markdown 中，通常使用 knitr 包中的函数 kable() 来快速创建一个表格。kable() 可以处理数据框、矩阵等“矩形数据”，快速生成表格，而表格的外观则可以通过修改函数参数来自定义，下面将对这些参数进行介绍： kable(x, format, digits = getOption(&quot;digits&quot;), row.names = NA, col.names = NA, align, caption = NULL, label = NULL, format.args = list(), escape = TRUE, ...) 6.1.1.1 表格样式 在大多数情况下，如果只需要制作一个简单表格，knitr::kable(x) 就足够了。其中第二个参数 format 会根据输出格式自动设置。它可能的取值是 pipe（列与列之间由短的竖线分隔的表），simple （仅包含横向分割线的简单表格），latex （LaTex 表格），html （HTML 表格），和 rst （reStructuredText 表格）。为了展示各个取值的不同，这里直接给出了各个取值在不同编程语言中的原始代码。 对于 R Markdown 文档，kable() 默认使用 pipe 格式的表格，输出结果如下所示： knitr::kable(grade, &#39;pipe&#39;) 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 knitr::kable() 也可以生成一个（基于 Pandoc 的）简单的表格，或 HMTL、LaTex 以及 reStructuredText 格式的表格： knitr::kable(grade, &#39;simple&#39;) 姓名 语文 数学 英语 ----- ----- ----- ----- 张三 89 93 92 李四 90 97 85 王五 85 91 97 knitr::kable(grade, &#39;html&#39;) &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; 姓名 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 语文 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 数学 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 英语 &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 张三 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 89 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 93 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 92 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 李四 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 90 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 97 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 85 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 王五 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 85 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 91 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 97 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; knitr::kable(grade, &#39;latex&#39;) \\begin{tabular}{l|r|r|r} \\hline 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\hline 张三 &amp; 89 &amp; 93 &amp; 92\\\\ \\hline 李四 &amp; 90 &amp; 97 &amp; 85\\\\ \\hline 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\hline \\end{tabular} knitr::kable(grade, &#39;rst&#39;) ==== ==== ==== ==== 姓名 语文 数学 英语 ==== ==== ==== ==== 张三 89 93 92 李四 90 97 85 王五 85 91 97 ==== ==== ==== ==== 需要注意的是，只有 pipe 和 simple 格式是“可移植”的，也就是说，它们适用于任何输出文档的格式，而其他格式则只适用于特定的输出格式，例如，format = 'latex' 只适用于 LaTeX 输出文档。使用特定的表格格式可以带来更多的自主控制能力，但代价是牺牲了可移植性。 如果想要为文档中的所有表格统一设置格式，可以使用选项 knitr.table.format。例如若只需要 LaTeX 格式的表格，则可以设置： options(knitr.table.format = &#39;latex&#39;) knitr.table.format 还可以接受一个函数处理更复杂的条件逻辑。例如，只在输出格式为 LaTeX 时使用 latex 格式: options(knitr.table.format = function() { if (knitr::is_latex_output()) &#39;latex&#39; else &#39;pipe&#39; }) 如果函数返回 NULL，knitr 将自动决定适当的格式。 6.1.1.2 修改列名 在一些情况下，在数据框（data frame）中定义的列的名称可能与想要显示给读者的内容不同，需要进行修改。在使用英文时，数据的列名通常不使用空格来分隔单词，而是使用点、下划线以及大小写来进行分隔。而在制作表格时，这样的变量名会显得有些不自然。在中文环境下，虽然空格的问题较少，但也存在变量名过长的情况，在 R 中也往往使用简化的名词或对应的英文简写来代替。在这种情况下，可以使用 col.names 参数将列名替换为一个包含新名称的向量，即 col.names = c(...)。例如，可以在上文成绩表的列名中提供更多信息： knitr::kable( grade, col.names = c(paste0(&#39;第1组&#39;, colnames(grade))) ) 第1组姓名 第1组语文 第1组数学 第1组英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 col.names 参数可以接受任意的字符向量（不一定是通过 paste0() 等函数修改的列名），只要向量的长度等于数据对象的列数即可，例如可以把列名换成英文： knitr::kable( grade, col.names = c(&#39;Name&#39;, &#39;Chinese&#39;, &#39;Math&#39;, &#39;English&#39;) ) Name Chinese Math English 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.1.3 指定列的对齐方式 如果想要改变表格中列的对齐方式，可以使用由字符 l （left，左对齐）、c （center，居中）以及 r （right，右对齐）组成的值向量或一个多字符的字符串来进行对齐，即 kable(..., align = c('c', 'l')) 和 kable(..., align = 'cl') 是等价的。在默认情况下，数字列是右对齐的，其他列是左对齐的。例如可以对成绩表进行调整，使得前两列右对齐，后两列左对齐： knitr::kable(grade, align = &#39;rrll&#39;) 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 而当对齐方式统一时，也可以用一个字母来代替，例如可以把成绩表所有列都居中表示： knitr::kable(grade, align = &#39;c&#39;) 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.1.4 添加表格标题 给表格添加标题需要用到 caption 参数，如表 6.2 所示： knitr::kable(grade, caption = &#39;考试成绩&#39;) 表 6.2: 考试成绩 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 正如本书 2.8.7 节所提到的那样，当一个表格有标题并且以 bookdown 来输出格式时，它可以被交叉引用，而在基础的 html_document 和 pdf_document 中则不行。 6.1.1.5 调整数字格式 有的时候，表格中的数字位数很长，展示的时候需要缩短，这时可以通过 digits 参数（会被传递给 round() 函数）来设置最大的小数位数，以及通过 format.args（会被传递给 R 中的 format() 函数）来设置其他格式化参数。 首先是几个简单的 round() 和 format() 的例子，从而可以更好地理解之后的 kable() 中 digits 参数是如何工作的: round(1.234567, 0) ## [1] 1 round(1.234567, digits = 1) ## [1] 1.2 round(1.234567, digits = 3) ## [1] 1.235 format(1000, scientific = TRUE) ## [1] &quot;1e+03&quot; format(10000.123, big.mark = &#39;,&#39;) ## [1] &quot;10,000.12&quot; 可以将数字四舍五入并格式化成表格： d = cbind( X1 = runif(3), X2 = 10^c(3, 5, 7), X3 = rnorm(3, 0, 1000) ) # 保留最多四位小数 knitr::kable(d, digits = 4) X1 X2 X3 0.4513 1e+03 -300.9029 0.7838 1e+05 528.2758 0.7097 1e+07 -622.8860 # 每列分别设置 knitr::kable(d, digits = c(5, 0, 2)) X1 X2 X3 0.45127 1e+03 -300.90 0.78378 1e+05 528.28 0.70968 1e+07 -622.89 # 不使用科学计数法 knitr::kable( d, digits = 3, format.args = list(scientific = FALSE) ) X1 X2 X3 0.451 1000 -300.903 0.784 100000 528.276 0.710 10000000 -622.886 # 给 big numbers 添加逗号 knitr::kable( d, digits = 3, format.args = list(big.mark = &#39;,&#39;, scientific = FALSE) ) X1 X2 X3 0.451 1,000 -300.903 0.784 100,000 528.276 0.710 10,000,000 -622.886 6.1.1.6 显示缺失值 表中可能存在缺失值，如该学生没有缺考或没有选修某个课。在默认情况下，R 中缺失值（如NA）在表格中显示为字符串NA，如： grade2 &lt;- data.frame(姓名 = c(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;), 物理 = c(NA,90,85), 政治 = c(93,97,NA), 计算机 = c(92,NA,97)) knitr::kable(grade2) # 默认显示 NA 姓名 物理 政治 计算机 张三 NA 93 92 李四 90 97 NA 王五 85 NA 97 为了使表格美观，也可以使用其他的值来替换它们，或者通过使用全局 R 选项 knitr.kable.NA 来调整显示的内容（例如使 NA 对应的单元格为空）。例如，可以将下面第一个表中的 NA 单元格设为空，然后在第二个表中显示 **： # 用空值代替 NA opts &lt;- options(knitr.kable.NA = &#39;&#39;) knitr::kable(grade2) 姓名 物理 政治 计算机 张三 93 92 李四 90 97 王五 85 97 # 用指定字符（**） 代替 NA options(knitr.kable.NA = &#39;**&#39;) knitr::kable(grade2) 姓名 物理 政治 计算机 张三 ** 93 92 李四 90 97 ** 王五 85 ** 97 options(opts) # 恢复全局 R 选项 6.1.1.7 转义特殊字符 HTML 和 LaTeX 中都包含了特殊字符，它们不显示为文本，而代表特定的格式，例如 HTML 里的 &amp;nbsp 和 LaTeX 里的 $ 等。当表格文本包含这些特殊字符时，kable() 将默认通过参数 escape = TRUE 来 转义这些特殊字符，即令这些特殊字符失去其特殊含义，显示文本本身（如 \\beta 将不会自动显示为 \\(\\beta\\)）。例如对于 HTML 格式的表格，&gt; 将被替换为 &amp;gt;；而对于 LaTeX 格式的表格，_ 将被转义为 \\_ 26。 如果需要特殊字符代表的格式，可以用 escape = FALSE 禁用转义，但要注意确保特殊字符不会在 LaTeX 或 HTML 中触发语法错误。表 6.3 展示了转义之后的结果，表 6.4 则展示了一些包含特殊字符（$、\\ 以及 _）的 LaTeX 数学表达式： # 添加数学表达式 g_range &lt;- data.frame( 成绩范围 = c(&quot;$\\\\ge 90$&quot;,&quot;$\\\\ge 80$&quot;, &quot;$\\\\ge 70$&quot;), 语文 = c(6,10,20), 数学 = c(3,7,16), 英语 = c(5,15,20) ) colnames(g_range) &lt;- c(&quot;成绩范围&quot;, &quot;$Chinese_{Jan}$&quot;, &quot;$Math_{Jan}$&quot;, &quot;$English_{Jan}$&quot;) knitr::kable( g_range, escape = TRUE, caption = &quot;escape = TRUE 生成的表&quot; ) 表 6.3: escape = TRUE 生成的表 成绩范围 \\(Chinese_{Jan}\\) \\(Math_{Jan}\\) \\(English_{Jan}\\) \\(\\ge 90\\) 6 3 5 \\(\\ge 80\\) 10 7 15 \\(\\ge 70\\) 20 16 20 knitr::kable( g_range, escape = FALSE, caption = &quot;escape = FALSE 生成的表&quot; ) 表 6.4: escape = FALSE 生成的表 成绩范围 \\(Chinese_{Jan}\\) \\(Math_{Jan}\\) \\(English_{Jan}\\) \\(\\ge 90\\) 6 3 5 \\(\\ge 80\\) 10 7 15 \\(\\ge 70\\) 20 16 20 如表 6.3 所示，如果设置 escape = TRUE，特殊字符将被转义或替换。例如，在 LaTeX 格式的表格中，$ 会被转义为 \\$、_ 被转义为 \\_ 以及 \\ 被替换为 \\textbackslash{}： knitr::kable(g_range[,1:2], format = &#39;latex&#39;, escape = TRUE) \\begin{tabular}{l|r} \\hline 成绩范围 &amp; \\$Chinese\\_\\{Jan\\}\\$\\\\ \\hline \\$\\textbackslash{}ge 90\\$ &amp; 6\\\\ \\hline \\$\\textbackslash{}ge 80\\$ &amp; 10\\\\ \\hline \\$\\textbackslash{}ge 70\\$ &amp; 20\\\\ \\hline \\end{tabular} 其他 LaTeX 中常见的特殊字符包括 #、%、&amp;、{ 以及 }；HTML 中常见的特殊字符包括 &amp;、&lt;、 &gt; 以及 \"。在生成带有 escape = FALSE 的表格时，需要格外小心并确保正确地使用了特殊字符。一个常见的错误是在使用 escape = FALSE 时，在 LaTeX 表格的列名或标题中包含 % 或 _ 等字符，而没有意识到它们是特殊的字符。 如果想知道 escape = TRUE 参数会如何转义特殊字符，可以通过 knitr 中两个内部辅助函数 escape_latex 和 escape_html 来分别查询在 LaTeX 和 HTML 格式的表格中的转义结果：。下面是一些例子： knitr:::escape_latex(c(&#39;100%&#39;, &#39;# 一个观点&#39;, &#39;文字_1&#39;)) ## [1] &quot;100\\\\%&quot; &quot;\\\\# 一个观点&quot; &quot;文字\\\\_1&quot; knitr:::escape_html(c(&#39;&lt;address&gt;&#39;, &#39;x = &quot;字符&quot;&#39;, &#39;a &amp; b&#39;)) ## [1] &quot;&amp;lt;address&amp;gt;&quot; &quot;x = &amp;quot;字符&amp;quot;&quot; &quot;a &amp;amp; b&quot; 6.1.1.8 并排多张表格 当 kable() 的第一个参数是包含多个数据框的列表时，它会生成多个并排放置的表格。例如，表 6.5 包含了之前展示过的两张表： # 数据对象 grade 和 grade2 由之前的代码块生成 knitr::kable( list(grade, grade2), caption = &#39;两张表并排放置&#39;, booktabs = TRUE, valign = &#39;t&#39; ) 表 6.5: 两张表并排放置 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 姓名 物理 政治 计算机 张三 NA 93 92 李四 90 97 NA 王五 85 NA 97 需要注意的是，此功能仅适用于 HTML 和 PDF 格式的输出。 另外，如果在并排放置各个表的时候，想能够分别自定义它们，可以使用 kables() 函数（即 kable() 的复数形式），并将一个对象为 kable() 的列表传递给它。例如，在表 6.6 中，可以更改左表中的列名，并将右表中的小数点位数设置为 4： # 数据对象 grade 和 d 由之前的代码块生成 knitr::kables( list( # 第一个 kable()：修改列名 knitr::kable( grade, col.names = c(&#39;Name&#39;, &#39;Chinese&#39;, &#39;Math&#39;, &#39;English&#39;), valign = &#39;t&#39; ), # 第二个 kable()：设置 digits 选项 knitr::kable(d, digits = 4, valign = &#39;t&#39;) ), caption = &#39;由 knitr::kables() 生成的两张表&#39; ) 表 6.6: 由 knitr::kables() 生成的两张表 Name Chinese Math English 张三 89 93 92 李四 90 97 85 王五 85 91 97 X1 X2 X3 0.4513 1e+03 -300.9029 0.7838 1e+05 528.2758 0.7097 1e+07 -622.8860 6.1.1.9 利用 for 循环生成多个表 (*) 结合 for 循环与 kable() 生成多张表时，有一点需要额外注意。必须在迭代中用 print() 显示打印 kable() 的结果，并应用块选项 results = 'asis'，例如： ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(grade)) } ``` 而下面的代码块只会在文档中输出最后一张表： ```{r} for (i in 1:3) { knitr::kable(grade) } ``` 这个问题并不特定于 kable()，同时也存在于许多其他的 R 包中。其背后原因较为复杂,对技术细节感兴趣的读者可以参考博文 “The Ghost Printer behind Top-level R Expressions.” 需要生成多个表格时，最好添加一些换行符（\\n）或 HTML 注释（&lt;!-- --&gt;），从而清晰地分隔所有输出的元素，例如： ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(grade, caption = &#39;标题&#39;)) cat(&#39;\\n\\n&lt;!-- --&gt;\\n\\n&#39;) } ``` 如果没有这些分隔符，Pandoc 可能无法检测到某些元素。例如，当一个图片之后面紧跟着一个表格时，这个表格并不会被识别到： ![](logo.png) 姓名 语文 数学 英语 ----- ----- ----- ----- 张三 89 93 92 李四 90 97 85 王五 85 91 97 解决办法是用空行或注释分隔图片和表格，例如： ![](logo.png) 姓名 语文 数学 英语 ----- ----- ----- ----- 张三 89 93 92 李四 90 97 85 王五 85 91 97 或者： ![](logo.png) &lt;!-- --&gt; 姓名 语文 数学 英语 ----- ----- ----- ----- 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.1.10 自定义 LaTeX 表格 (*) 如果只需要 LaTeX 格式的输出时，可以在 kable() 中使用一些额外的选项。注意在其他类型的输出中（如 HTML），这些选项将被忽略。除非已经设置了全局的表格格式选项（见本书 6.1.1.1 节），否则必须像本节的例子那样使用 kable() 的 format 参数，例如： knitr::kable(grade, format = &#39;latex&#39;, booktabs = TRUE) 带标题的表格（见本书 6.1.1.4 节）会被放入 table 环境中，即： \\begin{table} % 表格 (通常为 tabular 环境) \\end{table} 不同的环境有不同的默认排版方式，例如 LaTeX 会对 table 及 figure 等环境采用浮动布局。可以通过 table.envir 参数来对环境进行调整： knitr::kable(grade, format = &#39;latex&#39;, table.envir = &#39;Table&#39;) \\begin{Table} \\begin{tabular}{l|r|r|r} \\hline 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\hline 张三 &amp; 89 &amp; 93 &amp; 92\\\\ \\hline 李四 &amp; 90 &amp; 97 &amp; 85\\\\ \\hline 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\hline \\end{tabular} \\end{Table} 表格的位置由参数 position 来控制。例如，可以通过 position = \"!b\" 来强制将表格固定到页面的底部： knitr::kable(grade, format = &#39;latex&#39;, table.envir = &#39;table&#39;, position = &#39;!b&#39;) \\begin{table}[!b] \\begin{tabular}{l|r|r|r} \\hline 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\hline 张三 &amp; 89 &amp; 93 &amp; 92\\\\ \\hline 李四 &amp; 90 &amp; 97 &amp; 85\\\\ \\hline 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\hline \\end{tabular} \\end{table} 当表格有标题时，也可以通过 caption.short 参数给它分配一个短的标题，例如： knitr::kable(grade, caption = &#39;一个很长很长的标题！&#39;, caption.short = &#39;短标题&#39;) 短标题将会进入 LaTeX 中 \\caption[]{} 命令的方括号中，经常在 PDF 输出文档的表格目录中使用（如果不提供短标题，那里则会显示完整的标题）。 booktabs = TRUE 可以使用 LaTeX 包 booktabs{LaTeX package!booktabs} 进行表格排版。 knitr::kable(grade, format = &#39;latex&#39;, booktabs = TRUE) \\begin{tabular}{lrrr} \\toprule 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\midrule 张三 &amp; 89 &amp; 93 &amp; 92\\\\ 李四 &amp; 90 &amp; 97 &amp; 85\\\\ 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\bottomrule \\end{tabular} 需要注意的是，当在 R Markdown 文档中需要额外的 LaTeX 包时（如 booktabs），必须在 YAML 中声明这些包（请参阅第 3.2.4 节了解如何声明）： ```{r booktabs-false, include=knitr::is_latex_output()} knitr::kable(grade, format = &#39;latex&#39;, booktabs = FALSE, caption = &#39;booktabs = FALSE 时的表格&#39;) ``` ```{r booktabs-true, include=knitr::is_latex_output()} knitr::kable(grade, format = &#39;latex&#39;, booktabs = TRUE, caption = &#39;booktabs = TRUE 时的表格&#39;) ``` 图 6.1: booktabs 表格样式 对于 booktabs = FALSE： 表的列由垂直线分隔。可以通过 vline 参数来删除垂直线，例如 knitr::kable(grade, vline = \"\") （默认值是vline = \"|\"）。也可以将这个选项设置为一个全局的 R 选项，这样就不需要为每个表设置它，例如 options(knitr.table.vline = \"\")。 水平线可以通过参数 toprule、midrule、linesep 以及 bottomrule 来定义，它们的默认值都是\\hline。 对于 booktabs = TRUE： 表格中没有垂直线，但可以通过 vline 参数来添加。 表格只有标题和底部行有水平线。默认参数值是 toprule = \"\\\\toprule\"、midrule = \"\\\\midrule\" 以及 bottomrule = \"\\\\bottomrule\"。默认情况下，每 5 行加一个行间距（\\addlinespace），这是由参数 linesep 控制的，默认值为 c(\"\", \"\", \"\", \"\", \"\\\\addlinespace\")。如果想每 1 行加一个 \\addlinespace，则可以这样做： knitr::kable(grade, format = &#39;latex&#39;, linesep = c(&#39;\\\\addlinespace&#39;), booktabs = TRUE) \\begin{tabular}{lrrr} \\toprule 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\midrule 张三 &amp; 89 &amp; 93 &amp; 92\\\\ \\addlinespace 李四 &amp; 90 &amp; 97 &amp; 85\\\\ \\addlinespace 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\bottomrule \\end{tabular} 如果想删除所有的行间距，可以使用linesep = ''。 有的时候，表可能比一页还长。可以使用参数 longtable = TRUE，该参数使用 LaTeX 包 longtable 将表跨到多个页面。 另外，当表格被包含在 table 环境中时（例如，当表有标题时），表格默认居中对齐。如果不想让表格居中，可以使用参数 centering = FALSE。 6.1.1.11 自定义 HTML 表格 (*) 如果想自定义通过 knitr::kable(format = \"html\") 生成的表，除了前面提到的常见参数外，还有一个额外的参数需要注意：table.attr。这个参数允许用户向 &lt;table&gt; 标签添加任意属性。例如可以向表格中添加一个类striped： knitr::kable(grade, table.attr = &#39;class=&quot;striped&quot;&#39;, format = &quot;html&quot;) &lt;table class=&quot;striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; 姓名 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 语文 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 数学 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 英语 &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 张三 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 89 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 93 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 92 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 李四 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 90 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 97 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 85 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 王五 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 85 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 91 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 97 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 然而，类的名称不足以改变表的外观，必须定义 CSS27 类的规则。例如，要制作奇数行和偶数行有不同颜色的条纹表，可以为偶数行或奇数行添加浅灰色背景： .striped tr:nth-child(even) { background: #eee; } 上面的 CSS 规则意味着所有 striped 类的元素的子元素，且具有偶数行号（:nth-child(even)）的行（即 &lt;tr&gt; 标签），将它们的背景颜色设置为 #eee。 使用一点 CSS 可以使一个普通的 HTML 表看起来好看很多。图 6.2 是一个 HTML 表格的截图，其中应用了以下 CSS 规则： table { margin: auto; border-top: 1px solid #666; border-bottom: 1px solid #666; } table thead th { border-bottom: 1px solid #ddd; } th, td { padding: 5px; } thead, tfoot, tr:nth-child(even) { background: #eee; } 图 6.2: 利用 HTML 和 CSS 创建的条纹表 6.1.2 利用 kableExtra 美化表格 kableExtra 包(Zhu 2021) 设计的目的为扩展 knitr::kable() 生成表格的基本功能（见第 6.1.1 节）。由于 knitr::kable() 的设计很简单，就像很多其他的 R 包一样，它肯定有很多缺失的功能，而 kableExtra 完美地填补了空白，可以配合 knitr::kable() 生成更好看的表格。最令人惊讶的是，kableExtra 的大多数表格的特性都适用于 HTML 和 PDF 格式，例如，借助 kableExtra 包可以绘制如图 6.2 的条纹表。 一般情况下，kableExtra 包可以通过 CRAN 安装，也可以尝试 GitHub 上的开发版本 (https://github.com/haozhu233/kableExtra)： # 通过 CRAN 安装 install.packages(&quot;kableExtra&quot;) # 安装开发版本 remotes::install_github(&quot;haozhu233/kableExtra&quot;) https://haozhu233.github.io/kableExtra/ 提供了大量的文档，介绍了很多关于如何自定义 kable() 的 HTML 或 LaTeX 输出结果的例子。本节只提供几个示例，更多内容可参见该文档。 另外，kableExtra 包支持使用管道操作符 %&gt;%，可以将 kable() 的输出结果连到 kableExtra 的样式函数上，例如表 6.7： library(knitr) library(kableExtra) kable(grade, caption = &quot;条纹表&quot;) %&gt;% kable_styling(latex_options = &quot;striped&quot;) 表 6.7: 条纹表 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.2.1 设定字体尺寸 有的时候，在展示一些表格时，需要设定字体的尺寸，如放大或缩小某些特定问题。kableExtra 包中的 kable_styling() 函数可以帮助用户对整个表进行样式化。例如，可以指定页面上表格的对齐方式、表格的宽度和字体大小。表 6.8 展示了一个使用小字体的例子： kable(grade, booktabs = TRUE, caption = &quot;字体较小的表格&quot;) %&gt;% kable_styling(font_size = 8) 表 6.8: 字体较小的表格 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.2.2 特定的行或列的样式 有时还需要对表格的行或列的具体样式进行调整，如加粗某行等。函数 row_spec() 和 column_spec() 可分别用于样式化单独的行和列。表 6.9 将第一行文字加粗并设为斜体，将第二行添加黑色背景，同时更改字体颜色为白色并旋转，给第三行文字加下划线并更改其字体，并给第四列加删除线： kable(grade, align = &#39;c&#39;, booktabs = TRUE, caption = &quot;更改特定行或列的样式&quot;) %&gt;% row_spec(1, bold = TRUE, italic = TRUE) %&gt;% row_spec(2, color = &#39;white&#39;, background = &#39;black&#39;, angle = 45) %&gt;% row_spec(3, underline = TRUE, monospace = TRUE) %&gt;% column_spec(4, strikeout = TRUE) 表 6.9: 更改特定行或列的样式 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 类似地，也可以使用 cell_spec() 函数来给单个单元格设定样式。 6.1.2.3 给行或列分组 回想 Excel 里的操作，对单元格进行合并的操作可以给行或列进行分组。在 R Markdown 中，行和列可以分别通过函数 pack_rows() 和 add_header_above() 来进行分组。另外，也可以通过 collapse_rows() 来折叠行，这样一个单元格可以跨越多个行。表 6.10 展示了一个给标题列分组后的表格： grade3 &lt;- data.frame(姓名 = c(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;), 物理 = c(90,90,85), 化学 = c(86,92,80), 生物 = c(94,85,90), 政治 = c(93,97,95), 历史 = c(92,84,80), 地理 = c(99,89,95), 计算机 = c(92,95,97), 体育 = c(85,99,95)) kable(grade3, booktabs = TRUE, caption = &quot;对标题列进行分组&quot;) %&gt;% add_header_above(c(&quot; &quot; = 1, &quot;理科&quot; = 3, &quot;文科&quot; = 3, &quot;其它&quot; = 2)) 表 6.10: 对标题列进行分组 理科 文科 其它 姓名 物理 化学 生物 政治 历史 地理 计算机 体育 张三 90 86 94 93 92 99 92 85 李四 90 92 85 97 84 89 95 99 王五 85 80 90 95 80 95 97 95 对于 add_header_above() 中的命名向量，其名称是显示在表头中的文本，向量的整数值表示一个名称应该跨越多少列，例如，\"理科\" = 3 表示 理科 应该跨越三列。 表 6.11 提供了 pack_rows() 的示例，其中 index 参数的含义类似于之前解释过的 add_header_above() 参数： kable(grade3, booktabs = TRUE, caption = &quot;对行进行折叠&quot;) %&gt;% pack_rows( index = c(&quot;一班&quot; = 1, &quot;二班&quot; = 2) ) 表 6.11: 对行进行折叠 姓名 物理 化学 生物 政治 历史 地理 计算机 体育 一班 张三 90 86 94 93 92 99 92 85 二班 李四 90 92 85 97 84 89 95 99 王五 85 80 90 95 80 95 97 95 6.1.2.4 按比例缩小 LaTeX 中的表格 有一些特性是 HTML 或 LaTeX 输出格式特有的。例如，横向打印格式只在 LaTeX 中有意义，所以 kableExtra 中的 landscape() 函数只对 LaTeX 格式的输出有效。对于一个比较宽的表格（表 6.12），（表 6.13）展现了如何将表格按比例缩小以适应页面的宽度（否则该表格会太宽）： grade4 &lt;- merge(grade, grade3, by = &quot;姓名&quot;) kable(grade4, booktabs = TRUE, caption = &quot;原始表格（太宽）&quot;) 表 6.12: 原始表格（太宽） 姓名 语文 数学 英语 物理 化学 生物 政治 历史 地理 计算机 体育 张三 89 93 92 90 86 94 93 92 99 92 85 李四 90 97 85 90 92 85 97 84 89 95 99 王五 85 91 97 85 80 90 95 80 95 97 95 kable(grade4, booktabs = TRUE, caption = &quot;缩小后的表格&quot;) %&gt;% kable_styling(latex_options = &quot;scale_down&quot;) 表 6.13: 缩小后的表格 姓名 语文 数学 英语 物理 化学 生物 政治 历史 地理 计算机 体育 张三 89 93 92 90 86 94 93 92 99 92 85 李四 90 97 85 90 92 85 97 84 89 95 99 王五 85 91 97 85 80 90 95 80 95 97 95 注意如果在浏览 HTML 版本的话，表 6.12 和表 6.13 表格是没有差异的。 6.1.3 其它表格包 还有很多其他的 R 包可以用来生成表格。本节引入 kable() （见第 6.1.1 节）和 kableExtra （见第 6.1.2 节）的主要原因不是它们比其他包更好，而是因为作者们只熟悉它们，而且它们的功能可以涵盖大部分的日常使用需求。接下来本节将列出一些已知的其它软件包，感兴趣的读者可以去尝试并决定哪一个最适合自己。 flextable (R-flextable?) 和 huxtable (Hugh-Jones 2021)：flextable 和 huxtable 支持多种表格输出格式的包。它们都支持 HTML、LaTeX 以及 Office 格式，并且包含最常见的表格特性（例如条件格式化）。更多关于 flextable 的信息可参见：https://davidgohel.github.io/flextable/，huxtable 的说明文档则在：https://hughjonesd.github.io/huxtable/。 gt (R-gt?)：这个 R 包允许用户将表格的不同部分组合在一起，例如表头（标题和副标题）、列标签、表格主体、行组标签以及表格的脚注，从而组成一个完整的表格，其中有些部分是可选择性添加的。还可以格式化数字，并为单元格添加背景阴影。目前 gt 主要支持 HTML 输出。28更多关于 gt 的信息可参见：https://gt.rstudio.com。 formattable (R-formattable?)：这个 R 包提供了一些格式化数字的工具函数（如 percent() 和 accounting()），以及对列进行样式化的函数（如格式化文本，用背景阴影或颜色条注释数字，或在单元格中添加图标等等）。和 gt 相同，formattable 包也主要支持HTML格式。更多信息可参见GitHub项目：https://github.com/renkun-ken/formattable/。 DT (R-DT?)：它只支持 HTML 格式。DT 构建在 JavaScript 库 DataTables 之上，它可以将静态表转换为HTML页面上的交互式表。使用者可以对表进行排序、搜索和分页。DT 还支持格式化单元格，与 Shiny 一起构建交互式应用程序，并包含了大量的 DataTables 扩展（例如，可以将表格导出到Excel，或交互式重新排列表格的列）。更多信息可参见：https://github.com/rstudio/DT/。 reactable (R-reactable?)：与 DT 类似，这个包也基于 JavaScript 库创建交互式表。它在某些方面比 DT 更好（比如行分组和聚合操作，以及嵌入HTML小部件），但 reactable 并不包含 DT 全部的特性。更多信息可参见：https://glin.github.io/reactable/。 rhandsontable(R-rhandsontable?)：这个包也类似于 DT，并且和 Excel 比较像（例如，可以直接在表中编辑数据）。更多信息可参见：https://jrowen.github.io/rhandsontable/。 pixiedust (R-pixiedust?)：这个包通过 broom 包(R-broom?)来为为模型结果（如线性模型）创建表格，它支持 Markdown、HTML 以及 LaTeX 输出格式。更多信息可参见：https://github.com/nutterb/pixiedust/。 stargazer (R-stargazer?)：格式化回归模型和汇总统计表。更多信息可参见：https://cran.r-project.org/package=stargazer/。 xtable (Dahl et al. 2019)；这个包可能是最早的创建表格的包，其第一次发布是在 2000 年。它同时支持LaTeX和HTML格式。该软件包可在 CRAN 上访问：https://cran.r-project.org/package=xtable/。 还有一些其它生成表格的包，这里不再进一步介绍，只是在这里列出它们，以供感兴趣者参考：tables (R-tables?)、pander (Daróczi and Tsegelskyi 2022)、tangram (R-tangram?)、ztable (R-ztable?) 以及 condformat (R-condformat?)。 6.2 块选项 本节和接下来的第 6.4、6.6 两节进一步展示一些与 knitr 代码块选项相关的编程技巧。 R Markdown 支持超过 50 个块选项 用于调整 knitr 处理代码块的方式，完整列表可参阅在线文档https://yihui.org/knitr/options/。 下面的几节展示了在单个代码块中使用块选项的例子，希望为全部代码块统一设置块选项的读者可以参考第 2.7 节。 6.2.1 在块选项中使用变量 通常情况下，块选项中会使用常数（如：fig.width = 6），但有些时候仅使用常数无法满足需求，例如应展现的图像大小可能来源于其它代码块的结果，而非一成不变，每次根据结果来手动调整就会费时又费力。 块选项支持任意或简单或复杂的 R 表达式。一种特殊的情况是将代码块中定义的表达式传递给一个块选项。例如，为了满足图像大小变化的需求，可以在文档的一个代码块中定义关于图像宽度的变量，然后在其他代码块中使用它： ```{r} my_width &lt;- 7 ``` ```{r, fig.width=my_width} plot(cars) ``` 另外，块选项中也可以使用更为复杂的函数，例如可以使用 if-else 语句来调整图片大小： ```{r} fig_small &lt;- FALSE # 输出更大的图片需要改为 TRUE width_small &lt;- 4 width_large &lt;- 8 ``` ```{r, fig.width=if (fig_small) width_small else width_large} plot(cars) ``` 不仅如此，还可以只在所需要的包可使用时才运行一个代码块（eval=FALSE 意味着不运行该代码）： ```{r, eval=require(&#39;leaflet&#39;)} library(leaflet) leaflet() %&gt;% addTiles() ``` 需要注意的是，require('package') 只有当这个包已安装且可使用时才会返回 TRUE，否则会返回 FALSE。 6.2.2 允许错误 默认情况下，如果文档中的某一个代码块运行错误，R Markdown 将终止当前编译并跳过剩余代码块。但瑕疵掩不住美玉，一次报错不妨碍整体的质量；失败是成功之母，一次报错更是珍贵的学习机会。出于种种原因，用户希望在代码块报错的时候显示错误并继续运行，可以使用块选项 error = TRUE，例如： ```{r, error=TRUE} 1 + &quot;a&quot; ``` 这样在编译 R Markdown 文档后，将在输出文档中看到如下的错误消息： Error in 1 + &quot;a&quot;: non-numeric argument to binary operator 6.2.3 控制输出 默认情况下，knitr 会显示代码块的所有可能输出，包括源代码、提示信息（message）、警告（warning）、文本输出和图像输出等，但有时处于种种目的，只需要部分输出。本节将详细介绍如何控制各类结果的输出。 6.2.3.1 隐藏源代码、提示信息、警告、文本输出或图像输出 用户可以隐藏源代码和各类输出结果，包括信息、警告、文本和图像，可以使用相应的块选项来单独隐藏它们： 隐藏源代码： ```{r, echo=FALSE} 1 + 1 ``` 隐藏提示信息（message）： ```{r, message=FALSE} message(&quot;这个message不会显示&quot;) ``` 隐藏警告（warning）： ```{r, warning=FALSE} # 这将生成一个warning，但不会被输出 1:2 + 1:3 ``` 隐藏文本输出（也可以使用`results = FALSE`）： ```{r, results=&#39;hide&#39;} print(&quot;这个文本输出不会显示。&quot;) ``` 隐藏图形输出： ```{r, fig.show=&#39;hide&#39;} plot(cars) ``` 需要注意的是，上面的代码块会生成图形，它只是没有显示在输出中而已。 一个常见的需要隐藏的输出元素是某些包的加载信息。例如，在运行 library(tidyverse) 或 library(ggplot2) 时，可能会看到一些正在加载的 message。这类 message 也可以通过块选项 message = FALSE 来隐藏。 另外，还可以通过索引来有选择地显示或隐藏这些元素。下面的示例只输出了源代码的第四个和第五个表达式（注意，一个注释会被算作一个表达式）、前两个 message 以及第二个和第三个 warning： ```{r, echo=c(4, 5), message=c(1, 2), warning=2:3} # 一种生成服从N(0,1)分布的随机数的方法 x &lt;- qnorm(runif(10)) # 在实践中还可以使用 x &lt;- rnorm(10) x for (i in 1:5) message(&#39;这是 message &#39;, i) for (i in 1:5) warning(&#39;这是 warning &#39;, i) ``` 这些选项也支持负索引，例如，echo = -2 表示在输出中排除源代码的第二个表达式。 类似地，可以通过使用 fig.keep 选项 来选择显示或隐藏哪些图。例如，fig.keep = 1:2 意味着保留前两幅图。这个选项有一些快捷的方式，如 fig.keep = \"first\" 将只保留第一幅图、fig.keep = \"last\" 只保留最后的图以及 fig.keep = \"none\" 将丢弃所有的图。需要注意的是，fig.keep = \"none\" 和 fig.show = \"hide\" 这两个选项是不同的，后者将生成图像文件，只是会隐藏它们，而前者则根本不会生成图像文件。 对于 html_document 输出中的源代码块，如果不想完全省略它们（echo = FALSE），可以参考3.1.2.6节，来学习如何在页面上折叠它们，并允许报告用户通过单击展开按钮来展开它们。 6.2.3.2 隐藏代码块的所有输出 有的时候，可能希望正常执行代码块但隐藏源代码和所有输出。与使用第 6.2.3.1 节中提到的单独选项不同，include = FALSE 可以同时隐藏源代码和输出： ```{r, include=FALSE} # 任意 R 代码 ``` 注意，设置了 include=FALSE 的代码块仍会被运行，但读者将看不到任何的源代码、提示信息、警告、文本输出或图像输出等。 6.2.3.3 将文本输出压缩到源代码块中 R Markdown 默认把源代码和输出放置在不同的容器中。如果想把输出和源代码放在一起，可以使用块选项 collapse = TRUE，例如： 1 + 1 ## [1] 2 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 6.2.3.4 原样输出文本为 Markdown (*) 默认情况下，代码块的文本输出与源代码的样式一致。如果希望把代码块的输出直接作为后续的 Markdown 文本，可以通过添加块选项 results = 'asis' 来解决。这个选项告诉 knitr 不要将文本输出逐字包装成代码块，而是“原样”对待它。当想要从 R 代码动态生成内容时，这一点特别有用。例如，可以使用选项 results = 'asis' 从以下代码块生成 iris 数据的列名列表： cat(paste0(&#39;- `&#39;, names(iris), &#39;`&#39;), sep = &#39;\\n&#39;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 连字符（-）是 Markdown 中用于生成无序列表的语法，其中反引号是可选的。若没有设置 results = 'asis' 选项，则上述代码块的输出为： cat(paste0(&#39;- `&#39;, names(iris), &#39;`&#39;), sep = &#39;\\n&#39;) ## - `Sepal.Length` ## - `Sepal.Width` ## - `Petal.Length` ## - `Petal.Width` ## - `Species` 下面是一个完整的例子，展示了如何在 for 循环中为 mtcars 数据的所有列生成节标题、段落和图： --- title: 以编程的方式生成内容 --- 通过代码块选项 `results = &#39;asis&#39;`，可以将文本输出为 Markdown。 同时也可以与图片混合。 ```{r, mtcars-plots, results=&#39;asis&#39;} for (i in names(mtcars)) { cat(&quot;\\n\\n# 变量 `&quot;, i, &quot;` 的概要\\n\\n&quot;) x &lt;- mtcars[, i] if (length(unique(x)) &lt;= 6) { cat(&quot;`&quot;, i, &quot;` 是一个分类变量。\\n\\n&quot;) plot(table(x), xlab = i, ylab = &quot;频率&quot;, lwd = 10) } else { cat(&quot;连续变量 `&quot;, i, &quot;` 的直方图。\\n\\n&quot;) hist(x, xlab = i, main = &quot;&quot;) } } ``` 需要注意的是，上述示例代码中添加了过多的换行符（\\n），从而将不同的元素在 Markdown 中清晰地分开。在不同的元素之间使用过多的换行符是无害的，但是如果换行符不够，就会产生问题。例如，下面的 Markdown 文本就会产生很多的歧义： # 这是一个标题吗？ 这是一个段落还是标题的一部分呢？ ![这张图片呢？](foo.png) # 这行又是什么？ 如果产生了更多的空行（可以由cat('\\n')生成），则可以避免歧义： # 这是一个标题！ 这绝对是个段落。 ![这是一张图。](foo.png) # 这是另一个标题 cat() 函数不是唯一可以生成文本输出的函数，另一个常用的函数是 print()。但需要注意的是，print() 经常被 隐式 调用来打印对象，这就是为什么在 R 控制台（console）中输入一个对象或值后会看到输出。例如，当在 R 控制台中输入 1:5 并按下 Enter 键时，会看到输出，这是因为 R 实际上隐式地调用了 print(1:5)。经常令人感到困惑的是，不能在表达式（例如 for 循环）中直接生成输出，而如果在 R 控制台上输入对象或值，它们将被正确打印出来。这个主题非常技术性，具体细节可以参看博文“The Ghost Printer behind Top-level R Expressions”。如果对技术细节不感兴趣，只要记住这条规则即可：如果在 for 循环中没有看到输出，那么可能应该使用 print() 函数来显式地打印对象。 6.2.4 自动格式化源代码 多人协作中，维持统一的代码风格往往是令人头疼的问题，对空格、换行、括号等元素的不同使用习惯因人而异。即便是在单人工作中，时刻手动调整代码风格仍是件苦功夫。为了解决这个问题，R Markdown 提供了一个块选项 tidy 可以自动美化代码块的格式。 当设置块选项 tidy = TRUE 时， R 的源代码将被 formatR 包 (Xie 2022b)的 tidy_source() 函数重新格式化。tidy_source() 可以在几个方面重新格式化代码，比如在大多数操作符周围添加空格、适当缩进代码以及用 &lt;- 替换赋值操作符 = 。块选项 tidy.opts 可以是传递给 formatR::tidy_source() 的一个参数列表，例如： ```{r, tidy=TRUE, tidy.opts=list(arrow=TRUE, indent=2)} # 混乱的 R 代码... 1+ 1 x=1:10#有些使用者更喜欢用 &#39;&lt;-&#39; 来作为赋值操作符 if(TRUE){ print(&#39;Hello world!&#39;) # 缩进 2 个空格 } ``` 输出结果为： # 混乱的 R 代码... 1 + 1 x &lt;- 1:10 #有些使用者更喜欢用 &#39;&lt;-&#39; 来作为赋值操作符 if (TRUE) { print(&quot;Hello world!&quot;) # 缩进 2 个空格 } 块选项 out.width 可以控制输出的宽度。如果想进一步控制源代码的宽度，则可以在设置 tidy = TRUE 时使用 width.cutoff 参数，例如： ```{r, tidy=TRUE, tidy.opts=list(width.cutoff=50)} # 一个很长的表达式 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+ 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1 ``` 输出结果为： # 一个很长的表达式 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 更多可能的参数可以参见帮助页 ?formatR::tidy_source，也可以浏览 https://yihui.org/formatR/ 来了解这个函数的示例和局限性。 另外，还可以通过设定块选项 tidy = 'styler' 来使用 styler 包(R-styler?)重新格式化 R 代码，其中的格式化函数为 styler::style_text()。styler 包比 formatR 具有更丰富的特性。例如，它可以对齐函数参数并使用管道操作符 %&gt;%。块选项 tidy.opts 同样可以用于将附加参数传递给 styler::style_text()，例如： ```{r, tidy=&#39;styler&#39;, tidy.opts=list(strict=FALSE)} # 对齐赋值操作符 a &lt;- 1 # 一个变量 abc &lt;- 2 # 另一个变量 ``` R Markdown 默认设置 tidy = FALSE, 不会自动格式化代码。 6.2.5 调整文本输出中的前导符号 默认情况下，R Markdown 会在文本输出的前面插入两个符号 ##，那么这个符号能不能更改或者干脆删除呢？第 6.2.3.4 节介绍了通过在添加 results = 'asis' 选项来生成 Markdown 形式输出的方法。但如果只是想调整前导符号，而仍然想将文本放在单独的块中，则可以通过块选项 comment 来实现。如果要删除 ##，可以使用空字符串，例如： ```{r, comment=&quot;&quot;} 1:100 ``` 当然，可以使用任何其他的字符值，例如，comment = \"#&gt;\"。为什么 comment 选项默认为 ## 呢？这是因为 # 表示 R 中的注释，无论代码块的输出是什么，读者都可以直接复制整段代码并在 R 中运行。 6.2.6 为代码块添加属性 (*) 第 3.1.2.5 节展示了一些基于块选项 class.source 样式化代码块的示例。knitr 提供了更多类似的选项，如 class.output、class.message、class.warning 以及 class.error。另外的一个常见类是 .numberLines，可以用于为代码块添加行号。演示如下： ```{r, class.source=&#39;numberLines&#39;, eval=FALSE} if (TRUE) { x &lt;- 1:10 x + 1 } ``` if (TRUE) { x &lt;- 1:10 x + 1 } 注意，为了让 html_document 格式显示行号，需要在 YAML 元数据中使用任意非默认的高亮选项，例如 hightlight: pygment。 作为一个技术性拓展，块选项 class.* 只是 attr.* 的特殊情况，例如，class.source = 'numberLines' 等价于 attr.source = '.numberLines'（注意前面的点 .），但 attr.source 可以取任意的属性值，例如 attr.source = c('.numberLines', 'startFrom=\"11\"')。同理，可以用类似的 方法设置 attr.output、attr.message、attr.warning 以及 attr.error 等属性。 第 3.1.2.5 节介绍了 R Markdown 内置的 \"bg-primary\"，\"bg-success\"，\"bg-info\"，\"bg-warning\" 和 \"bg-danger\" 等样式类。本节的知识可以让读者定义自己的样式类，例如，可以在 CSS 中定义一个 myClass 类及其外观，然后通过 class.source = 'myclass' 来为代码块添加定义好的样式。例如： 定义 myClass 类： ```{css, echo = FALSE} @import url(&#39;https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&amp;display=swap&#39;); .myClass { background-color: #f1f3f5; padding: 0.4rem; border-radius: 0.25rem; border-left: 3px solid #31bae9; border-bottom: none; box-shadow: 0px 8px 5px -8px rgba(0,0,0,0.75); } .myClass code { font-family: &#39;Fira Code&#39;, monospace; } ``` 应用 myClass 类： ```{r, class.source = &quot;myClass&quot;, eval = FALSE} state.x77 |&gt; as.data.frame() |&gt; tibble::rownames_to_column(&quot;State&quot;) |&gt; dplyr::group_by(State) |&gt; dplyr::summarise(avg_murder_rate = mean(Murder)) ``` 属性 attr 也支持自定义行内 CSS 样式，例如 ```{r, attr.output=&#39;style=&quot;background: pink;&quot;&#39;} if (TRUE) { x &lt;- 1:10 x + 1 } ``` 1 + 1 ## [1] 2 基于类和属性的选项对 HTML 输出格式是通用的，部分情况下也支持其他格式。这些属性需要被 Pandoc 或第三方的包支持。例如 Pandoc 中，.numberLines 属性适用于 HTML 和 LaTeX 输出；第三方的包则通常需要通过一个 Lua 过滤器，感兴趣者请参见：https://bookdown.org/yihui/rmarkdown-cookbook/lua-filters.html。 更多类与属性的例子参见第 6.4.3 节。 6.2.7 同一张图的多种图像输出格式 在大多数情况下，报告可能只需要一种图像格式，例如 png 或 tiff。但有些时候，一些报告需要提交多种格式的图像，这就需要进一步了解图像格式选择的原理。 图像格式由块选项 dev 控制，即渲染图像的图像设备，这个选项的取值可以为设备名（即输出格式）的向量，例如： ```{r, dev=c(&#39;png&#39;, &#39;pdf&#39;, &#39;svg&#39;, &#39;tiff&#39;)} plot(cars) ``` 输出文档中只会呈现第一种格式的图像，但其它格式的图像也会被生成。这里需要注意的是，在默认情况下，图像文件在输出文档呈现后会立即被删除，如要保存这些文件，请参见7.1.5节。 6.2.8 图像的后期加工 (*) fig.process 可用于对代码块生成的图片做后期加工。fig.process 接受一个函数，其中的第一个参数是当前图片的路径，最终应该返回加工后的图片的路径。该函数还可以有第二个可选参数 options，代表一个由当前块选项组成的列表，这个列表可以用于定制图片处理的细节。 下面的例子展示了如何使用一个功能强大的 magick包 (Ooms 2021) 来在图像中添加 R logo。首先，定义一个函数 add_logo()： install.packages(&quot;magick&quot;) add_logo = function(path, options) { # 代码块中创建的图像 img = magick::image_read(path) # R logo logo = file.path(R.home(&quot;doc&quot;), &quot;html&quot;, &quot;logo.jpg&quot;) logo = magick::image_read(logo) # 默认的重力方向为西北，用户可以通过代码块来改变它 # option magick.gravity if (is.null(g &lt;- options$magick.gravity)) g = &#39;northwest&#39; # 在图像中添加 logo img = magick::image_composite(img, logo, gravity = g) # 写入新的图像中 magick::image_write(img, path) path } 该函数会读取图像的路径，添加 R logo，并将新图像保存到原路径。在默认情况下，logo 会被添加到图像的左上角（西北方向），但用户可以通过自定义块选项 magick.gravity（这个选项名可以是任意的）来自定义位置。 下一步就是将处理函数 add_logo() 应用到代码块中，并使用块选项 fig.process = add_logo 和 magick.gravity = \"northeast\"，所以 logo 会被添加到右上角。实际输出见图 6.3。 par(mar = c(4, 4, .1, .1)) hist(faithful$eruptions, breaks = 30, main = &#39;&#39;, col = &#39;gray&#39;, border = &#39;white&#39;) 图 6.3: 通过块选项 fig.process 来给一幅图添加 R logo。 下面的例子展示了 fig.process 选项的另一个应用，其中 pdf2png() 函数可以将 PDF 图像转换成 PNG 格式。第 6.2.9 节介绍了如何使用 tikz 图像设备来生成图，但该设备生成的 PDF 图不适用于非 LaTeX 的输出文档。而在设置块选项 dev = \"tikz\" 和 fig.process = pdf2png 后，就可以显示图 6.4 的 PNG 版本了。 pdf2png = function(path) { # 只对非LaTeX的输出进行转换 if (knitr::is_latex_output()) return(path) path2 = xfun::with_ext(path, &quot;png&quot;) img = magick::image_read_pdf(path) magick::image_write(img, path2, format = &quot;png&quot;) path2 } 6.2.9 输出高质量的图像 (*) 不同格式的图像往往在输出质量上有差异。rmarkdown 包为不同的输出格式设置了合理的默认图像设备。例如，对 HTML 输出格式使用 png() 设备，所以 knitr 将生成 png 绘图文件；而对 PDF 输出格式则使用 pdf() 设备。如果对默认图像设备的输出质量不满意，可以通过块选项 dev 来更改它们。knitr 支持的设备为：\"bmp\"，\"postscript\"，\"pdf\"，\"png\"，\"svg\"，\"jpeg\"，\"pictex\"，\"tiff\"，\"win.metafile\"，\"cairo_pdf\"，\"cairo_ps\"，\"quartz_pdf\"，\"quartz_png\"，\"quartz_jpeg\"，\"quartz_tiff\"，\"quartz_gif\"，\"quartz_psd\"，\"quartz_bmp\"，\"CairoJPEG\"，\"CairoPNG\"，\"CairoPS\"，\"CairoPDF\"，\"CairoSVG\"，\"CairoTIFF\"，\"Cairo_pdf\"，\"Cairo_png\"，\"Cairo_ps\"，\"Cairo_svg\"，\"svglite\"，\"ragg_png\"，以及\"tikz\"。 通常情况下，图像设备名也是函数名。更多关于图像设备的信息可以参阅 R 的帮助页面。例如，可以在 R 的控制台中输入 ?svg 来了解关于 svg 设备的细节，它包含在 R 的基础包中，所以不需要额外安装。需要注意的是，quartz_XXX 设备是基于 quartz() 函数的，并且它们仅在 macOS 上可用；CairoXXX 设备来自的 R 包 cairoDevice29；svglite 设备来自 svglite 包 (Hadley Wickham et al. 2022)；tikz 设备则在 tikzDevice 包 (Sharpsteen and Bracken 2020)中。如果需要使用这些包中的图像设备，必须先安装这些包。 通常，矢量图比位图质量更高，并且可以在不损失质量的情况下缩放矢量图。对于 HTML 输出，可以使用 dev = \"svg\" 或 dev = \"svglite\" 来绘制 SVG（可缩放矢量图，Scalable Vector Graphics）。需要注意的是，默认情况下 png 设备生成的图像为位图。 对于 PDF 输出，如果对图像中的字体非常挑剔，可以使用 dev = \"tikz\"，因为它提供了对 LaTeX 的原生支持，这意味着图像中的所有元素，包括文本和符号，都可以通过 LaTeX 以高质量呈现。图 6.4 展示了一个在R图像中用块选项 dev = \"tikz\" 添加 LaTeX 数学表达式的例子。 par(mar = c(4, 4, 2, .1)) curve(dnorm, -3, 3, xlab = &#39;$x$&#39;, ylab = &#39;$\\\\phi(x)$&#39;, main = &#39;The density function of $N(0, 1)$&#39;) text(-1, .2, cex = 3, col = &#39;blue&#39;, &#39;$\\\\phi(x)=\\\\frac{1}{\\\\sqrt{2\\\\pi}}e^{\\\\frac{-x^2}{2}}$&#39;) 图 6.4: 通过 tikz 设备呈现的图像。 需要注意的是，R 的基础包实际上支持数学表达式，但它们不是通过 LaTeX 呈现的（具体细节可参见 ?plotmath）。此外，还有几个高级选项可以调整 tikz 设备的排版细节（参见 ?tikzDevice::tikz）。例如，如果图像中包含多字节字符，可以设置选项： options(tikzDefaultEngine = &#39;xetex&#39;) 这是因为在处理 LaTeX 文档中的多字节字符时，xetex 通常比默认引擎 pdftex 要好。 tikz 设备主要有两个缺点。首先，它需要安装 LaTeX，但这其实并不会很麻烦（见第 2.2.1 节），虽然还需要几个 LaTeX 包，但这些包也可以通过 TinyTeX 很方便地安装： tinytex::tlmgr_install(c(&#39;pgf&#39;, &#39;preview&#39;, &#39;xcolor&#39;)) 其次，tikz 设备渲染图的速度通常要慢得多，因为这个设备会生成 LaTeX 文件，并且必须将其编译成 PDF。如果觉得代码块很耗时，可以通过块选项 cache = TRUE 来启用缓存（见第 6.5 节）。 图 6.4 实际上也使用了块选项 fig.process = pdf2png，当输出格式不是 LaTeX时，pdf2png 函数可以将 PDF 图转换为 PNG，其定义见第 6.2.8 节。如果没有这一转换，可能无法在 Web 浏览器中查看该书在线版本中的 PDF 图。 6.2.10 带有低级绘图功能的逐步绘图 (*) 在 R 中，有两种类型的绘图函数可以用来画图：高级的绘图函数用于创建新图，以及低级的绘图函数用于在现有的图中添加元素，更多信息请参见 R 手册《An Introduction to R》的第 12 章（“Graphical procedures”）。 在默认的情况下，当使用一系列低级的绘图函数来修改以前的图像时，knitr 不会显示中间的图，只会显示所有函数执行后的最后一个图。 然而有的时候，尤其是在教学过程中，展示中间的图像是很有用的。为此，可以设置块选项 fig.keep = 'low' 来保留各低级函数更改后的图。例如，图 6.5 和图 6.6 来自一个带有块选项 fig.keep = 'low' 的单个代码块，尽管它们很像两个代码块的输出结果。不仅如此，本节还通过块选项 fig.cap=c('cars ...', '在现有的...') 给它们分配了不同的标题。 par(mar = c(4, 4, .1, .1)) plot(cars) 图 6.5: cars 数据的点图 fit = lm(dist ~ speed, data = cars) abline(fit) 图 6.6: 在现有的点图中添加一条回归线 如果想在不同的代码块中继续修改这张图，请参阅第 6.6.5 节。 6.2.11 在代码块中自定义对象的打印格式 (*) 在默认的情况下，代码块中的对象会通过 knitr::knit_print() 函数来打印，基本上就相当于 R 中的 print()，但这往往并不能满足用户的需求。有的时候用户可能希望直接输出表格，除了第 6.1 节提到的方法外，还有更便捷的方法实现。 本质上，knit_print() 函数是一个 S3 泛型函数，这意味着可以通过在其上注册 S3 方法来拓展输出方式。下面的例子展示了如何通过 knitr::kable() 来自动将数据框打印成表格： --- title: 使用自定义的 `knit_print` 方法来打印数据框 --- 首先，定义一个 `knit_print` 方法，并注册它： ```{r} knit_print.data.frame = function(x, ...) { res = paste(c(&quot;&quot;, &quot;&quot;, knitr::kable(x)), collapse = &quot;\\n&quot;) knitr::asis_output(res) } registerS3method( &quot;knit_print&quot;, &quot;data.frame&quot;, knit_print.data.frame, envir = asNamespace(&quot;knitr&quot;) ) ``` 现在可以在数据框上测试这个自定义的打印方法。 需要注意的是，之后不再需要显式地调用 `knitr::kable()` 了。 ```{r} head(iris) ``` ```{r} head(mtcars) ``` 更多关于 knit_print() 函数的信息可参见 knitr 包的简介： vignette(&#39;knit_print&#39;, package = &#39;knitr&#39;) printr 包 (R-printr?)提供了一些 S3 方法来自动将 R 对象打印为表格。只需要在 R 代码块中输入 library(printr)，所有的方法都将自动注册。 一些 R Markdown 输出格式，如 html_document 和 pdf_document 提供了一个选项 df_print，它允许用户自定义数据框的打印行为。例如，如果想通过 knitr::kable() 来将数据框打印为表格，可以设置选项： --- output: html_document: df_print: kable --- 有关输出格式的更多细节可参阅输出格式的帮助页（如 ?rmarkdown::html_document），可以了解 df_print 选项支持哪些输出格式，以及对应的值是什么。 读者还可以通过块选项 render 来完全代替打印函数 knit_print()，render 可以使用任何函数来打印对象。例如，如果想使用 pander 包来打印对象，可以设置块选项 render 为函数 pander::pander： ```{r, render=pander::pander} head(iris) ``` 最终得到的结果为： Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa render 选项让用户可以充分定制任意对象的打印效果。 6.2.12 选项钩子 (*) 选项钩子（option hook）可以在代码块执行前操作块选项的值，或者定义新的块选项。例如，用户可能希望自动调整所有代码块的图片宽度 fig.width 不小于高度 fig.height。knitr 提供了对象 opts_hooks 来设置一个选项钩子，其中的 set() 用于覆盖块选项的执行逻辑。例如，可以在 knitr::opts_hooks$set() 中指定 fig.width，使它总是大于等于 fig.height： knitr::opts_hooks$set(fig.width = function(options) { if (options$fig.width &lt; options$fig.height) { options$fig.width = options$fig.height } options }) opts_chunk$set() 中的每一个元素都是一个函数，它的第一个参数是一个包含当前代码块所有选项的列表 options，由 knitr 在执行代码块前自动传入。如果想要修改选项，就可以修改 options 并返回更新后的列表。 对于下面的代码块，如果设置了上述的选项钩子，则 fig.width 将被修改为 6 而不是最初定义的 5： ```{r fig.width = 5, fig.height = 6} plot(1:10) ``` 选项钩子只会在块选项不是 NULL 时执行，而 fig.width 有非 NULL 的默认值，所以能确保该钩子执行。 另外，第 6.2.5 节的最后一个例子介绍了如何将输出格式调整成类似于 R 控制台（console）的格式，这一功能也可以用选项钩子实现，从而可以使用一个单独的块选项 console = TRUE 来代替 comment = \"\" 和 prompt = TRUE。需要注意的是，console 不是一个内置的 knitr 块选项，而是一个自定义的任意的选项名，它的默认值是 NULL。下面是一个完整的例子： ```{r, include=FALSE} knitr::opts_hooks$set( console = function(options) { if (isTRUE(options$console)) { options$comment &lt;- &#39;&#39;; options$prompt &lt;- TRUE } options }) ``` 默认输出为： ```{r} 1 + 1 if (TRUE) { 2 + 2 } ``` 设置 `console = TRUE` 时的输出为： ```{r, console=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` opts_hooks$set() 的参数可以是 knitr 内置的选项，也可以是自定义选项。下面的例子定义了新的块选项 numberLines，用于添加行号，涉及的元素包括源代码块、文本输出、提示信息、警告以及报错信息。 knitr::opts_hooks$set( numberLines = function(options) { attrs &lt;- paste0(&quot;attr.&quot;, options$numberLines) options[attrs] &lt;- lapply(options[attrs], c, &quot;.numberLines&quot;) options } ) knitr::opts_chunk$set( numberLines = c( &quot;source&quot;, &quot;output&quot;, &quot;message&quot;, &quot;warning&quot;, &quot;error&quot; ) ) 新选项 numberLines 在 options 列表中的 attr 元素上添加了一个新属性 .numberLines，实质上与 6.2.6 节中的 attr.&lt;element&gt; = \".numberLines\" 设置是等价的。numberLines = c('source', 'output') 代表给源代码和文本输出添加行号，等同于 attr.source = '.numberLines' 和 attr.output = '.numberLines'，而numberLines = NULL 会取消所有元素的行号。使用选项钩子的好处是更加简洁，且它不会覆盖现有的属性。用户也可以同时使用 numberLines 并设置属性： ```{r, numberLines=&quot;source&quot;, attr.source=&quot;startFrom=&#39;2&#39;&quot;} # 编号从 2 开始 1 + 1 ``` 6.3 结合其他语言 在 R Markdown 中，knitr 包除了支持 R 语言外，还支持许多其他语言。 不同语言代码块的表示方式类似，只需修改代码块中三个反引号后的花括号中的第一个单词即可。例如，```{r} 中的小 r 表示该代码块为 R 代码块，而 ```{python} 是指该代码块为 Python 代码块。其他语言也是使用类似的表达方式。 在 knitr 中，每种语言都通过语言引擎得到支持。语言引擎本质上是一些函数，它们以源代码和代码块选项作为输入，最后输出一个字符串。该过程通过 knitr::knit_engines 进行管理。读者可以使用以下方式检查现有引擎： names(knitr::knit_engines$get()) 在作者的电脑下，包含了以下引擎： ## [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; &quot;groovy&quot; &quot;haskell&quot; ## [7] &quot;lein&quot; &quot;mysql&quot; &quot;node&quot; &quot;octave&quot; &quot;perl&quot; &quot;psql&quot; ## [13] &quot;Rscript&quot; &quot;ruby&quot; &quot;sas&quot; &quot;scala&quot; &quot;sed&quot; &quot;sh&quot; ## [19] &quot;stata&quot; &quot;zsh&quot; &quot;asis&quot; &quot;asy&quot; &quot;block&quot; &quot;block2&quot; ## [25] &quot;bslib&quot; &quot;c&quot; &quot;cat&quot; &quot;cc&quot; &quot;comment&quot; &quot;css&quot; ## [31] &quot;ditaa&quot; &quot;dot&quot; &quot;embed&quot; &quot;exec&quot; &quot;fortran&quot; &quot;fortran95&quot; ## [37] &quot;go&quot; &quot;highlight&quot; &quot;js&quot; &quot;julia&quot; &quot;python&quot; &quot;R&quot; ## [43] &quot;Rcpp&quot; &quot;sass&quot; &quot;scss&quot; &quot;sql&quot; &quot;stan&quot; &quot;targets&quot; ## [49] &quot;tikz&quot; &quot;verbatim&quot; 注意：目前，大多数非 R 语言的代码块都是独立执行的。例如，同一文档中的所有 bash 代码块都在各自的会话中单独执行，因此后面的 bash 代码块不能使用在先前 bash 代码块中创建的变量，更改后的工作目录在其他 bash 代码块中也不会一直存在。 本节重点介绍 Pyhton、Shell、SAS、Stata 以及 Asymptote 等语言引擎，如果读者其他语言引擎感兴趣，例如：SQL, Rcpp, Stan, JavaScript, Julia, C，和 Fortran 等，可参见书籍 《R Markdown: The definitive guide》(Xie, Allaire, and Grolemund 2018b) 中的第 2.7 节内容，也可以在以下网站中找到更多的例子： https://github.com/yihui/knitr-examples。 6.3.1 注册自定义语言引擎 (*) 除了使用内置的引擎外，读者可以使用 knitr::knit_engines$set() 注册一个自定义语言引擎。该引擎接受一个函数，例如： knitr::knit_engines$set(foo = function(options) { # 源代码在 options$code }) 上面的代码注册了一个引擎，名称是 foo。接下来就可以使用以 ```{foo} 开头的代码块了。读者可以在 options$code 中以字符向量的形式访问代码块的源代码。例如，对于代码块： ```{foo} 1 + 1 2 + 2 ``` 此时，所对应的 options$code 为字符向量 c('1 + 1', '2 + 2')。目前 foo 引擎对应的函数没有做任何工作，所以代码块的输出为空。 下面定义了一个自定义引擎 upper， 它将代码块的内容转换为大写： knitr::knit_engines$set(upper = function(options) { code &lt;- paste(options$code, collapse = &#39;\\n&#39;) if (options$eval) toupper(code) else code }) 该 upper 引擎的作用是将 toupper 函数应用于代码，并以单个字符串的形式返回结果（通过 \\n 连接所有代码行）。注意 toupper() 仅在代码块选项为 eval = TRUE 时才会应用，否则返回原始字符串。 以上例子展示了如何在引擎函数中使用 eval 之类的代码块选项。类似地，读者也可以考虑在函数体中添加 if (options$results == 'hide') return() 来隐藏代码块选项时的输出 results = 'hide' 。下面是一个使用 upper 引擎及其输出的简单示例： ```{upper} Hello, **knitr** engines! ``` HELLO, KNITR ENGINES! 下面的例子实现了一个基础的 Python 引擎，名为 py。30。首先获得代码块中完整的 Python 代码，随后使用 system2() 函数在命令行调用 Python 解释器，最后格式化输出。 knitr::knit_engines$set(py = function(options) { code &lt;- paste(options$code, collapse = &#39;\\n&#39;) out &lt;- system2( &#39;python3&#39;, c(&#39;-c&#39;, shQuote(code)), stdout = TRUE ) knitr::engine_output(options, code, out) }) 以上代码的主要思路和细节介绍如下： 将输入的 Python 代码作为字符串存储到 code 中 system2() 调用 Python 解释器 python -c 'code' 执行代码，其中 -c 'code' 表示代码以字符串形式传入。并指定 stdout = TRUE 来收集（文本）输出。 之后，将代码块选项、源代码和文本输出传递给函数 knitr::engine_output()，作为最终输出结果。knitr::engine_output() 常用于返回运行结果，它会自动响应如 echo = FALSE 和 results = 'hide' 等块选项，所以这里不需要额外的 if 语句。 注意：knitr 中的许多语言引擎都是这样定义的（例如，使用 system2() 来执行与语言对应的命令）。如果读者对技术细节感兴趣，可以在下面网站中查看大多数语言引擎的源代码 https://github.com/yihui/knitr/blob/master/R/engine.R。 现在，可以使用新的引擎 py 运行 Python 代码，例如： ```{py} print(1 + 1) ``` ## 2 如果觉得自己自定义的语言引擎版本比现有版本更好，读者甚至可以通过 knitr::knit_engines$set() 重写现有的语言引擎。但是，通常不建议这样做，因为这会让熟悉现有引擎的用户感到不解。不过本节主要目的是告诉读者，自定义语言引擎来替换现有引擎这种想法是可以实现的。 knitr 中许多语言的引擎使用了类似的实现方法。读者可以在 https://github.com/yihui/knitr/blob/master/R/engine.R 查看内置语言引擎的源代码。 6.3.2 运行 Python 代码并与 Python 交互 reticulate (Ushey, Allaire, and Tang 2022) 包提供了 R Markdown 中默认的 Python 引擎。要将 Python 代码块添加到 R Markdown 文档中，可以在代码块头部设置为```{python}，例如： ```{python} print(&quot;Hello Python!&quot;) ``` Python 代码块支持部分 knitr 选项，比如 echo = FALSE 或 eval = FALSE 等。 reticulate 包的一个重要特性是它允许在 Python 和 R 运行环境中传递对象。例如，可以在 R 会话中通过 reticulate 包中的 py 对象访问或创建 Python 变量。例如： --- output: html_document --- ```{r, setup} library(reticulate) ``` 在 Python 会话中创建一个变量 `x`: ```{python} x = [1, 2, 3] ``` 在 R 代码块中访问 Python 变量 `x`: ```{r} py$x ``` 在 R 中创建变量，并传递给 Python 会话，命名为 `y`: ```{r} py$y &lt;- head(cars) ``` 在 Python 中使用变量 `y`： ```{python} print(y) print(type(y)) ``` 输出如图 6.7 所示。 图 6.7: R 与 Python 代码块的交互 在 R 和 Python 代码块互相传递对象时，reticulate 包会自动地进行类型转换。例如 R 中的向量在 Python 中变为列表，R 中的列表在 Python 中变为字典，R 中的数据框 data.frame 类变为 Python 中 pandas 库支持的 DataFrame 类等。 更多 reticulate 包的知识可以查看文档 https://rstudio.github.io/reticulate 。 comment 和 prompt 可以让 Python 的输出格式模仿 R 控制台。在 R 控制台中，用户不会在文本输出前面看到##。如果想模仿 R 控制台的行为， 可以使用 comment = \"\" 和 prompt = TRUE，例如： ```{r, comment=&quot;&quot;, prompt=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` 6.3.3 通过 asis 引擎有条件地执行内容 如果读者需要按一定条件输出某个代码块的内容，可以使用 asis 引擎来实现该功能。只需将条件加入到代码块选项 echo 中，当 echo = FALSE 时，对应代码块将不会显示内容，而当 echo = TRUE 时，对应代码块将会显示内容。下面给出一个简单的例子： ```{r} getRandomNumber &lt;- function() { sample(1:6, 1) } ``` ```{asis, echo = getRandomNumber() == 4} 根据 https://xkcd.com/221/, 这里生成的是一个**真**随机数! ``` 其中，第一个代码块中设定了一个函数并赋值到 getRandomNumber 中。第二个代码块使用了 asis 引擎，并将 echo 参数进行了设置。只有当条件 getRandomNumber() == 4 （随机）为真时，该代码块中的文本才会显示。 6.3.4 执行 Shell 脚本 读者有时需要执行 Shell 脚本来批量运行一些代码，在 R Markdown 中，读者可以根据自己的喜好，使用 bash、 sh 或 zsh 之间的任何一种引擎来运行 Shell 脚本。下面是一个使用 bash 引擎的示例： ls *.Rmd | head -n 5 ## [1] &quot;01-intro.Rmd&quot; &quot;02-base.Rmd&quot; &quot;03-document.Rmd&quot; ## [4] &quot;04-working.Rmd&quot; &quot;05-interaction.Rmd&quot; 需要注意的是，bash 是通过用 R 函数 system2() 调用的，该函数将忽略配置文件，例如 ~/.bash_profile 和 ~/.bash_login等，这些文件中可能定义了一些命令的别名或修改过的环境变量（如 PATH 变量）等。如果想要复现终端（terminal）的运行结果，可以设置引擎参数 engine.opts = ‘-l’ 显式加载配置文件。例如： ```{bash, engine.opts=&#39;-l&#39;} echo $PATH ``` 如果想对所有 bash 块全局启用 -l 参数，可以在文档开头的全局代码块（global chunk）中设置： knitr::opts_chunk$set(engine.opts = list(bash = &#39;-l&#39;)) 另外，还可以将其他参数作为字符向量提供给块选项 engine.opts，从而将其传递给 bash。 6.3.5 通过 cat 引擎将代码块内容写入文件 有时读者可能需要将代码块的内容写入文件。并在后续的代码块中引用该文件。一个简单的实现办法是使用 writeLines() 函数。例如： writeLines(&quot;添加反斜杠是件头疼的事，到底是 &#39;\\t&#39;、&#39;\\\\t&#39; 还是 &#39;\\\\\\\\t&#39;?&quot;, con = &quot;my-file.txt&quot;) 随后，需要使用 my-file.txt 文件中的内容时，可以用 readLines() 重新读取该文件。 当内容相对较长或包含特殊字符时，writeLines() 中繁琐的转义字符让代码的可读性较差。 注意：自 R 4.0.0 以来，这个问题已经大大缓解了，因为 R 开始支持 r\"( )\" 中的原始字符串（参见帮助页面 ?Quotes），而且读者不需要记住所有关于特殊字符的规则。即使使用原始字符串，在代码块中显式地将长字符串写入文件仍然会让读者分心。 另外一种更加巧妙的方法是借助 knitr 中的 cat 引擎。该引擎为读者提供了一种在代码块中呈现文本内容或将其写入外部文件的方法，并且无需考虑有关 R 字符串的规则（例如，读者需要使用双反斜杠，才能输出反斜杠）。 要将代码块内容写入文件，只需在代码块选项 engine.opts 中指定文件路径，例如 engine.opts = list(file = 'path/to/file')。此时，engine.opts 中指定的对象将传递给 base::cat()。 接下来，将提供三个示例来说明 cat 引擎的用法。 6.3.5.1 写入 CSS 文件 第一种方法是在 R Markdown 文档中嵌入一个 css 代码块，以使用 CSS 样式化元素。 另一种方法是通过一些 R Markdown 输出格式（如，html_document）的 CSS 选项为 Pandoc 提供一个定制的 CSS 文件。 cat 引擎可以用来从 Rmd 编写这个 CSS 文件。 下面的例子展示了如何从文档中的代码块生成 custom.css 文件，并将文件路径传递给 html_document 格式的 css 选项。 --- title: &quot;从代码块中创建一个 CSS 文件&quot; output: html_document: css: custom.css --- 下面的代码块中将写入 `custom.css` 文件，它会在 Pandoc 转换期间使用。 ```{cat, engine.opts = list(file = &quot;custom.css&quot;)} h2 { color: blue; } ``` ## 标题会变蓝 6.3.5.2 写入 LaTeX 文件 第 3.2.4.1 节介绍了 LaTeX 文档的通用结构。其中序言 (preamble) 部分常用于加载包和定制选项。R Markdown 支持在序言中插入任意 LaTeX 代码，可以用 cat 引擎将 LaTeX 代码插入 preamble.tex 文件中，并在 YAML 元数据中加载该文件。 --- title: &quot;从代码块中创建一个 .tex 文件&quot; author: &quot;Jane Doe&quot; classoption: twoside output: pdf_document: includes: in_header: preamble.tex --- # 它是如何运作的 将代码块写入文件 `preamble.tex` 以定义 PDF 输出文档的页眉和页脚： ```{cat, engine.opts=list(file = &#39;preamble.tex&#39;)} \\usepackage{fancyhdr} \\usepackage{lipsum} \\pagestyle{fancy} \\fancyhead[CO,CE]{This is fancy header} \\fancyfoot[CO,CE]{And this is a fancy footer} \\fancyfoot[LE,RO]{\\thepage} \\fancypagestyle{plain}{\\pagestyle{fancy}} ``` \\lipsum[1-15] # 更多随机内容 \\lipsum[16-30] 注意：cat 代码块中的内容主要目的是定义 PDF 文档的页眉和页脚。如果读者还想在页脚中显示作者姓名，可以使用engine.opts = list(file = 'preamble.tex', append = TRUE) 和 code = sprintf('\\\\fancyfoot[LO,RE]{%s}', rmarkdown::metadata$author)选项将作者信息附加到另一个 cat 代码块中，并使用 engine.opts 写入到 preamble.tex 文件中。 6.3.5.3 写入 YAML 文件 默认情况下，cat 代码块的内容不会显示在输出文档中。如果读者需要显示该 cat 代码块的内容，则需要将代码块选项 class.source 设置为某个语言名称。此时对应内容将会被高亮显示。下面给出一个例子，该例子将 class.source 设置为 yaml 语言： ```{cat, engine.opts=list(file=&#39;demo.yml&#39;), class.source=&#39;yaml&#39;} a: aa: &quot;something&quot; bb: 1 b: aa: &quot;something else&quot; bb: 2 ``` 此时，将会输出以下内容，并生成 demo.yml 文件。 a: aa: &quot;something&quot; bb: 1 b: aa: &quot;something else&quot; bb: 2 6.3.6 运行 SAS 代码 R Markdown 内置了 sas 引擎运行 SAS (https://www.sas.com) 代码。用户需要确保 SAS 可执行文件位于环境变量 PATH 中，或者也可以通过块选项 engine.path 指定 SAS 可执行文件的路径，例如：engine.path = \"C:\\\\Program Files\\\\SASHome\\\\x86\\\\SASFoundation\\\\9.3\\\\sas.exe\"。下面是一个输出 “Hello World” 的示例： ```{sas} data _null_; put &#39;Hello, world!&#39;; run; ``` 6.3.7 运行 Stata 代码 stata 引擎 可运行 Stata (https://www.stata.com) 代码。与 SAS 类似，R Markdown 会调用环境变量或 engine.path 指定的 Stata 可执行文件，例如：engine.path = \"C:/Program Files (x86)/Stata15/StataSE-64.exe\"。 ```{stata} sysuse auto summarize ``` knitr 内置的 stata 引擎功能有限。Doug Hemken 开发的 Statamarkdown 包 扩展了该引擎，Github 主页见 https://github.com/Hemken/Statamarkdown。 6.3.8 用渐近线 Asymptote 创建图形 渐近线 Asymptote （https://asymptote.sourceforge.io） 是一款为了绘制技术图形而设计的矢量图描述软件。 如果读者已经安装了 Asymptote，则可以使用 asy 引擎在 R Markdown 中编写并运行 Asymptote 代码。Asymptote 的安装可以参考官网 https://asymptote.sourceforge.io/。 下面给出一个简单的示例，该示例代码来自于 https://github.com/vectorgraphics/asymptote，其输出如图 6.8 所示： ```{asy, elevation, fig.cap=&#39; 用渐近线制作的 3D 图形。&#39;, eval=eval_asy()} import graph3; import grid3; import palette; settings.prc = false; currentprojection=orthographic(0.8,1,2); size(500,400,IgnoreAspect); real f(pair z) {return cos(2*pi*z.x)*sin(2*pi*z.y);} surface s=surface(f,(-1/2,-1/2),(1/2,1/2),50,Spline); surface S=planeproject(unitsquare3)*s; S.colors(palette(s.map(zpart),Rainbow())); draw(S,nolight); draw(s,lightgray+opacity(0.7)); grid3(XYZgrid); ``` 图 6.8: 用渐近线制作的 3D 图形。 上面代码块应用了选项 settings.prc = false。如果不进行此设置，当输出格式为 PDF 时，渐近线将生成交互式的 3D 图形。注意的是，想要进行图形交互（例如：使用鼠标来旋转图 6.8 ），需要使用 Acrobat Reader 软件查看。 注意: 如果读者需要输出 PDF 文件， 则可能需要安装一些额外的 LaTeX 包，否则可能会出现以下错误： ! LaTeX Error: File `ocgbase.sty&#39; not found. 这个错误是缺失了 LaTeX 包导致的，第 2.2.1.1 节介绍了解决办法。 6.3.8.1 Asymptote 读取 R 数据 下面是一个 Asymptote 使用 R 中数据的例子，首先将 R 中的数据保存到 CSV 文件中： x = seq(0, 5, l = 100) y = sin(x) writeLines(paste(x, y, sep = &#39;,&#39;), &#39;sine.csv&#39;) 然后用 Asymptote 读取该文件，并绘制出图 6.9，对应的代码如下所示： ```{asy, sine-curve, fig.cap=&#39;将数据从 R 传递到渐近线以绘制图形&#39;, cache=TRUE, fig.width=6,fig.align=&#39;center&#39;,fig.retina=1, eval=eval_asy()} import graph; size(400,300,IgnoreAspect); settings.prc = false; // import data from csv file file in=input(&quot;sine.csv&quot;).line().csv(); real[][] a=in.dimension(0,0); a=transpose(a); // generate a path path rpath = graph(a[0],a[1]); path lpath = (1,0)--(5,1); // find intersection pair pA=intersectionpoint(rpath,lpath); // draw all draw(rpath,red); draw(lpath,dashed + blue); dot(&quot;$\\delta$&quot;,pA,NE); xaxis(&quot;$x$&quot;,BottomTop,LeftTicks); yaxis(&quot;$y$&quot;,LeftRight,RightTicks); ``` 图 6.9: 将数据从 R 传递到渐近线以绘制图形 6.3.9 使用 Sass/SCSS 构建 HTML 页面 Sass (https://sass-lang.com) 是一种 CSS 扩展语言，它使用比普通 CSS 更灵活的方式创建 CSS 规则。Sass 在 CSS 的基础上引入了变量，规则，继承等更多编程特性，在语法上使用缩进而不是括号 { 分隔块，使用换行符替代分号 ; 分隔语句。下面是一个 scss 代码块： sass (Cheng et al. 2022) 包可用于将 Sass 汇编为 CSS。基于 sass 包，knitr 包含了两个语言引擎： sass和 scss （分别对应于 Sass 和 SCSS 语法）。其功能是将代码块编译为 CSS 语言。下面给出一个由 scss 构成的代码块： ```{sass} $font-stack: &quot;Comic Sans MS&quot;, cursive, sans-serif $primary-color: #0020FF .font-demo font: 100% $font-stack color: $primary-color ``` 上面的 Scss 代码定义了两个可以复用的变量 $font-stack 和 $primary-color，并且在 .font-demo CSS 类中引用这些变量设置了字体和颜色。效果如下： .font-demo{font:100% \"Comic Sans MS\",cursive,sans-serif;color:#0020FF} 在过去的十多年间，R 语言发展的十分迅猛，这其中就包括了 R Markdown。这段往事可能要追溯到 2007 年。那时候，还在中国人民大学上学的谢益辉开始使用 Sweave，并沉迷于此无法自拔。不仅自己在写作业的时候尽可能的使用 Sweave，还持之以恒地向同学们兜售。Sweave 的命名是 S + weave，前者指的是 S 语言，这是 R 语言的前身，后者含义即“编织”。Sweave 之所以受到谢同学的追捧，正是因为它可以将某些东西编织起来——代码和代码执行后的结果。直到今天，Sweave 仍然是 RStudio 中从 Rnw 文档生成 PDF 的重要工具之一。 块选项 engine.opts 可以定制 CSS 代码的输出样式，例如：engine.opts = list(style = \"expanded\")。默认的样式是 “compressed”。请参阅帮助页面 ?sass::sass_options 了解更多 output_style 可用的参数。 6.4 输出钩子 (*) 第 6.2.3 节介绍了如何通过使用 knitr 包控制代码块的每一段输出，如源代码、文本输出、图像输出以及 message 等。实际上，这一控制是通过“输出钩子”（Output Hook）实现的。大部分用户不需要了解钩子函数的底层细节。有兴趣的读者可以在 https://github.com/yihui/knitr/tree/master/R 找到内置钩子函数的源代码，它们的文件名格式为 hooks-*.R，例如，hooks-md.R 包含 R Markdown 中的钩子函数）。 在 R Markdown 中，输出钩子负责将代码块的输出转换为最终文档里的视觉元素。knitr 运行完代码块后将结果存储为字符向量，钩子函数将这个字符向量加工为新的字符向量并返回到文档中，这就是用户最终看到的结果。考虑下面的代码块： ```{r} 1 + 1 ``` knitr 运行该段代码后，得到两个字符串：源代码 \"1 + 1\" 和文本输出 \"[1] 2\"。现在需要两个输出钩子把它们转换为输出元素，一个负责源代码，一个负责文本输出。对于源代码，R Markdown 默认调用 knitr 中 source 钩子，它的简化版如下： # 对于上面的例子， `x` 为字符串 &quot;1 + 1&quot; function(x, options) { # 小写的 &quot;r&quot; 在这里表示编程语言的名称 paste(c(&quot;```r&quot;, x, &quot;```&quot;), collapse = &quot;\\n&quot;) } 上面的输出钩子函数将源代码转换为 Markdown 代码块，即以 ``` 开头和结尾，并添加语言标记。 类似的，处理文本输出的 output 钩子简化版如下： function(x, options) { paste(c(&#39;```&#39;, x, &#39;```&#39;), collapse = &#39;\\n&#39;) } 经过两个输出钩子的处理后，上述代码块的最终输出为： ```r 1 + 1 ``` ``` [1] 2 ``` source 和 output 的实际代码更为复杂，但背后的思想是一样的。读者可以通过在 knit_hooks 中查看钩子函数的源代码，例如： # 为了得到有意义的输出，以下代码应在一个 knitr 文档的代码块内部执行 knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$get(&#39;output&#39;) # 或者 knitr::knit_hooks$get(c(&#39;source&#39;, &#39;output&#39;)) 用户可以用 knit_hooks 中的 set() 函数覆盖 R Markdown 内置的钩子，从而定制文本输出。由于该方法将覆盖现有的默认钩子，所以最好先保存默认钩子的副本，以自己的方式处理输出元素，并将结果传递给默认钩子。常见的模式为： # 在这里使用 local() 是可选的，设置的原因只是想避免创建不必要的全局变量，如 `hook_old`） local({ hook_old = knitr::knit_hooks$get(&#39;NAME&#39;) # 保存现有的钩子 knitr::knit_hooks$set(NAME = function(x, options) { # 现在可以对 x 做任何处理，并将 x 传递给现有的钩子 hook_old(x, options) }) }) 这里，NAME 是钩子的名称，它可以是以下值之一： source：处理源代码； output：处理文本输出； warning：处理 warning （通常来自 warning()）； message：处理 message （通常来自 message()）； error：处理 error message （通常来自 stop()）； plot：处理图像输出路径； inline：处理行内 R 表达式的输出； chunk：处理整个块的输出； document：处理整个文档的输出。 钩子的 options 参数接受一个列表，表示当前代码块的块选项。例如，如果在一个块上设置 foo = TRUE，可以通过钩子中的 options$foo 获取它的值。但需要注意的是，参数 options 对 inline 和 document 钩子不可用。 输出钩子可以让使用者能够最终控制块和文档输出的每个单独部分。与块选项（第 6.2 节，通常具有预定义的用途）相比，输出钩子可能要强大得多，因为它们是用户自定义的函数，而且可以在函数中做任何想做的事情。 6.4.1 编辑源代码 有时用户可能希望隐藏部分源代码。例如，在连接数据库时隐藏密码。第 6.2.3.1 节谈到可以使用块选项 echo 隐藏或显示某一行（例如，通过 echo = 2 可以显示第二个表达式）。本节提供了一种更加灵活的方法，它不需要指定表达式的位置或索引。 它的基本思想是在代码中添加一个特殊的注释（例如，# SECRET!!）。当在代码中检测到该注释时，将自动忽略该行。下面是使用 source 钩子的完整示例: --- title: 用 `source` 钩子来隐藏某行代码 --- 首先，设置一个 `source` 钩子来匹配并隐藏（排除）末尾处包含字符串 `# SECRET!!` 的代码行： ```{r, include=FALSE} local({ hook_source &lt;- knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$set(source = function(x, options) { x &lt;- x[!grepl(&#39;# SECRET!!$&#39;, x)] hook_source(x, options) }) }) ``` 现在可以测试这个新的钩子。在编译这个文档时，读者将看不到带有特殊注释 `# SECRET!!` 的代码行。 ```{r} 1 + 1 # 正常显示代码 # 请使用你的用户名及密码 auth &lt;- httr::authenticate(&quot;user&quot;, &quot;passwd&quot;) auth &lt;- httr::authenticate(&quot;yihui&quot;, &quot;horsebattery&quot;) # SECRET!! httr::GET(&quot;http://httpbin.org/basic-auth/user/passwd&quot;, auth) ``` 上述 source 钩子的关键部分为下面这一行，它会通过 grepl() 来匹配源代码向量 x 中末尾处包含注释 # SECRET!! 的代码行，并隐藏（排除）它们： x &lt;- x[!grepl(&#39;# SECRET!!$&#39;, x)] 准确地说，上述的钩子将隐藏（排除）所有末尾处包含注释 # SECRET!! 的 表达式，而非单独的行，因为 x 实际上是一个由 R 中表达式组成的向量。例如，对于下面的代码块： 1 + 1 if (TRUE) { # SECRET!! 1:10 } 在 source 钩子中，x 的值为： c(&quot;1 + 1&quot;, &quot;if (TRUE) { # SECRET!!\\n 1:10\\n}&quot;) 如果想隐藏某些特定行而非 R 代码中完整的表达式，则必须将 x 分割成单独的行。可以考虑使用函数 xfun::split_lines()，钩子函数变为： x &lt;- xfun::split_lines(x) # 分为单独的行 x &lt;- x[!grepl(&#39;# SECRET!!$&#39;, x)] x &lt;- paste(x, collapse = &#39;\\n&#39;) # 组合成单个字符串 hook_source(x, options) 第 6.4.2 节介绍了 grepl() 函数之外更多操作操作字符串的选择。 6.4.2 向源代码中添加行号 有的时候，为了方便读者阅读或讨论代码，需要给源代码添加行号。该功能可以通过自定义 source 钩子实现。例如，对于下面代码块： ```{r} if (TRUE) { x &lt;- 1:10 x + 1 } ``` 希望得到的输出为： if (TRUE) { # 1 x &lt;- 1:10 # 2 x + 1 # 3 } # 4 实现这个功能的 source 钩子定义如下： --- title: 向源代码中添加行号 --- 本例设置了一个 `source` 钩子来向源代码中添加行号，行号会出现在每行末尾的注释中。 ```{r, include=FALSE} local({ hook_source &lt;- knitr::knit_hooks$get(&#39;source&#39;) knitr::knit_hooks$set(source = function(x, options) { x &lt;- xfun::split_lines(x) n &lt;- nchar(x, &#39;width&#39;) i &lt;- seq_along(x) # 行号 n &lt;- n + nchar(i) s &lt;- knitr:::v_spaces(max(n) - n) x &lt;- paste(x, s, &#39; # &#39;, i, sep = &#39;&#39;, collapse = &#39;\\n&#39;) hook_source(x, options) }) }) ``` 现在可以测试这个新钩子了。编译此文档时，将在每行末尾的注释中看到行号： ```{r} if (TRUE) { x &lt;- 1:10 x + 1 } ``` 上面这个例子中使用的主要技巧是确定每行注释之前需要的空格数，以便注释可以在右边对齐。该空格数取决于每行代码的宽度，本节将钩子函数中的代码留给读者来理解。需要注意的是，函数 knitr:::v_spaces() 用于生成指定长度的空格，例如： knitr:::v_spaces(c(1, 3, 6, 0)) ## [1] &quot; &quot; &quot; &quot; &quot; &quot; &quot;&quot; 在实际中，如果想要在源代码或文本输出中添加行号的话，直接在块选项部分添加attr.source = \".numberLines\" 或 attr.output = \".numberLines\" 来实现，该语法更简洁，并且适用于源代码和文本输出块。本节中介绍 source 钩子的主要目的是展示一种使用自定义函数操作源代码的可能性。 6.4.3 为长文本添加滚动条 在通过 HTML 进行展示的时候，当代码块或者文本输出过长时，可以对其添加滚动条。第 3.1.2.7节展示了如何通过 CSS 来实现上述功能。一个更简单的方法时使用块选项的 attr.source 和 attr.output 来将 style 属性添加 Markdown 输出中的分离代码块中（有关这些选项的更多信息，请参阅第 6.2.6 节）。例如，对于这个带有 attr.output 选项的代码块： ```{r, attr.output=&#39;style=&quot;max-height: 100px;&quot;&#39;} 1:300 ``` 它的 Markdown 输出为： ```r 1:300 ``` ```{style=&quot;max-height: 100px;&quot;} ## [1] 1 2 3 4 5 6 7 8 9 10 ## [11] 11 12 13 14 15 16 17 18 19 20 ## ... ... ``` 随后文本输出块将被 Pandoc 转换为 HTML： &lt;pre style=&quot;max-height: 100px;&quot;&gt; &lt;code&gt;## [1] 1 2 3 4 5 6 7 8 9 10 ## [11] 11 12 13 14 15 16 17 18 19 20 ## ... ...&lt;/code&gt; &lt;/pre&gt; 更多有关 Pandoc 中分离代码块的信息，可参阅其阅读手册：https://pandoc.org/MANUAL.html#fenced-code-blocks。 attr.source 和 attr.output 选项让使用者能够指定每个代码块的最大高度，但是对应的语法有点笨拙，需要更好地理解 CSS 和 Pandoc 的 Markdown 语法。下面的例子展示如何使用自定义块选项 max.height 来自定义输出钩子，这样只需要设置块选项，如 max.height = \"100px\" 而非 attr.output = 'style=\"max-height: 100px;\"'。本例只操作 options 参数，而不操作 x 参数： --- title: 可滚动的代码块 output: html_document: highlight: tango --- 本例设置了一个输出钩子，可以当块选项 `max.height` 已被设置时，向文本输出添加 `style` 属性： ```{r, include=FALSE} options(width = 60) local({ hook_output &lt;- knitr::knit_hooks$get(&#39;output&#39;) knitr::knit_hooks$set(output = function(x, options) { if (!is.null(options$max.height)) options$attr.output &lt;- c( options$attr.output, sprintf(&#39;style=&quot;max-height: %s;&quot;&#39;, options$max.height) ) hook_output(x, options) }) }) ``` 如果没有 `max.height`，可以看到完整的输出，即： ```{r} 1:100 ``` 现在设置 `max.height` 为 `100px`，这样可以在文本输出中看到一个滚动条，因为它的高度大于 100px。 ```{r, max.height=&#39;100px&#39;} 1:100 ``` 本质上，`max.height` 选项被转换为 `attr.output` 选项，并且即 `attr.output` 选项是存在的，这一转换也是有效的，也就是说，它不会覆盖 `attr.output` 选项，例如，可以通过 `.numberLines` 属性在文本输出的左侧显示行号： ```{r, max.height=&#39;100px&#39;, attr.output=&#39;.numberLines&#39;} 1:100 ``` 图 6.10 展示了代码的输出结果。需要注意的是，在最后一个代码块中使用块选项 attr.output 时，该选项将不会被 max.height 覆盖，因为这里将现有的属性与 max.height 生成的 style 属性组合在了一起： options$attr.output &lt;- c( options$attr.output, sprintf(&#39;style=&quot;max-height: %s;&quot;&#39;, options$max.height) ) 图 6.10: 一个可滚动文本输出的例子，其高度通过块选项max.height来给定 同样地，source 钩子中也可以使用相似的技巧来限制源代码块的高度。 6.4.4 截断文本输出 增加长文本可读性的另一个方法是限制最大显示行数。下面的例子通过输出钩子定义了块选项 out.lines 来限制文本输出的最大行数： # 保存内置的 output 钩子 hook_output = knitr::knit_hooks$get(&quot;output&quot;) # 设置一个新的 output 钩子来截断文本输出 knitr::knit_hooks$set(output = function(x, options) { if (!is.null(n &lt;- options$out.lines)) { x = xfun::split_lines(x) if (length(x) &gt; n) { # 截断文本输出 x = c(head(x, n), &#39;....\\n&#39;) } x = paste(x, collapse = &#39;\\n&#39;) } hook_output(x, options) }) 上述钩子函数的基本思想是，如果文本输出的行数大于块选项 out.lines 设置的阈值（存储在变量 n 中），只保留前 n 行，并添加省略号（....）来表示输出被截断。 现在可以通过设置块选项 out.lines = 4 来测试新的输出钩子，读者将会看到四行输出： print(cars) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 .... 由于已经将原始的输出钩子存储在 output 中，故可以通过再次调用 set() 来恢复它： knitr::knit_hooks$set(output = hook_output) 作为进一步的练习，可以尝试以不同的方式截断输出：给定块选项’ out.lines 来确定最大行数，能在中间而不是末尾截断输出吗？例如，如果设定 out.lines = 10，提取前 5 行和后 5 行，并在中间添加 .... 的输出是这样的： ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 .... ## 46 24 70 ## 47 24 92 ## 48 24 93 ## 49 24 120 ## 50 25 85 需要注意的是，输出的最后一行（即钩子函数的参数 x）可能是空行，所以可能需要设定 c(head(x, n/2), '....', tail(x, n/2 + 1))，其中 + 1 将最后的空行也纳入考虑。 6.4.5 以 HTML5 格式输出图像 默认情况下，R Markdown 的 HTML 输出中的图包含在标签 &lt;p&gt; 或 &lt;div&gt; 下的 &lt;img src=\"...\" /&gt; 中，但很多时候使用者可能想输出以 HTML531 格式来输出图像。 下面的例子展示了如何使用 HTML5 的标签 &lt;figure&gt; 来显示图像。 --- title: 在标签 `&lt;figure&gt;` 中输出图像 output: html_document --- 在块选项 `options$fig.cap` 中给定图像文件路径 `x` 和图像标题（caption），希望使用如下形式把图像写入 HTML5 的标签之中： ```html &lt;figure&gt; &lt;img src=&quot;PATH&quot; alt=&quot;CAPTION&quot; /&gt; &lt;figcaption&gt;CAPTION&lt;/figcaption&gt; &lt;/figure&gt; ``` 现在重新定义 `plot` 钩子（仅当输出格式为 HTML 时）: ```{r} if (knitr::is_html_output()) knitr::knit_hooks$set( plot = function(x, options) { cap &lt;- options$fig.cap # 图像标题 tags &lt;- htmltools::tags as.character(tags$figure( tags$img(src = x, alt = cap), tags$figcaption(cap) )) } ) ``` 代码块中的图像将被放置在 `&lt;figure&gt;` 标签之中： ```{r, fig.cap=&#39;一个`cars`数据的散点图&#39;} par(mar = c(4.5, 4.5, .2, .2)) plot(cars, pch = 19, col = &#39;red&#39;) ``` 可以进一步添加一些 CSS 样式来让 `&lt;figure&gt;` 和 `&lt;figcaption&gt;` 标签“看”起来更好一些（`figure` 有虚线边框，图像标题有浅粉色背景）： ```{css, echo=FALSE} figure { border: 2px dashed red; margin: 1em 0; } figcaption { padding: .5em; background: lightpink; font-size: 1.3em; font-variant: small-caps; } ``` 图像的输出如图 6.11 所示。注意，这个例子实际上覆盖了默认的 plot 钩子，而本节的大多数其他例子都是在默认钩子的基础上构建自定义钩子。只有当确定要忽略默认钩子的一些内置特性时，才应该完全覆盖默认钩子。例如，在本例中，plot 钩子函数没有考虑像 out.width = '100%' 或 fig.show = 'animate' 这样的块选项。 图 6.11: 一个在HTML5 figure 标签中的图像 上例展示了在 plot 钩子 中使用图像文件路径 x 可以进行的操作。如果所需要的只是自定义图像的样式，则不必使用 HTML5 标签。通常情况下，默认的 plot 钩子会以如下的 HTML 代码输出图像： &lt;div class=&quot;figure&quot;&gt; &lt;img src=&quot;PATH&quot; /&gt; &lt;p class=&quot;caption&quot;&gt;CAPTION&lt;/p&gt; &lt;/div&gt; 所以可以仅为 div.figure 和 p.caption 定义 CSS 规则。 6.5 缓存 (*) 6.5.1 缓存耗时的代码块 在一个报告中，往往会有一些运行起来很费时且很关键的代码块（如数据预处理等）。为了节省时间，可以考虑通过块选项 cache = TRUE 来缓存该代码块的结果。当启用缓存时，如果一个代码块之前被执行过且之后没有任何变化时，knitr 将跳过这个代码块的执行，从而大大缩短编译所需的时间。而当再次修改代码块时（如修改代码或块选项），之前的缓存将自动失效，并且 knitr 将再次运行并缓存该代码块。 对于一个被缓存了的代码块，它的输出以及变量对象将从上一次的运行中自动加载，就像该代码块被再次执行了一样。当加载结果比计算结果快得多时，缓存操作通常是有用的。然而，天下没有免费的午餐，有的时候 knitr 会令缓存失效或是部分失效，如外部文件内容的改变可能没有体现在报告中等等。更多关于如何缓存，特别是缓存失效的相关知识可参见：https://yihui.org/en/2018/06/cache-invalidation/。 缓存的一个典型应用场景是保存和重新加载那些需要很长时间才能在代码块中计算的 R 对象。需要注意的是，代码需要没有任何“副产物”，否则建议不要进行缓存。例如在使用 options() 更改全局 R 选项时，产生的更改不会被缓存。 正如前文提到的，缓存依赖于代码或块选项。如果改变了任何块选项（除了 include 选项），缓存将会失效。此特性可用于解决一个常见的问题，即当代码需要读取外部数据文件时，应在更新数据文件时使缓存失效，那仅仅像下面这样简单地使用 cache = TRUE 是不够的： ```{r import-data, cache=TRUE} d &lt;- read.csv(&#39;数据.csv&#39;) ``` 必须要让 knitr 知道数据文件是否已被更改。一种方法是添加另一个块选项 cache.extra = file.mtime('数据.csv')，或者更严格的方式：cache.extra = tools::md5sum('数据.csv')。前者意味着如果文件的修改时间发生了变化，就需要使缓存失效；而后者的意思是，如果文件的内容被修改，就更新缓存。需要注意的是，cache.extra不是一个内置的 knitr 代码选项，可以为该选项使用任何其他名称，只要它不与内置选项名称冲突。 类似地，还可以将缓存与其他信息相关联，比如R的版本（cache.extra = getRversion()）、时间（cache.extra = Sys.Date()）或是操作系统（cache.extra = Sys.info()[['sysname']]），当这些条件改变时，可以使缓存正确地失效。 需要注意的是，本书不建议在文档中设置全局块选项 cache = TRUE，因为缓存可能相当棘手。相反的，可以只在个别耗时很久的代码块上启用缓存，这样并不会产生副产物。 如果对 knitr 的缓存设计不满意，还可以选择自己缓存对象，下面是一个简单的例子： if (file.exists(&#39;结果.rds&#39;)) { res = readRDS(&#39;结果.rds&#39;) } else { res = compute_it() # 一个很耗时的函数 saveRDS(res, &#39;结果.rds&#39;) } 在这一例子中，使缓存失效的唯一（也是简单的）方法就是删除文件results.rds。如果对这个简单的缓存机制感兴趣，可以使用在6.5.4节中介绍的函数xfun::cache_rds()。 6.5.2 为多种输出格式缓存代码块 当通过块选项 cache = TRUE启用缓存时，knitr 将把在代码块中生成的 R 对象写入缓存数据库，以便下次重新加载它们。缓存数据库的路径由块选项 cache.path 决定。默认情况下，R Markdown 对不同的输出格式会使用不同的缓存路径，这意味着对于每种输出格式都将完全执行一次这个（耗时的）代码块。这可能很不方便，但这种默认的行为是有原因的，即代码块的输出可能依赖于特定的输出格式。例如，生成图像，当输出格式为word_document时，图像的输出可能是像 ![text](path/to/image.png) 这样的标记代码；而或者当输出格式为 html_document 时，输出的HTML代码则类似 &lt;img src=\"path/to/image.png\" /&gt;。 当代码块没有任何副产物（如图像）时，对所有输出格式使用相同的缓存数据库是安全的，还可以节省时间。例如，当读取一个大型数据对象或运行一个比较耗时的模型时，若结果不依赖于输出格式，就可以使用相同的缓存数据库。可以通过块选项 cache.path ，例如： ```{r important-computing, cache=TRUE, cache.path=&quot;cache/&quot;} ``` 实际上，在 R Markdown 中，cache.path 的默认设置为 cache.path = \"INPUT_cache/FORMAT/\"，其中 INPUT 代表输入的文件名，FORMAT 为输出格式（如 html、latex 或 docx），这就导致了不同的输出格式对应不同的缓存路径。 6.5.3 缓存大型的对象 当设定块选项 cache = TRUE 时，缓存的对象将被延迟加载到 R 中，这意味着对象将不会从缓存数据库中读取，直到它在代码中被实际使用。当不是所有对象都在文档中稍后被使用时，这一操作可以节省一些内存。例如，如果读取了一个大型的数据对象，但在后续的分析中只使用了其中的一个子集，那么原始的数据对象将不会从缓存数据库中加载： ```{r, read-data, cache=TRUE} full &lt;- read.csv(&quot;大型数据集.csv&quot;) rows &lt;- subset(full, price &gt; 100) # 之后只使用 `rows` 数据集 ``` ```{r} plot(rows) ``` 然而，当一个对象太大时，可能会遇到这样的报错： Error in lazyLoadDBinsertVariable(vars[i], ... long vectors not supported yet: ... Execution halted 如果出现这个问题，可以尝试通过块选项 cache.lazy = FALSE 来关闭延迟加载，这样该代码块中的所有对象都将立即被加载到内存中。 6.5.4 基于 cache_rds() 的缓存 如果在使用的过程中，觉得前文介绍的基于 knitr 的缓存机过于复杂，可以考虑使用基于函数 xfun::cache_rds() 的一个更简单的缓存机制，例如： xfun::cache_rds({ # 在这里编写耗时的代码 }) 关于 knitr 缓存，其棘手之处在于如何决定何时使缓存失效，而使用 xfun::cache_rds() 则要清楚得多：第一次将 R 表达式传递给这个函数时，它会计算表达式并将结果保存到 .rds 文件中；下次再次运行 cache_rds() 时，它会读取 .rds 文件，并立即返回结果，而不再次计算表达式。使缓存无效的最明显的方法是删除 .rds 的文件。如果不想手动删除它，则可以用参数 rerun = TRUE 来调用 xfun::cache_rds()。 当 xfun::cache_rds() 在 knitr 源文档的一个代码块中被调用时，.rds 文件的路径由块选项 cache.path 和块标签决定。例如，对于在 Rmd 文档 input.Rmd 中带有块标签 foo 的代码块： ```{r, foo} res &lt;- xfun::cache_rds({ Sys.sleep(3) 1:10 }) ``` .rds 文件的路径格式为 input_cache/FORMAT/foo_HASH.rds，其中 FORMAT 是 Pandoc 输出格式名称（例如 html 或 latex）， HASH 是一个MD5哈希值，包含了 32 个十六进制数字（a-f 和 0-9），例如 input_cache/html/foo_7a3f22c4309d400eff95de0e8bddac71.rds。 如帮助页面 ?xfun::cache_rds 所述，通常在两种的情况下可能想要使缓存失效：（1）待求值表达式中的代码发生了变化；（2）代码使用了一个外部变量，并且该变量的值已经改变。本节接下来将解释这两种情况下缓存是如何失效的，以及如何将缓存的多个副本保存到对应于不同版本的代码中。 6.5.4.1 使缓存失效 cache_rds() 中的内容改变时（例如，从 cache_rds({x + 1}) 改为 cache_rds({x + 2})），缓存将自动失效，表达式将被重新计算。但是需要注意的是，空格或注释的变化是不重要的，或者一般来说，只要更改不影响已解析的表达式，缓存就不会失效。例如，下面传递给 cache_rds() 的两个表达式在本质上是相同的： res &lt;- xfun::cache_rds({ Sys.sleep(3); x&lt;-1:10; # 分号不影响 x+1; }) res &lt;- xfun::cache_rds({ Sys.sleep(3) x &lt;- 1:10 # 一个注释 x + 1 # 可以随意修改空格部分 }) 因此，如果对第一个表达式执行 cache_rds() ，那么第二个表达式将能够调用缓存的结果。这一特性非常有用，因为其允许在代码中进行修饰性更改，而不会使缓存失效。 如果不确定两个版本的代码是否相等，则可以尝试下面的 parse_code() 函数： parse_code &lt;- function(expr) { deparse(substitute(expr)) } # 空格或分号不影响 parse_code({x+1}) ## [1] &quot;{&quot; &quot; x + 1&quot; &quot;}&quot; parse_code({ x + 1; }) ## [1] &quot;{&quot; &quot; x + 1&quot; &quot;}&quot; # 左箭头和右箭头是等价的 identical(parse_code({x &lt;- 1}), parse_code({1 -&gt; x})) ## [1] TRUE 通常情况下，表达式中有两种类型的变量：全局变量和局部变量。全局变量是在表达式外部创建的，局部变量则是在表达式内部创建的。如果表达式中全局变量的值发生了变化，那么缓存的结果和再次运行的结果之间可能会产生差异。例如，在下面的表达式中，y 相对于 cache_rds 是全局变量： y &lt;- 2 res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }) cache_rds() 不能自动检测发生在全局变量上的变化。如果想要在 y 变化时重新计算 res，需要显示声明 y 作为表达式的依赖项。hash 参数接受一个列表作为表达式的依赖项： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }, hash = list(y)) knitr 用哈希记值记录列表中每个元素的状态以及它们是否被改变。当 hash 中的任意值改变时，对应的哈希值发生变化，knitr 于是知道应该让缓存失效。例如，如果想要使缓存依赖于 y 以及 R 的版本，可以这样指定依赖： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }, hash = list(y, getRversion())) 或者如果想让缓存依赖于 y 以及数据文件最后一次修改的时间，可以这样做： res &lt;- xfun::cache_rds({ x &lt;- read.csv(&quot;数据.csv&quot;) x[[1]] + y }, hash = list(y, file.mtime(&quot;数据.csv&quot;))) 如果不想为 hash 参数提供全局变量的列表，则可以尝试 hash = \"auto\"，它将使 cache_rds() 自动找出所有的全局变量，并将它们作为 hash 参数的值，例如： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y + z # y 和 z 是全局变量 }, hash = &quot;auto&quot;) 这等价于： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y + z # y 和 z 是全局变量 }, hash = list(y = y, z = z)) 当 hash = \"auto\" 时，全局变量由 codetools::findGlobals() 识别，这可能不是完全可靠的，所以如果需要完全确定哪些变量可以使缓存失效，本书建议在 hash 参数中显示给定依赖列表。 6.5.4.2 保留缓存的多个副本 由于缓存通常用于非常耗时的代码，在使其失效时应当保守一些。有的时候可能会因过早或主动地使缓存失效而后悔，因为如果再次需要一个旧版本的缓存时，则将不得不等待很长的时间才能重新完成计算。 若将 cache_rds() 中的 clean 参数设置为 FALSE，则将允许保留旧的缓存副本。也可以设置全局 R 选项 options(xfun.cache_rds.clean = FALSE) 来使其成为文档的默认行为。在默认情况下，clean = TRUE 和 cache_rds() 每次都会尝试删除旧的缓存。如果还在进行代码测试，那么设置 clean = FALSE 会很有用。例如，可以缓存一个线性模型的两个版本： model &lt;- xfun::cache_rds({ lm(dist ~ speed, data = cars) }, clean = FALSE) model &lt;- xfun::cache_rds({ lm(dist ~ speed + I(speed^2), data = cars) }, clean = FALSE) 在决定使用哪个模型之后，可以再次设置 clean = TRUE，或者删除 clean 参数（默认为 TRUE）。 6.5.4.3 与 knitr 的缓存比较 那么什么时候使用 knitr 的缓存（例如，设置块选项 cache = TRUE），什么时候在 knitr 源文档中使用 xfun::cache_rds()呢？后者最大的缺点是它不缓存副产物（而只缓存表达式的值），而 knitr 却可以。有的时候，一些副产物是有用的，比如打印的输出或图像。例如，在下面的代码中，当使用 cache_rds() 加载缓存时，文本输出和图像将会丢失，只会返回 1:10： xfun::cache_rds({ print(&quot;Hello world!&quot;) plot(cars) 1:10 }) 相比之下，对于设定选项为 cache = TRUE 的代码块，所有的内容都将被缓存： ```{r, cache=TRUE} print(&quot;Hello world!&quot;) plot(cars) 1:10 ``` 但 knitr 的缓存最大的缺点是缓存可能会在不经意间失效，因为影响 knitr 判断是否应该重新计算的因素很多。例如，任何代码块块选项的改变都会使缓存失效32，但有些块选项可能与计算无关。例如在下面的代码块中，改变块选项 fig.width = 6 到 fig.width = 10 不会影响结果，因为该代码块并不涉及生成图片，但在 knitr 眼中这个代码块的缓存已经过期了，需要重新运行。 ```{r, cache=TRUE, fig.width=6} # 这个块没有生成图像 x &lt;- rnorm(1000) mean(x) ``` 另外一个对比是，xfun::cache_rds() 是缓存计算结果的通用方法，它可以在任何地方使用，而 knitr 的缓存只能在 knitr 文档中使用。 6.6 其它使用 knitr 的小技巧 (*) 除了块选项（第 6.2 节）和输出钩子（第 6.4 节）之外，在 knitr 中还有很多有用的函数和技巧。本节将介绍这些技巧，例如重复使用代码块（第 6.6.1 节）、提前退出编译（第 6.6.3 节）、生成一个图像并在其他地方显示（第 6.6.4 节）等等。 6.6.1 重复使用代码块 有的时候，使用者需要在源文档中重复使用某些代码块，例如在详细讲解某一段代码、重复生成一些数据或者需要在附录中呈现所有代码时。这当然可以通过复制粘贴实现，但通常会很麻烦，甚至会在改一段代码时忘记修改对应的另一段代码。实际上，还有更简便的方法实现重复使用代码块的功能，这其中的关键点在于标记代码块，从而在其它地方用标签的形式引用它们。本节将介绍三种重复使用代码块的方法。 6.6.1.1 嵌入代码块 (*) R Markdown 支持在 R 函数中使用 &lt;&lt; label &gt;&gt; 作为占位符，随后以 label 为标签的代码块中的内容会被嵌入该函数中。例如，可以这样创建一个 R 函数： F2C &lt;- function(x) { &lt;&lt;check-arg&gt;&gt; &lt;&lt;convert&gt;&gt; } 随后，分别用两个标签为 check-arg 和 convert 的代码块实现 F2C 函数的功能： 首先，检查输入值是否为数字： ```{r, check-arg, eval=FALSE} if (!is.numeric(x)) stop(&quot;The input must be numeric!&quot;) ``` 然后进行转换： ```{r, convert, eval=FALSE} (x - 32) * 5/ 9 ``` 编译时，knitr 将自动将 &lt;&lt;check-arg&gt;&gt; 和 &lt;&lt;convert&gt;&gt; 扩展为 check-arg 和 convert 两个代码块的内容，生成： F2C &lt;- function(x) { if (!is.numeric(x)) stop(&quot;The input must be numeric!&quot;) (x - 32) * 5/ 9 } 这是唐纳德·克努特（Donald Knuth）提出的文学编程中的主要思想之一。这种技术的优点在于，使用者可以将（复杂的）代码分割成更小的部分，将每个部分写入单独的代码块中，并使用文字叙述来解释它们。所有的部分都可以被放入要执行的主代码块中。 一个代码块中可以嵌入任意数量的其他代码块，并且嵌入也可以是递归的。例如，可以将块 A 嵌入到块 B 中，将块 B 嵌入到块 C 中，这样块 C 将借由块 B 包含块 A 中的代码。 另外，标记符 &lt;&lt;label&gt;&gt; 不必单独写成一行，它可以嵌入到代码块的任何地方。 6.6.1.2 在另一个块中使用相同的块标签 如果想要重复多次使用完全相同的代码块，则可以用一个标签来定义块，并使用相同的标签创建更多的代码块，但需要保留块的内容为空，例如： 下面是一个没有被运行的代码块： ```{r, chunk-one, eval=FALSE} 1 + 1 2 + 2 ``` 现在运行该代码块： ```{r, chunk-one, eval=TRUE} ``` 上面的例子使用了两次块标签 chunk-one，第二个块只是重复使用了第一个块的代码。 但是最好不要多次（多于一次）使用此方法多次运行代码块来生成图像或其他文件，因为从后面的块创建的图像文件可能会覆盖前一个块创建的文件。如果只有一个块使用块选项 eval = TRUE，而所有其他块使用 eval = FALSE 的话是可以的。 6.6.1.3 引用代码块标签 (*) 除了块之间的嵌入以及使用块标签外，还可以通过引用标签的方法来重复使用代码块。该方法的核心在于块选项 ref.label，该选项利用一个由块标签组成的向量来检索这些块的内容。例如在下例中，标签为 chunk-a 的代码块是 chunk-c 和 chunk-b 的组合： ```{r chunk-a, ref.label=c(&#39;chunk-c&#39;, &#39;chunk-b&#39;)} ``` ```{r chunk-b} # 这是块 b 1 + 1 ``` ```{r chunk-c} # 这是块 c 2 + 2 ``` chunk-a 的内容在编译时被替换为： ```{r chunk-a} # 这是块 c 2 + 2 # 这是块 b 1 + 1 ``` ref.label 提供了一种在文档中灵活组织代码块的方法，而无需复制粘贴。需要注意的是，被引用的代码块在使用 ref.label 的代码块之前还是之后并不重要，文档中出现在前的代码块同样引用后面的代码块。 6.6.2 在创建对象之前使用它 (*) 一个 knitr 文档中的所有代码，包括代码块和行内 R 表达式中的代码，从开始到结束都是按先后顺序执行的。从理论上讲，在给变量赋值之前不能使用它。但是，在某些情况下，使用者可能需要在文档前面提到一个变量的值。例如，通常在文章的摘要中需要显示结果，但结果实际上是在文档的后面计算的。下面的例子说明了这个想法，但无法编译： --- 题目：一个重要的报告 摘要： &gt; 在本文的分析中，`x` 的平均值是 `r knitr::inline_expr(&#39;mx&#39;)`... --- 在下面的块中创建对象 `mx`： ```{r} x &lt;- 1:100 mx &lt;- mean(x) ``` 要解决这个问题，对象的值必须先保存在某个地方，并在下一次编译文档时加载。需要注意的是，这一操作意味着文档至少需要被编译两次。下面的例子介绍了一种可能的解决方案，即使用 saveRDS() 函数： ```{r, include=FALSE} mx &lt;- if (file.exists(&#39;mean.rds&#39;)) { readRDS(&#39;mean.rds&#39;) } else { &quot;The value of `mx` is not available yet&quot; } ``` --- 题目：一个重要的报告 摘要： &gt; 在本文的分析中，`x` 的平均值是 `r knitr::inline_expr(&#39;mx&#39;)`... --- 在下面的块中创建对象 `mx`： ```{r} x &lt;- 1:100 mx &lt;- mean(x) saveRDS(mx, &#39;mean.rds&#39;) ``` 第一次编译本文档时，将会在摘要中看到短语 “The value of mx is not available yet”。之后当再次编译它时，将会看到 mx 的值。 函数 knitr::load_cache() 是一个替代的解决方案，它允许在特定的代码块已经被缓存了之后从该代码块加载对象的值。这个想法与上面的例子类似，但它将减少手动保存和加载对象的工作，因为对象会自动保存到缓存数据库，只需要通过 load_cache() 加载它即可，例如： --- 题目：一个重要的报告 摘要： &gt; 在本文的分析中，`x` 的平均值是 `r knitr::inline_expr(&quot;knitr::load_cache(&#39;mean-x&#39;, &#39;mx&#39;)&quot;)`. --- 在下面的块中创建对象 `mx`： ```{r mean-x, cache=TRUE} x &lt;- 1:100 mx &lt;- mean(x) ``` 这个例子中，R 代码块被添加了一个块标签 mean-x（被传递给 load_cache() 函数），并通过块选项 cache = TRUE 来缓存它。此代码块中的所有对象都将被保存到缓存数据库中。同样的，必须至少编译该文档两次，这样才能正确地从缓存数据库加载对象 mx。如果 mx 的值今后不会被更改，则不需要再次编译该文档。 如果在 load_cache() 的第二个参数中没有指定对象名，整个缓存数据库都将被加载到当前环境中。然后，可以从缓存数据库中调用这些本应在后续的文档中被创建的对象，例如： knitr::load_cache(&#39;mean-x&#39;) x # 对象 `x` mx # 对象 `mx` 6.6.3 提前退出编译 有的时候，使用者可能需要提前退出编译，而不是在文档的末尾退出。例如，可能只希望分享结果的前半部分，或者可能文档末尾的一些代码尚未完成。在这些情况下，可以考虑在一个代码块中使用 knit_exit() 函数，它将在该代码块之后结束编译过程。 下面的例子先给出了一个非常简单的块，并紧跟着有一个更耗时的块： ```{r} 1 + 1 knitr::knit_exit() ``` 在输出中将只会看到上面的内容。 ```{r} Sys.sleep(100) ``` 一般情况下，需要等待 100 秒来编译整个文档，但由于调用了 knit_exit()，文档的剩余部分将不会被编译。 6.6.4 控制图像显示位置 通常情况下，由代码块中生成的图像会显示在代码块下面，但也可以让它显示在任意位置，例如： 在这个代码块中生成了一个图像，但是没有显示出来： ```{r cars-plot, dev=&#39;png&#39;, fig.show=&#39;hide&#39;} plot(cars) ``` 随后，作者可以在文档的任意后续部分引用该图像： ![一张好看的图](`r knitr::inline_expr(&quot;knitr::fig_chunk(&#39;cars-plot&#39;, &#39;png&#39;)&quot;)`) 上述代码块使用了块选项 fig.show='hide' 来把图像暂时隐藏起来。然后在另一段中，通过函数 knitr::fig_chunk() 得到该文件的路径，例如 test_files/figure-html/cars-plot-1.png。使用者需要将块标签和图像设备名称传递给 fig_chunk()，以便它更好地得到图像文件路径。 https://stackoverflow.com/a/46305297/559676 介绍了 fig_chunk() 在 blogdown 网站中的应用。这个函数适用于任何 R Markdown 的输出格式，并且它对于在幻灯片上显示图像特别有用，因为幻灯片页上的屏幕空间通常是有限的，可以在一张幻灯片上展示代码，然后在另一张幻灯片上展示图像。 6.6.5 修改之前代码块中的图像 默认设置下，对每个代码块生成的图像，knitr 都会启用一个新的图像设备。这就带来了一个问题：不能轻易地修改之前代码块产生的图像，因为之前的图像设备已经关闭了。这个问题对于 base R 生成的图形最为显著，但一般不会影响从基于 grid 网格系统生成的图像 (例如 ggplot2)，因为其可以被保存为 R 对象。例如，base R 作图常涉及先创建一个基础图形，随后用 points() 和 lines() 等函数在基础图形上叠加图形元素。但是这些函数在 knitr 中无法访问到先前已经被关闭的图像设备。一个解决办法是让 knitr 保持打开同一个图像设备，可以在设置 knitr 选项 global.device `： knitr::opts_knit$set(global.device = TRUE) 需要注意的是，这里使用的是 opts_knit 而非更常用的 opts_chunk。相关例子可参见 https://stackoverflow.com/q/17502050。下面是一个完整的例子： --- title: &quot;使用全局图像设备记录图像&quot; --- 首先，开启全局图像设备： ```{r, include=FALSE} knitr::opts_knit$set(global.device = TRUE) ``` 画一张图： ```{r} par(mar = c(4, 4, 0.1, 0.1)) plot(cars) ``` 给之前代码块生成的图添加一条线： ```{r} fit &lt;- lm(dist ~ speed, data = cars) abline(fit) ``` 不再使用全局图像设备了： ```{r, include=FALSE} knitr::opts_knit$set(global.device = FALSE) ``` 画另一张图： ```{r} plot(pressure, type = &#39;b&#39;) ``` 6.6.6 复用块选项 (*) 使用者有时需要经常使用一些块选项，例如对一些图像的设置、对一些结果输出方式的设置。这当然可以通过复制粘贴实现，但不妨把它们保存为一个组，然后只使用组的名称来重复使用它们。这可以通过 knitr::opts_template$set(name = list(options)) 来实现，之后可以使用 opts.label 来引用组名，从而实现重复使用。例如： ```{r, setup, include=FALSE} knitr::opts_template$set(fullwidth = list( fig.width = 10, fig.height = 6, fig.retina = 2, out.width = &#39;100%&#39; )) ``` ```{r, opts.label=&#39;fullwidth&#39;} plot(cars) ``` 在设定 opts.label = 'fullwidth' 时， knitr 将从 knitr::opts_template 中读取块选项，并将它们应用到当前的块中，这样可以节省一些打字的工作量。如果一个块选项要在文档中全局使用，则应该考虑全局地设置它（参见第 6.2 节）。 另外，还可以覆盖从 opts.label 中读取的选项，例如，如果在下面的块中设置 fig.height = 7，则实际的 fig.height 将变为 7 而非 6，从而可以对单个块进行调整： ```{r, opts.label=&#39;fullwidth&#39;, fig.height=7} plot(cars) ``` 事实上，可以保存任意数量的分组选项，例如 knitr::opts_template$set(group1 = list(...), group2 = list(...))。 6.6.7 使用 knitr::knit_expand() 来生成 Rmd 源代码 函数 knitr::knit_expand()可以将 {{ }} 中的表达式“扩展”为它的值（默认），例如， knitr::knit_expand(text = &quot;`pi` 的值是 {{pi}}.&quot;) ## [1] &quot;`pi` 的值是 3.14159265358979.&quot; knitr::knit_expand( text = &quot;`a` 的值是 {{a}}, 所以 `a + 1` 是 {{a+1}}.&quot;, a = round(rnorm(1), 4) ) ## [1] &quot;`a` 的值是 -0.7558, 所以 `a + 1` 是 0.2442.&quot; 这意味着，如果有一个 R Markdown 文档，其中包含了 {{ }} 中的一些动态部分，那么可以在该文档上应用 knit_expand()，然后调用 knit() 来编译它。例如，下面是一个名为 template.Rmd 的模板文档： # 在 {{i}} 上进行回归 ```{r lm-{{i}}} lm(mpg ~ {{i}}, data = mtcars) ``` 可以用 mpg 来对 mtcars 数据集中的所有其他变量逐个建立线性回归模型： ```{r, echo=FALSE, results=&#39;asis&#39;} src = lapply(setdiff(names(mtcars), &#39;mpg&#39;), function(i) { knitr::knit_expand(&#39;template.Rmd&#39;) }) res = knitr::knit_child(text = unlist(src), quiet = TRUE) cat(res, sep = &#39;\\n&#39;) ``` 如果理解这个例子有难度，可参阅第 6.2.3.4 节，以了解块选项 results = 'asis'，以及第 7.1.4 节来了解 knitr::knit_child() 的用法。 6.6.8 重复代码块标签 (*) 默认情况下，knitr 不允许在文档中重复代码块标签。在编译文档时，重复的标签将导致错误。这种情况常见于在文档中复制和粘贴代码块的时候，会产生这样的错误信息： processing file: myfile.Rmd Error in parse_block(g[-1], g[1], params.src, markdown_mode) : Duplicate chunk label &#39;cars&#39; Calls: &lt;Anonymous&gt; ... process_file -&gt; split_file -&gt; lapply -&gt; FUN -&gt; parse_block Execution halted 然而，在某些情况下，使用者会希望允许标签可以重复。例如，如果有一个母文档 parent.Rmd，在其中会多次编译子文档，下面的代码会运行失败： # 设置 settings = list(...) # 第一次运行 knit_child(&#39;useful_analysis.Rmd&#39;) # 重新设置 settings = list(...) # 再次运行 knit_child(&#39;useful_analysis.Rmd&#39;) 在这个场景中，可以通过在编译子文档之前在 R 中设置这个全局选项来允许标签可重复： options(knitr.duplicate.label = &#39;allow&#39;) 如果想在母文档而不是子文档中允许标签可重复，则必须在 knitr::knit() 被调用之前设置这个选项。一种可能的方法是在 ~/.Rprofile 中设置这个选项（更多信息可参见帮助页面 ?Rprofile）。 设置此选项时需要很谨慎，与大多数的报错一样，它们的存在是有原因的。允许重复的块可能会在图像和交叉引用方面产生静默问题（silent problem）。例如，理论上，如果两个代码块具有相同的标签，并且两个代码块都生成图像，那么它们的图像文件将互相覆盖（并不会产生错误或警告消息），因为图像的文件名是由块标签决定的。使用选项 knitr.duplicate.label = \"allow\" 时， knitr 将通过添加数字后缀来静默地改变重复标签。例如，对于两个代码块： ```{r, test} plot(1:10) ``` ```{r, test} plot(10:1) ``` 第二个标签将被静默地更改为 test-1，这将避免覆盖由标签 test 的块产生的图像，但这也使得块标签不可被预知，所以在交叉引用图像时可能会产生困难（参见 2.8.7 节），因为交叉引用也是基于块标签的。 参考文献 "],["rmarkdown-project.html", "第 7 章 使用 R Markdown 开展项目工作 7.1 使用 R Markdown 在工作中管理项目 7.2 使用 R Markdown 实现工作流", " 第 7 章 使用 R Markdown 开展项目工作 7.1 使用 R Markdown 在工作中管理项目 处理比较大的项目或报告时，将所有的文本和代码都放在一个 R Markdown 文档中可能会导致单个文档过大，不便于查找或者阅读。更好的方式是把它们组织成更小的单元。本节将介绍一些方法，来帮助使用者更好地组织与 R Markdown 相关的多个文件。 7.1.1 来自外部的 R 脚本 如果 R Markdown 中有大量代码，则可以考虑将一些代码放入外部 R 脚本中，并通过 source() 或 sys.source() 来运行它们，例如： ```{r, include=FALSE} source(&quot;your-script.R&quot;, local = knitr::knit_global()) # 或 sys.source(&quot;your-script.R&quot;, envir = knitr::knit_global()) ``` your-script.R 中可以包含任意的 R 代码。这里 source() 设置 local 参数为 knitr 的编译环境，即 knitr::knit_global()。这可以确保脚本中定义的对象能被所有代码块正确引用。 接下来，R Markdown 文档的任意代码块都可以使用这些脚本中创建的对象（例如，数据对象或函数）。这种方法不仅可以让 R Markdown 文档更简洁，而且可以更方便地开发和调试 R 代码。 需要注意的是，上面的例子中使用了 include = FALSE，从而只执行脚本而不显示任何输出。如果想要输出，则可以删除这个块选项，或者使用第 6.2.3.1 节中的块选项来有选择地隐藏或显示不同类型的输出。 7.1.2 将外部脚本读取到一个块中 第 7.1.1 节中用 source() 引入外部脚本的方法有一个缺点：默认情况下将无法看到脚本中的源代码。source(..., echo = TRUE) 可以在加载代码的同时将它输出到代码块里，但这样引入的代码不会有语法高亮等样式。此外，如第 7.1.1 节中提到的那样，还要记得设置 source() 的 local 参数。本节将介绍一种没有上述问题的替代方法。 代码块提供了选项 code 用于执行字符形式的代码。例如： ```{r, code=c(&#39;1 + 1&#39;, &#39;if (TRUE) plot(cars)&#39;)} ``` 上面的代码块等同于： ```{r} 1 + 1 if (TRUE) plot(cars) ``` 利用这样的机制，用户就可以为 code 提供任意脚本的内容，例如： ```{r, code=xfun::read_utf8(&#39;your-script.R&#39;)} ``` 读取多个脚本： ```{r, include=FALSE} read_files &lt;- function(files) { unlist(lapply(files, xfun::read_utf8)) } ``` ```{r, code=read_files(c(&#39;one.R&#39;, &#39;two.R&#39;))} ``` 一些其他语言的代码块也支持 code 选项，下面是一些示例。 读取 Python 脚本： ```{python, code=xfun::read_utf8(&#39;script.py&#39;)} ``` 读取 C++ 文件： ```{Rcpp, code=xfun::read_utf8(&#39;file.cpp&#39;)} ``` 更多使用其他语言的知识可参阅 第 6.3 节。 借助 code 选项，可以在任何编辑器中开发复杂的代码，并将其读到一个 R Markdown 文档的代码块中。 7.1.3 从外部脚本读取多个代码块 (*) 第 7.1.2 节介绍了一种将代码读取到单个代码块的方法。本节则将介绍一种从外部脚本中读取多个代码块的方法。该方法的关键点在于需要标记脚本中的代码，进而可以在 R Markdown 文档的代码块中使用相同的标签，所以外部脚本中的代码可以通过函数 knitr::read_chunk() 映射到代码块。若要给脚本中的代码块贴上标签，可以在 ## ---- 后面写标签，还可以在该行的末尾添加一系列破折号。一个脚本可以包含多个已被标记的代码块，例如： ## ---- test-a -------- 1 + 1 ## ---- test-b -------- if (TRUE) { plot(cars) } 假设上面脚本的文件名是 test.R。在 R Markdown 文档中，可以通过 knitr::read_chunk() 来读取它，并使用带有标签的代码块中的代码，例如： 读取外部脚本： ```{r, include=FALSE, cache=FALSE} knitr::read_chunk(&#39;test.R&#39;) ``` 现在可以使用被标记的代码，即： ```{r, test-a, echo=FALSE} ``` ```{r, test-b, fig.height=4} ``` 需要注意的是，使用 knitr::read_chunk() 时请确保调用这个函数的代码块没有被缓存（见第 6.5 节的解释）。 与第 7.1.1 节和第 7.1.2 节中引入的方法一样，该方法也为在独立环境中开发代码提供了灵活性。 7.1.4 子文档 (*) 如果觉得一个 R Markdown 文档太长，可以考虑把它分成更短的文档，并通过块选项 child 将它们设置为主文档的子文档（child document）。在 child 选项中需要以字符向量的形式给定子文档的路径，例如： ```{r, child=c(&#39;one.Rmd&#39;, &#39;two.Rmd&#39;)} ``` 因为 knitr 块选项可以从任意的 R 表达式中获取值，故 child 选项的一个应用就是有条件地包含文档。例如，如果报告中有一个附录，其中包含了特定读者（如老板）可能不感兴趣的技术细节，则可以使用一个变量来控制这个附录是否包含在报告中： 如果特定读者（如老板）阅读这份报告，则将 `BOSS_MODE` 改为 `TRUE`： ```{r, include=FALSE} BOSS_MODE &lt;- FALSE ``` 有条件地包含附录： ```{r, child=if (!BOSS_MODE) &#39;appendix.Rmd&#39;} ``` 或者如果正在写一篇关于一场尚未发生的足球比赛的新闻报道（例如德国和巴西之间的比赛），则可以根据结果包含不同的子文档，例如，child = if (winner == 'brazil') 'brazil.Rmd' else 'germany.Rmd'。然后，一旦比赛结束，就可以立即发表报告。 另一种编译子文档的方法是函数 knitr::knit_child()。使用者可以在一个 R 代码块或一个行内 R 表达式中调用这个函数，例如： ```{r, echo=FALSE, results=&#39;asis&#39;} res &lt;- knitr::knit_child(&#39;child.Rmd&#39;, quiet = TRUE) cat(res, sep = &#39;\\n&#39;) ``` 函数 knit_child() 返回已编译输出的字符向量，可以使用 cat() 和块选项 results = 'asis' 来将其写回主文档。 子文档也可以作为模板，并使用不同的参数重复调用 knit_child()。下面的例子使用 mpg 作为响应变量，而 mtcars 数据中的其他变量作为解释变量进行回归： ```{r, echo=FALSE, results=&#39;asis&#39;} res &lt;- lapply(setdiff(names(mtcars), &#39;mpg&#39;), function(x) { knitr::knit_child(text = c( &#39;## 对 `r knitr::inline_expr(&quot;x&quot;)` 跑回归&#39;, &#39;&#39;, &#39;```{r}&#39;, &#39;lm(mpg ~ ., data = mtcars[, c(&quot;mpg&quot;, x)])&#39;, &#39;```&#39;, &#39;&#39; ), envir = environment(), quiet = TRUE) }) cat(unlist(res), sep = &#39;\\n&#39;) ``` 为了使上面的示例自成一体，上例使用 knit_child() 的 text 参数而不是文件输入来传递要编译的 R Markdown 内容。当然可以将内容写入一个文件，并将路径传递给 knit_child()。例如，可以将下面的内容保存到一个名为 template.Rmd 的文件中： ## 对 `r knitr::inline_expr(&#39;x&#39;)` 跑回归 ```{r} lm(mpg ~ ., data = mtcars[, c(&quot;mpg&quot;, x)]) ``` 然后编译这个文件： res &lt;- lapply(setdiff(names(mtcars), &#39;mpg&#39;), function(x) { knitr::knit_child( &#39;template.Rmd&#39;, envir = environment(), quiet = TRUE ) }) cat(unlist(res), sep = &#39;\\n&#39;) 7.1.5 保留图像文件 大多数 R Markdown 输出格式默认使用选项 self_contained = TRUE。这将导致 R 的图像会直接被嵌入到输出文档中，所以在查看输出文档时不需要这些中间产物（图像文件）。因此，图像文件夹（通常带有后缀 _files）将在 R Markdown 文档编译完成后被删除。 然而，有的时候可能需要保留图像文件。例如，一些学术期刊要求作者单独提交数据文件。对于 R Markdown 来说，有三种方法可以避免自动删除这些文件： 如果输出格式支持，请使用选项 self_contained = FALSE，例如： output: html_document: self_contained: false 但是，这意味着图像文件不会被嵌入到输出文档中。如果不想这样，则可以考虑下面两种方法。 为至少一个代码块启用缓存（见第 6.5 节）。当启用缓存时，R Markdown 将不会删除 plot 文件夹。 如果输出格式支持，请使用选项 keep_md = TRUE，例如： output: word_document: keep_md: true 当要求 R Markdown 保存中间的 Markdown 输出文件时，它也将保存图像文件夹。 7.1.6 R 代码块的工作目录 在默认情况下，R 代码块的工作目录（working directory）是包含 R Markdown 文档的目录。例如，如果一个 R Markdown 文件的路径是 ~/Downloads/foo.Rmd，计算 R 代码块的工作目录是 ~/Downloads/。这意味着当在代码块中引用具有相对路径的外部文件时，需要知道这些路径是相对于 R Markdown 文件的目录的。例如 read.csv(\"data/iris.csv\") 在代码块中意味着读取 CSV 文件 ~/Downloads/data/iris.csv。 当有报错或其它问题时，可以将 getwd() 添加到代码块中，编译文档，并检查 getwd() 的输出。 有的时候，可能希望使用另一个目录作为工作目录。通常改变工作目录的方法是 setwd()，但是需要注意的是，setwd() 在 R Markdown（或其他类型的 knitr 源文档）中并不是持久的，即 setwd() 仅对当前代码块有效，工作目录将在此代码块计算后恢复。 如果想改变所有代码块的工作目录，则可以通过在文档开头的 setup 代码块来设置： ```{r, setup, include=FALSE} knitr::opts_knit$set(root.dir = &#39;/tmp&#39;) ``` 这将改变所有后续代码块的工作目录。 如果使用 RStudio 来编译 R Markdown，也可以从菜单 Tools -&gt; Global Options -&gt; R Markdown 中选择工作目录（见图 7.1）。默认工作目录的是 R Markdown 的目录文件，并且还有另外两个可能的选择：可以使用 R 控制台的当前工作目录（选项 Current），或者使用包含这个 R Markdown 文件的项目的根目录（选项 Project）作为工作目录。 图 7.1: 在 RStudio 中改变所有 R Markdown 文档的默认工作目录。 在 RStudio 中，也可以编译一个带有特定工作目录的独立 R Markdown 文档，如图 7.2 所示。在改变 Knit Directory 并点击 Knit 按钮后，knitr 将使用新的工作目录来编译代码块。所有这些设置都可以归结为前面提到的 knitr::opts_knit$set(root.dir = ...)，所以如果不满意上述更改工作目录方式的任何一个，也可以自己用 knitr::opts_knit$set() 指定一个目录。 图 7.2: 在 RStudio 中设置当前 R Markdown 文档的工作目录。 更改工作目录各方式的选择没有哪种绝对正确，每种选择都有其优缺点： 如果使用 R Markdown 文档目录作为代码块的工作目录（knitr 的默认值），则需假定文件路径是相对于 R Markdown 文档的。这类似于 web 浏览器如何处理相对路径，例如，对于在 HTML 页面 https://www.example.org/path/to/page.html的一个图像 &lt;img src=\"foo/bar.png\" /&gt;，web 浏览器将尝试从 https://www.example.org/path/to/foo/bar.png 获取图像。换句话说，相对路径 foo/bar.png 是相对于 HTML 文件的目录，即 https://www.example.org/path/to/。 这种方法的优点是，可以自由地将 R Markdown 文件与其引用的文件一起移动到任何地方，只要它们的相对位置保持不变。对于上面的 HTML 页面和图像示例，文件 page.html 和 foo/bar.png 可以一起移动到不同的目录，如 https://www.example.org/another/path/，使用者将不需要更新 &lt;img /&gt; 的 src 属性中的相对路径。 一些用户喜欢将 R Markdown 文档中的相对路径看作是“相对于 R 控制台的工作目录”，而不是“相对于 R Markdown 文件”。因此，knitr 的默认工作目录让人感到困惑。事实上，当设计者在设计 knitr 时，没有使用 R 控制台的工作目录作为默认目录的原因是，用户可以使用 setwd() 随时更改工作目录。这个工作目录不能保证是稳定的。每当用户在控制台中调用 setwd() 时，就存在 R Markdown 文档中的文件路径可能失效的风险，因为这在 R Markdown 文件的控制之外。当考虑相对路径时，如果将 R Markdown 文件视为“宇宙的中心”，那么 R Markdown 文件中的路径可能更稳定。 此外，如果不想过多地考虑相对路径，则可以使用 RStudio 的自动填充功能在 RStudio 中输入一个路径，如图 7.3 所示。RStudio 将尝试自动完成一个相对于 R Markdown 文件的路径。 使用 R 控制台的工作目录可以是一个很好的选择，可以以编程方式或交互式方式编译文档。例如，可以在循环中多次编译一个文档，并每次使用不同的工作目录来读取该目录中的不同数据文件（具有相同的文件名）。这种类型的工作目录是由 ezknitr 包 (R-ezknitr?)实现的，其本质上是使用 knitr::opts_knit$set(root.dir) 来改变 knitr 中的代码块的工作目录。 使用项目目录作为工作目录需要一个明显的假设：首先必须使用一个项目（例如，RStudio 项目或版本控制项目），这可能是这种方法的一个缺点。这种类型的工作目录的优点是，任何 R Markdown 文档中的所有相对路径都是相对于项目根目录的，因此不需要考虑 R Markdown 文件在项目中的位置，也不需要相应地调整其他文件的相对路径。这种类型的工作目录是由 here (Müller 2020)实现的，它提供了函数 here::here()，通过解析传递给它的相对路径来返回绝对路径（需要注意的是，相对路径是相对于项目根的）。然而，该方法的缺点是，当引用的文件和 R Markdown 文件一起移动到项目中的另一个位置时，需要更新 R Markdown 文档中的引用路径。当与其他人共享 R Markdown 文件时，也必须共享整个项目。 这些类型的路径类似于 HTML 中没有协议（protocol）或域（domain）的绝对路径。例如，https://www.example.org/path/to/page.html 页面上的 &lt;img src=\"/foo/bar.png\" /&gt; 图像是指网站根目录下的图像，即 https://www.example.org/foo/bar.png。图像 src 属性中的 / 表示网站的根目录。如果想了解更多关于 HTML 中绝对路径和相对路径的知识，请参阅附录 B.1 – blogdown 书 (blogdown2017?)。 工作目录之苦主要来自于处理相对路径时的这个问题： _相对于什么？_正如之前提到的，不同的人有不同的偏好，没有绝对正确的答案。 图 7.3: 在 RStudio 中自动填充 Rmd 文档中的文件路径。 7.2 使用 R Markdown 实现工作流 本节将介绍一些处理 R Markdown 文档以及运行 R Markdown 项目的技巧。在学习完本节后，可以对上述工作有初步的了解，想要更详细地了解也可以查看 R for Data Science 的第三十章 “R Markdown workflow”(H. Wickham and Grolemund 2017)，该书简要介绍了一些使用分析笔记本的技巧（包括 R Markdown 文档）。Nicholas Tierney 在书R Markdown for Scientists 中也讨论了工作流。 7.2.1 使用 RStudio 键盘快捷键 R Markdown 格式可以与任何编辑器一起使用，只要安装了 R、rmarkdown 包以及 Pandoc。然而，RStudio 与 R Markdown 深度集成，所以可以在 RStudio 中利用 R Markdown 顺利地开展工作。 与任何 IDE（集成开发环境，Integrated Development Environment）一样，RStudio 也有键盘快捷键。完整的列表可以在菜单 Tools -&gt; Keyboard Shortcuts Help 下找到。一些与 R Markdown 相关的最有用的快捷方式总结可见表 7.1。 表 7.1: 与R Markdown相关的RStudio键盘快捷键。 任务 Windows &amp; Linux macOS 插入 R 块 Ctrl+Alt+I Command+Option+I HTML预览 Ctrl+Shift+K Command+Shift+K 编译文档（knitr） Ctrl+Shift+K Command+Shift+K 编译Notebook Ctrl+Shift+K Command+Shift+K 编译PDF Ctrl+Shift+K Command+Shift+K 运行上面的所有块、 Ctrl+Alt+P Command+Option+P 运行当前的块 Ctrl+Alt+C Command+Option+C 运行当前的块 Ctrl+Shift+Enter Command+Shift+Enter 运行下一个块 Ctrl+Alt+N Command+Option+N 运行所有的块 Ctrl+Alt+R Command+Option+R 转到下一个块/标题 Ctrl+PgDown Command+PgDown 转到上一个块/标题 Ctrl+PgUp Command+PgUp 显示/隐藏文档大纲 Ctrl+Shift+O Command+Shift+O Build书、网站… Ctrl+Shift+B Command+Shift+B 此外，还可以通过 Ctrl + Alt + F10（或 macOS 中的Command + Option + F10）来重新启动 R 会话。定期重新启动有助于保证结果的再现性，因为如果结果是从一个新的 R 会话计算出来的，那么其更有可能再现。这也可以通过工具栏上 Run 按钮后面的下拉菜单 Restart R and Run All Chunks 来完成。 7.2.2 R Markdown 的拼写检查 如果使用 RStudio IDE，可以按 F7 键或点击菜单 Edit -&gt; Check Spelling 对 R Markdown 文档进行拼写检查。实时拼写检查在 RStudio v1.3 中已经可以使用了，所以在这个版本或更高版本的 RStudio 中，不再需要手动触发拼写检查。 如果不使用 RStudio，则 spelling 包 (R-spelling?)提供一个函数 spell_check_files()，可以检查常见文档格式的拼写，包括 R Markdown。当拼写检查 R Markdown 文档时，它将跳过代码块，只检查普通文本。 7.2.3 用 rmarkdown::render() 呈现 R Markdown 如果不使用 RStudio 或任何其他 IDE，则需要知道一个事实：R Markdown 文档是通过函数 rmarkdown::render() 来呈现的。这意味着可以在任何 R 脚本中以编程方式呈现 R Markdown 文档。例如，可以在 for 循环中为一个国家的每个城市呈现一系列报告： for (city in city.name) { rmarkdown::render( &#39;input.Rmd&#39;, output_file = paste0(city, &#39;.html&#39;) ) } 这样的话，每个城市的输出文件名是不同的。还可以在文档 input.Rmd 中使用 city 变量，例如： --- title: &quot;`r knitr::inline_expr(&#39;city&#39;)` 的一个报告&quot; output: html_document --- `r knitr::inline_expr(&#39;city&#39;)` 的面积是 `r knitr::inline_expr(&#39;city.area[city.name == city]&#39;)` 平方公里。 可以阅读帮助页面 ?rmarkdown::render 以了解其他可能的参数。这里本节只提到其中两个关键的参数：clean 和 envir 参数。 当 Pandoc 转换出现任何问题时，clean 参数将特别有助于调试。如果调用 rmarkdown::render(..., clean = FALSE) ，所有中间文件将被保留，包括编译 .Rmd 文件得到的中间文件 .md。如果 Pandoc 发出错误信号，则可以从 .md 文件开始调试。 当调用 rmarkdown::render(..., envir = new.env()) 时，envir 参数可以保证空白的新环境下呈现文档，因此在代码块中创建的对象将留在该环境中，而不会影响当前的全局环境。另一方面，如果倾向于在一个新的 R 会话中呈现 R Markdown 文档，以便当前 R 会话中的对象不会影响 R Markdown 文档，则可以在 xfun::Rscript_call() 中调用 rmarkdown::render，例如： xfun::Rscript_call( rmarkdown::render, list(input = &#39;my-file.Rmd&#39;, output_format = &#39;pdf_document&#39;) ) 这个方法类似于点击 RStudio的 Knit 按钮，它也在可以新的 R 会话中呈现 R Markdown 文档。考虑到使用者可能需要在一个 R Markdown 文档内呈现另一个 R Markdown 文档，本书强烈建议使用者使用这种方法，而不是在代码块中直接调用 rmarkdown::render()，因为 rmarkdown::render() 会产生并依赖于其内部的很多“副产物”，这可能会影响在同一个 R 会话中呈现其他的 R Markdown 文件。 xfun::Rscript_call() 的第二个参数接受传递给 rmarkdown::render() 的参数列表。事实上，xfun::Rscript_call 是一个通用的函数，用于在新的 R 会话中调用任何 R 函数。感兴趣者可以查看它的帮助页面。 7.2.4 参数化的报告 第 7.2.3 节提到了一种在 for 循环中呈现一系列报告的方法。实际上，rmarkdown::render() 有一个叫 params 的参数，是专门为这个任务设计的。使用者可以通过这个参数来参数化其产生的报告。当为报表指定参数时，可以在报表中使用变量 params。例如，如果调用： for (city in city.name) { rmarkdown::render(&#39;input.Rmd&#39;, params = list(city = city)) } 那么在 input.Rmd 中，params 对象会是一个包含 city 变量的列表： --- title: &quot;`r knitr::inline_expr(&#39;params$city&#39;)` 的一个报告&quot; output: html_document --- `r knitr::inline_expr(&#39;params$city&#39;)` 的面积是 `r knitr::inline_expr(&#39;city.area[city.name == params$city]&#39;)` 平方公里。 另一种为报告指定参数的方法是使用 YAML 字段 params，例如： --- title: 参数化的报告 output: html_document params: city: Beijing year: 2022 --- 需要注意的是，使用者可以在 YAML 字段 params 或 rmarkdown::render() 的参数 params 中包含尽可能多的参数。如果 YAML 字段 params 和参数 params 同时存在，则参数 params 中的参数值将覆盖 YAML 字段 params 中相应的参数。例如，当在前面有 YAML 字段 params 的例子中调用 rmarkdown::render(..., params = list(city = 'Shanghai', year = 2020)，则在 R Markdown 文档中，params$city 将变成 Shanghai（而不是Beijing）， params$year 将变成2020（而不是2022） 当用相同的 R Markdown 文档呈现一系列报告时，需要调整 rmarkdown::render() 的 output_file 参数，以确保每个报告都有其唯一的文件名。否则，可能将意外地覆盖某些报告文件。例如，可以编写一个函数来生成每个城市每年的报告： render_one &lt;- function(city, year) { # 假设 input.Rmd 的输出格式是 PDF rmarkdown::render( &#39;input.Rmd&#39;, output_file = paste0(city, &#39;-&#39;, year, &#39;.pdf&#39;), params = list(city = city, year = year), envir = parent.frame() ) } 之后可以使用嵌套的 for 循环来生成所有的报告： for (city in city.name) { for (year in 2000:2022) { render_one(city, year) } } 最后，可以得到一系列的报告文件，如Beijing-2000.pdf，Beijing-2001.pdf，…，Shanghai-2021.pdf，以及Shanghai-2022.pdf。 对于参数化的报告，还可以通过一个由 Shiny 创建的图形用户界面（Graphical User Interface，GUI）来交互式地输入参数。这需要在 YAML 中提供一个 params 字段，rmarkdown 将为每个参数使用适当的输入部件自动创建 GUI，例如，将为布尔（Boolean）参数提供一个复选框。 如果不使用 RStudio，也可以用 params = 'ask' 调用 rmarkdown::render() 来启动 GUI： rmarkdown::render(&#39;input.Rmd&#39;, params = &#39;ask&#39;) 如果使用 RStudio，则可以点击 Knit 按钮后面的菜单 Knit with Parameters。图 7.4 展示了一个参数的 GUI 示例。 图 7.4: 使用者可以从 GUI 输入的参数编译一个 R Markdown 文档。 有关参数化报告的更多信息，请阅读 R Markdown Definitive Guide 的第十五章 “Parameterized reports”(Xie, Allaire, and Grolemund 2018a)。 7.2.5 自定义 Knit 按钮 (*) 当点击 RStudio 的 Knit 按钮时，它将在一个新的 R 会话中调用 rmarkdown::render() 函数，并输出一个与输入文件的基本名相同的文件。例如，编译输出格式为 html_document 的 example.Rmd ，将得到一个输出文件 example.html。 在某些情况下，使用者可能需要自定义文档的呈现方式。例如，可能希望呈现的文档包含当前日期，或者希望将编译后的报告输出到不同的目录中。尽管可以通过使用适当的 output_file 参数调用 rmarkdown::render()（请参阅第 7.2.3 节）来实现这些目标，但依赖自定义调用 rmarkdown::render() 来编译报告可能会很不方便。 另外，可以通过在文档的 YAML frontmatter 中提供 knit 字段来控制 Knit 按钮的行为。该字段接受一个主参数为 input（输入 R Markdown 文档的路径）和其他当前被忽略的参数的函数。使用者可以直接在 knit 字段中编写函数的源代码，也可以把函数放在其他地方（例如，在 R 包中），然后在 knit 字段中调用函数。如果经常需要自定义的 knit功能，则建议把它放在一个包中，而不是在每个 R Markdown 文档中都重复它的源代码。 如果直接将代码存储在 YAML 中，则必须将整个函数包装在括号中。如果源代码有多行，则必须缩进所有行（第一行除外）至少两个空格。例如，如果想要输出文件名包含它呈现的日期，可以使用如下的 YAML 代码： --- knit: (function(input, ...) { rmarkdown::render( input, output_file = paste0( xfun::sans_ext(input), &#39;-&#39;, Sys.Date(), &#39;.html&#39; ), envir = globalenv() ) }) --- 例如，如果在 2022-02-08 编译 example.Rmd，则输出的文件名将为 example-2022-02-08.html。 虽然上面的方法看起来足够简单和直接，但直接在 YAML 中嵌入函数可能会使维护它变得困难，除非该函数只在单个 R Markdown 文档中使用一次。一般而言，建议使用 R 包来维护这样的函数，例如，可以在包中创建一个函数 knit_with_date()： #&#39; 为 RStudio 自定义编译功能 #&#39; #&#39; @export knit_with_date &lt;- function(input, ...) { rmarkdown::render( input, output_file = paste0( xfun::sans_ext(input), &#39;-&#39;, Sys.Date(), &#39;.&#39;, xfun::file_ext(input) ), envir = globalenv() ) } 如果将上面的代码添加到一个名为 myPackage 的包中，则将能够使用以下 YAML 设置来引用自定义的 knit 函数： --- knit: myPackage::knit_with_date --- 可以参考帮助页面 ?rmarkdown::render 来找到更多关于如何在 RStudio 中自定义 Knit 按钮后 knit 函数的方法。 7.2.6 通过 Google Drive 对 Rmd 文档进行协作 基于 googledrive 包 (R-googledrive?)， Emily Kothe 在 rmdrive 包 中提供了一些包装函数，该包目前只能从 GitHub上获得（https://github.com/ekothe/rmdrive）。在撰写本书时，它仍然缺乏丰富的文档，所以建议尝试 Janosch Linkersdörfer 的分支：https://github.com/januz/rmdrive，该分支基于 Ben Marwick 的分支（对于尚未学会 Git 的读者，可能会被这些自由分支和改进其他人 Git 库的例子所激励）。 使用 rmdrive 进行工作的流程可被概述如下： 假设有一个项目的主要作者或贡献者，他能够使用像 Git 这样的版本控制工具。主要作者编写 R Markdown 文档的初始版本，并通过 upload_rmd() 函数将其上传到 Google Drive； Google Drive 中的 R Markdown 文档可以与其他合作者共享，他们可以对 Google Document 进行更改或提出更改建议； 主要作者可以接受建议的修改，并通过 render_rmd() 在本地下载或预览 R Markdown 文档。如果其他合作者有修改过的代码块，并且希望看到新的结果，他们也可以自己完成这项工作； 如果满意，主作者可以将更改提交到 Git 存储库。 在 Google Drive 中，协作编辑可以是同步的，也可以是异步的。多人可以同时编辑同一文档，也可以等待其他人先完成编辑。 包中还有一个 udpate_rmd() 函数，它允许在本地编辑 R Markdown 文档，并将本地 R Markdown 文档上传到 Google Drive。事实上，使用者可能永远都不应该运行这个函数，因为它将完全覆盖 Google Drive 中的文档。主要作者需要提前警告合作者。理想情况下，所有协作者应该只在 Google Drive 中编辑文档，而不是在本地。可以通过 render_rmd() 在本地预览编辑的文档，不过需要注意的是，render_rmd() 会在呈现之前自动下载文档。 7.2.7 用 workflowr 将 R Markdown 项目组织到一个研究网站上 为了更好地完成 R Markdown 项目，有的时候使用者会想将其组织到一个网站上。workflowr 包 (R-workflowr?; workflowr2019?)可以帮助使用者用项目模板和版本控制工具 Git 组织一个（数据分析）的项目。每次对项目做出更改时，可以记录更改，workflowr 可以建立一个与项目的特定版本相对应的网站。这意味着将能够查看分析结果的完整历史记录。尽管这个包使用 Git 作为版本控制的后端，但其实并不需要真正熟悉 Git。这个包提供了 R 函数，这些函数在底层执行 Git 操作，所以只需要调用这些 R 函数即可。此外，workflowr 自动化了可重复性代码的最优方法。每次 R Markdown 文档被呈现时，workflowr 会自动使用 set.seed() 设置一个种子，使用 sessionInfo() 记录会话信息，并扫描绝对文件路径等。请参阅 workflowr 包的文档来了解如何开始并获取更多信息。 workflowr 的主要作者 John Blischak 也整理了一个与 R 项目工作流相关的 R 包和指南的非详尽列表，可见 GitHub 仓库： https://github.com/jdblischak/r-project-workflows。 7.2.8 使用 GitHub Actions 实现自动化部署 使用 R Markdown 输出特定的文件格式后，一个自然的问题是如何与他人共享结果，一些使用场景包括在公司内部发布数据分析报告，发表 blogdown 博客，更新 bookdown 电子书籍等。最直接的做法是在本地执行编译，随后分享输出文件。例如执行在控制台 rmarkdown::render() 函数后，上传更新后的 HTML 文件到网络服务器上，或者在 Github 中上传 Markdown 文件。本地手动编译不仅需要重复的人力劳动，如果输出结果依赖于特定的系统环境，也难以保证结果的可重复性。为了使部署过程更高效可靠，包括 Github Actions, Gitlab Pipeline 等在内的持续集成 (continuous integration) 工具被广泛应用在 R Markdown 工作流的自动化部署中。本节以 Github 平台的 Github Actions 为例讲解 R Markdown 的自动化部署方法。 尽管 Github Actions 持续集成工具的用途非常广泛，具体在 R Markdown 的语境内，读者可以把它想象为一系列执行 R Markdown 编译的指令，可以是终端的 shell 命令，也可以调用 R 语言或任意工具的命令行接口。用户可以自行定义这些指令的触发条件，例如每周一上午十点运行一次，或每次 Github 仓库有新的代码提交时运行。当这些条件被触发时，Github 会创建一个专属的虚拟环境运行定义好的代码，其中便可以包括用于发布 R Markdown 输出文档的命令。 新建任意项目目录，在其中创建 index.Rmd 文件，包含如下内容: --- title: &quot;用 Github Actions 实现自动化部署&quot; author: &quot;张三&quot; date: &quot;`r Sys.Date()`&quot; output: prettydoc::html_pretty: theme: leonids highlight: github --- ## 数据概览 `r Sys.Date()` 日各地区销售情况 ```{r} day &lt;- as.integer(format(Sys.Date(), &quot;%d&quot;)) sales_dat &lt;- data.frame( region = rep(LETTERS, each = 10), sales = rpois(26 * 10, day) ) knitr::kable(head(sales_dat, 20)) ``` ## 描述性分析 本日销售量最多对前 10 个地区为： ```{r} sales_sum &lt;- aggregate(sales ~ region, data = sales_dat, sum) top_10_regions &lt;- head(sales_sum[order(-sales_sum$sales), ], 10) barplot(sales ~ region, data = top_10_regions) ``` ## 线性模型 用简单线性模型探究地区对销售量对影响，公式为: $$ \\text{销售量} = \\beta_0 + \\beta_1\\text{地区 A} + \\beta_2\\text{地区 B} + \\cdots + \\beta_{26}\\text{地区 Z} $$ ```{r} mod &lt;- lm(sales ~ region, data = sales_dat) region_coefs &lt;- mod$coefficients[-1] max_idx &lt;- which.max(region_coefs) ``` 所有 `r length(unique(sales_dat$region))` 个地区中，回归系数绝对值最大的是 `r LETTERS[max_idx]`，为 `r region_coefs[max_idx]` 本地编译结果如下 (需要安装 prettydoc (Qiu 2021) 包)： 本地验证代码运行无误后，开始设置自动化部署。首先在 Github 上新建对应的仓库，在本地目录下 git init 初始化 git 并 git remote add origin &lt;url&gt; 添加该仓库。希望实现的效果为，每次更新 main 分支后，Github Actions 自动编译 index.Rmd 并更新至仓库对应的 Github Pages 网页端。 Github Actions 使用 yaml 文件定义命令，在根目录下新建 .github/workflows/deploy.yml 文件。 此时文档结构为： ├── .github │   └── workflows │   └── deploy.yml └── index.Rmd 其中，.github/workflows/ 是固定的前缀路径，Github 在此路径下搜索 yaml 文件，每个文件称为一个 workflow，不同的 workflow 通常代表自动化部署的不同任务，例如有的负责获取数据，有的负责更新网页。deploy.yml 是本案例使用的唯一 workflow 文件，名称可以自定义，其中内容为： on: push: branches: main name: Render jobs: render: name: Render index.Rmd runs-on: macOS-latest steps: - uses: actions/checkout@v2 - uses: r-lib/actions/setup-r@v2 - uses: r-lib/actions/setup-pandoc@v1 - name: Install rmarkdown run: Rscript -e &#39;install.packages(c(&quot;rmarkdown&quot;, &quot;prettydoc&quot;))&#39; - name: Render index.Rmd run: Rscript -e &#39;rmarkdown::render(&quot;index.Rmd&quot;)&#39; - name: Commit results run: | git add index.html git commit -m &#39;Re-build index.Rmd&#39; git push origin on 定义了该 workflow 的触发条件，这里为 main 分支收到新提交 (push) 时触发。它的语法通常包括动作与分支，例如 “main 和 release 分支收到 pull request 时触发” 可以表示为 on: pull_request: # 可包含多个触发分支 branches: - main - releases 。on 还支持 cron 语法，例如 # 每天 5:30 and 17:30 UTC 触发 workflow on: schedule: - cron: &#39;30 5,17 * * *&#39; name 代表 Github 网页端显示的 workflow 名称。 jobs 是 workflow 中的核心内容，代表需要执行的一系列指令，可以分为不同的子任务，该文件中包含一个 render 子任务，指定运行环境为 macOS-latest，其他可选环境包括 windows，linux 等不同版本的机型。render 中的每一项代表一组独立的指令。由于每次 workflow 触发时均运行在全新的环境中，必须重新安装项目所需的依赖项，前三个 uses 指令是 Github 社区提供的模版，分别在环境中克隆所需的仓库，安装 R 和安装 pandoc。 # 预定义模版搜索 https://github.com/marketplace?type=actions - uses: actions/checkout@v2 - uses: r-lib/actions/setup-r@v2 - uses: r-lib/actions/setup-pandoc@v1 随后，两个自定义的终端命令为 - name: Install rmarkdown run: Rscript -e &#39;install.packages(c(&quot;rmarkdown&quot;, &quot;prettydoc&quot;))&#39; - name: Render index.Rmd run: Rscript -e &#39;rmarkdown::render(&quot;index.Rmd&quot;)&#39; name 定义该步骤的 UI 名称, run 代表该步骤执行的 shell 命令，这两步安装了 rmarkdown 和 prettydoc 包，并编译 index.Rmd。Rscript 是 R 提供的命令行接口，另外一种写法是： - name: Install rmarkdown shell: Rscript {0} run: | install.packages(c(&quot;rmarkdown&quot;, &quot;prettydoc&quot;)) 最后，workflow 需要把虚拟环境中生成的输出文件同步到主仓库中。这样，每次 main 分支收到更新，Github Actions 便会重新编译 index.Rmd 文档，同步输出文件 index.html 至仓库，实现自动化编译。 # 同步输出文件至仓库 - name: Commit results run: | git add index.html git commit -m &#39;Re-build index.Rmd&#39; git push origin 案例的最后一步是启动 Github Pages 服务，该服务将自动识别仓库内的 index.html 文件，基于个人 Github 账号生成公开的网页地址。启动方法为点击仓库的 settings -&gt; pages 并选择 Source 为 main 分支下的 root 目录。 图 7.5: 为仓库启用 Github Pages，生成地址见 https://qiushiyan.github.io/rmd-ci/ 真实生产环境中，应使主文档 index.Rmd 尽可能简洁抽象，可以运用 7.1.4 节学习的子文档知识，将业务逻辑封装为函数放入子文档 functions.Rmd 中，functions.Rmd 的内容为: ```{r, include=FALSE} fetch_sales_data &lt;- function(date = Sys.Date()) { day &lt;- as.integer(format(date, &quot;%d&quot;)) sales_dat &lt;- data.frame( region = rep(LETTERS, each = 10), sales = rpois(26 * 10, day) ) sales_dat } top_n_regions &lt;- function(sales_dat, n) { sales_sum &lt;- aggregate(sales ~ region, data = sales_dat, sum) head(sales_sum[order(-sales_sum$sales), ], n) } ``` 随后在主文档 index.Rmd 中引用子文档: ```{r, child = &quot;template.Rmd&quot;, include = FALSE} ``` ```{r} sales_dat &lt;- fetch_sales_data() knitr::kable(head(sales_dat, 20)) ``` ```{r} top_10_regions &lt;- top_n_regions(sales_dat, 10) barplot(sales ~ region, data = top_10_regions) ``` 读者可以在 Github Actions 文档 学习更多语法知识，此外 rlib/actions 仓库汇集了诸多 R 社区为各项自动化任务定制的 workflow 文件，大部分情况下可以直接复制使用，或仅需要修改少量配置。 参考文献 "],["references.html", "参考文献", " 参考文献 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
