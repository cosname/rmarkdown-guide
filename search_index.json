[["index.html", "R Markdown 指南 前言", " R Markdown 指南 王祎帆 闫求识 高春辉 庄亮亮 杨晓龙 2022-05-05 前言 "],["rmarkdown-intro.html", "第 1 章 R Markdown概述 1.1 R Markdown 的渊源 1.2 以案例形式初识 R Markdown", " 第 1 章 R Markdown概述 1.1 R Markdown 的渊源 1.1.1 knitr 和 Sweave 1.1.2 标记语言和 Pandoc 转换器 1.2 以案例形式初识 R Markdown 1.2.1 数据分析报告 1.2.2 交互笔记本 1.2.3 个人简历 1.2.4 网站 1.2.5 幻灯片 1.2.6 交互报表 1.2.7 动态文档 "],["rmarkdown-base.html", "第 2 章 R Markdown 的基础知识 2.1 R Studio 相关的配置 2.2 R Markdown 的安装 2.3 R Markdown 的编译过程 2.4 R Markdown 的基本元素 2.5 页面设置和布局 2.6 R Markdown 的文档元素", " 第 2 章 R Markdown 的基础知识 2.1 R Studio 相关的配置 2.2 R Markdown 的安装 2.2.1 安装 R Markdown 2.2.2 安装 Tinytex 要想使用 R Markdown 输出 PDF 格式的文档，必须事先安装 LaTeX。LaTeX 有很多发行版，如 MiKTex，MacTeX， TeX Live 等，建议 R Markdown 的用户使用 TinyTeX。 TinyTeX 是一个瘦身版的 TeX Live，去掉了 TeX Live 中对普通用户毫无用处的源代码和文档。通过命令行模式，它的安装要简单的多。 knitr::include_graphics(&quot;images/logo-tinytex.png&quot;, dpi = NA) 图 2.1: TinyTex 是一个瘦身版的 TeX Live 要安装 TinyTeX，只需要在 R 语言终端输入两条命令即可1。 # 安装 tinytex install.packages(&quot;tinytex&quot;) # 安装 TinyTex 套件 tinytex::install_tinytex() 如果 TinyTeX 本身的下载安装就很慢，或在 R 里面下载不完整，那么可以用浏览器或其它下载工具直接下载：https://github.com/yihui/tinytex-releases/releases 然后把下载的文件路径传给安装函数，比如： # 假设下载文件所在的位置是 ~/Downloads/TinyTeX-v2021.01.zip tinytex:::install_prebuilt(&#39;~/Downloads/TinyTeX-v2021.01.zip&#39;) 安装完成后，在 RStudio 中打开之前保存的 R Markdown 源文档，将第三行 output_format: html_document 更改为 output_format: pdf_document。点击 Knit 后，生成如下两页 PDF 文档，说明安装成功。 2.2.2.1 安装 LaTeX 组件 rmarkdown 包从版本 1.9 开始，编译 R Markdown 为 PDF 时会调用 TinyTeX。因此，对 R Markdown 用户来说，编译 PDF 是出错的头号原因可能在于缺失某些 LaTeX 包。 LaTeX 包（也被称为“package”）是 LaTeX 的组件，数目非常多，可以用来扩展 LaTeX 的功能。tinytex::install_tinytex() 默认只安装了必须的一些组件，在实际使用过程中经常会出现缺少组件的错误。 如果知道包的名称，那么可以直接使用下面的命令安装。这里值得注意的是，对于国内的用户来说，通常需要设定一下 LaTeX 软件仓库的位置。下面的例子中，使用了清华大学的 TeX Live 镜像。 # 安装需要的 LaTeX 组件 tinytex::tlmgr_repo(url = &quot;https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/tlnet&quot;) tinytex::tlmgr_install(c(&#39;pgf&#39;, &#39;preview&#39;, &#39;xcolor&#39;)) 如果不知道包的名称也没有关系，tinytex 也提供了相应的函数来帮助用户从报错信息中找到解决方法。tinytex::parse_install() 提供两种方法，第一种是通过准确的错误提示，第二种是通过分析 log 文件。如果嫌 log 太长或者找不到具体提示信息，还可以使用第二种办法。 # 假如有相关报错信息 &quot;! LaTeX Error: File `preview.sty&#39; not found.&quot; tinytex::parse_install(text = &quot;! LaTeX Error: File `preview.sty&#39; not found.&quot;) # 假如错误 log 名为 tex.log tinytex::parse_install(log = &quot;tex.log&quot;) 2.2.3 安装 Git (*) Git 是一个分布式版本控制软件，最初由 Linus Torvalds 开发2，于 2005 年以 GPL 协议发布。Git 软件可以在其官方网站下载（https://git-scm.com/downloads）。为了与 Git 配合使用，通常还需要注册一个支持 Git 软件仓库托管的配套网站，比较流行网站服务包括 GitHub（https://github.com），Gitee（https://gitee.com/）等。在这里以 GitHub 为例进行说明。 图 2.2: 使用 Git 和 GitHub 可以提高团队协作的效率 2.2.3.1 配置 Git 和 GitHub 在 Windows 下面3，安装完 Git 客户端之后，鼠标右键菜单中会多出来两个命令：“Git GUI Here”和“Git Bash Here”。前者打开一个图形界面，后者打开一个终端，通过这两个命令都可以进入 Git。 首先需要配置 Git 的用户信息。 # 全局配置 $ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;xxx@xxx.xxx&quot; # 本地配置 $ git config user.name &quot;your name&quot; # 查看配置 $ git config --list # 查看指定项 $ git config user.name 为了能够使用 GitHub 提供的服务，需要先注册一个账号（https://github.com/signup）。 2.2.3.2 使用 Git Git 常用的命令有下面几个： git init sample 在当前目录新建一个“sample”目录，在目录中启用 Git 版本控制系统。 git clone https://github.com/cosname/rmarkdown-guide.git 从 GitHub 克隆一个软件仓库到当前目录。这将在当前目录新建一个“rmarkdown-guide”文件夹，其中包含所有文件和版本历史。 git status 显示当前 Git 仓库的状态。如果有修改，新建，删除等操作，将会自动列举出来。 git add newfile.Rmd newfile.Rmd 是一个新建的文件，其中有一些新增的代码。该命令将其加入 Git 追踪的文件清单中。 git commit 或者 git commit -a 这个命令将执行一次 Commit 操作，系统会打开默认的文本编辑器，以填写本次 Commit 操作涉及的工作内容。 git push 将本地仓库的修改推送到远程仓库中去。要执行该命令，本地仓库需要关联一个远程仓库，并且用户对该远程仓库具有修改权限（使用 git remote -v 查看本地仓库关联的远程仓库地址）。 git pull 将本地仓库的内容与远程仓库同步（这是远程仓库的文件比本地仓库的文件版本新）。 2.2.3.3 配置 Git 远程仓库的 SSH 认证 SSH 密钥是成对的，包括公钥和私钥；公钥登记到 GitHub 网站，私钥存储在本地计算机（私有）。密钥在本地生成。点击鼠标右键，选择“Git Bash Here”，输入下列命令将生成一对 SSH 密钥。 默认情况下，私钥保存在“~/.ssh/id_rsa”文件中，公钥保存在 “~/.ssh/id_rsa.pub”文件中 （在 Windows 系统中的 Git bash 终端下，~ 代表用户的家目录）。 ssh-keygen cat ./.ssh/id_rsa.pub 复制这个公钥的全部内容，进入“GitHub - Setting - SSH and GPG keys”，选择“New SSH key”，将公钥粘贴进去，点击“Add SSH key”，即可完成公钥添加。 这样，以后就调用 “Git Bash Here” 时，便会自动提供私钥认证，不需要输入用户名和密码了。 2.2.3.4 使用 GitHub 在 GitHub 网站中，通常主要进行下列操作： 创建一个新的软件仓库； 点击 GitHub 右上角的“+”，选择“Create a new repository”，按照提示操作即可。这步操作其实相当于在 GitHub 服务器上新建了一个目录。目录名称是 Repository Name。目录的路径就是 &lt;username&gt;/&lt;repository_name&gt;。对应的网址（绝对路径）是 https://github.com/&lt;username&gt;/&lt;repository_name&gt;。对应的 Git 地址是 git://git@github.com/&lt;username&gt;/&lt;repository_name&gt;.git。对应的 SSH 地址是 ssh://git@github.com/&lt;username&gt;/&lt;repository_name&gt;.git。 从其他用户的软件仓库中新建一个分支，即 Fork； 在 GitHub 项目网页中，点击“Fork”即可。 为其他用户的软件仓库中贡献代码，即 Pull Request； 因为自己不具备其他用户拥有的软件仓库的编辑权限，所以无法直接通过 push 的方法提交修改。在这种情况下，用户可以首先在 GitHub 上 Fork 其他用户的软件仓库，并在自己的 Fork 中做相应修改后，通过 Pull Request 的方法提交给其他用户，经过管理员审核后，即可合并到对方的软件仓库中去。这也是团队协作共同维护一个项目时的常规操作。 第 7.2.8 节还将介绍使用 GitHub Actions 实现自动化完成持续性集成（Continuous Integration，CI）的功能。 2.2.4 安装 RStudio 图形化编辑器 2.2.5 创建第一个 R Markdown 文档 2.3 R Markdown 的编译过程 2.4 R Markdown 的基本元素 2.4.1 YAML 头部 2.4.2 Markdown 语法 2.4.3 代码区块和行内代码 2.5 页面设置和布局 2.5.1 控制输出宽度 2.5.2 换行符号 2.5.3 分页符和分割线 2.5.4 目录 2.5.5 章节编号 2.5.6 图表的索引 2.5.7 参考文献 2.6 R Markdown 的文档元素 2.6.1 图片 2.6.2 表格 2.6.3 公式 2.6.4 引用 2.6.5 字体颜色 2.6.6 动态交互元件 2.6.7 音频和视频 2.6.8 流程图 2.6.9 甘特图 TinyTeX 与 tinytex 并不是一个东西。前者是一个 LaTeX 发行版，后者是一个用来安装和维护前者的 R 语言软件包。↩︎ Linus Torvalds (1969年12月28日－) 生于芬兰赫尔辛基市，拥有美国国籍，Linux 内核的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他 2005 年发布了 Git，是 Git 的主要开发者。↩︎ 命令行对于 Linux/Mac 用户应该并不陌生，此处和以下不再另行介绍。↩︎ "],["rmarkdown-document.html", "第 3 章 使用 R Markdown 创建常用文档 3.1 HTML 文档 3.2 PDF 文档 3.3 PPT 幻灯片 3.4 Word 文档 3.5 创建新的文档格式", " 第 3 章 使用 R Markdown 创建常用文档 Markdown 在发明之初的主要目的就是简化 HTML 内容的书写方式。例如要表示一个无序列表中的项，用 HTML 来写是 &lt;ul&gt;&lt;li&gt;text&lt;/li&gt;&lt;/ul&gt;，而用 Markdown 来写则只需要 - text；又如要表示一段引用文字，用 HTML 来写是 &lt;blockquote&gt;text&lt;/blockquote&gt;，用 Markdown 来写则只需要 &gt; text。 Pandoc 大大扩展了 Markdown 的语法。更重要的是，Pandoc 使得将 Markdown 文档转换为多种输出格式成为可能。尽管这些文档大体可以按照背后的实现方式，分为 HTML、PDF 和 Microsoft Office 等 3 大类型，但是根据应用场景的差异，会有多种多样的具体样式。 鉴于每种样式通常会通过不同的 R Markdown 扩展软件包来实现，所以其设置和使用方面会有自身的特点。因此，在接下来的一部分内容中将依次介绍常用文档格式的使用方法。而本章则主要介绍将 R Markdown 源文件输出为各种常用文档格式的功能。 简单说来，要论从 R Markdown 到各种文档之间总共分几步？答案是 2 步。 R Markdown –&gt; Markdown，由 knitr (Xie 2022b) 完成； Markdown –&gt; 不同格式文档，由 Pandoc 完成。 3.1 HTML 文档 HTML 即超文本标记语言（Hyper Text Markup Language），该技术是互联网最重要的基础设施之一，是网上精彩纷呈内容的主要依托。HTML 文档不仅能够展示文字、图片、表格、公式等常规页面元素，而且还可以呈现音乐、视频、交互动画等丰富多样的多媒体内容。而同样的任务则是其它常见的文档格式如 PDF、Microsoft Word 等所不能完成的。因为 Markdown 技术在设计之初的输出格式就是 HTML，所以 HTML 文档不仅仅是最常用 R Markdown 输出格式，同时也拥有最丰富的功能，因此是在学习 R Markdown 技术的过程中首先需要了解这一部分内容。 严格意义上说，采用 R Markdown 和 HTML 技术呈现的网站、幻灯片等也都属于 HTML 格式的文档，不过这些形式的内容通常包含了多个 .html 格式的文件，而这里介绍如何通过 R Markdown 源文件生成一份独立的 .html 格式的文件。 前面提过，R Markdown 生成 HTML 文档的过程有一个中间步骤，就是 Markdown + HTML 模板。HTML 模板包括预定义的文档结构、 CSS 样式表和 JavaScript 动态网页功能等，所以最终渲染得到的 HTML 文档的一些功能可能依赖于特定 HTML 模板才能实现。对于一般用户而言，不了解这方面的知识并不影响正常使用 R Markdown 创建 HTML 文档。但是如果用户对此有所了解，那将有利于了解 HTML 文档的实现途径。 默认情况下，R Markdown 的 HTML 文档使用 rmarkdown::html_document 模板。除此之外， rmarkdown 之外的其它软件包也提供了各种不同类型的 HTML 模板文件（如 bookdown::html_document2，pagedown::html_paged 等）。因此，在这一部分将首先从 R Markdown 到 html_document 文档开始。 要创建一个 html_document，只需要在 R Markdown 的开头加入 YAML 格式的元数据。 --- title: &quot;文档标题&quot; author: &quot;作者&quot; date: &quot;创建时间&quot; output: html_document --- 在元数据中，还可以加入各种各样设置，从而改变文档的格式。例如下面的设置将为文档添加一个自动目录。 --- title: &quot;文档标题&quot; author: &quot;作者&quot; date: &quot;创建时间&quot; output: html_document: toc: true --- 3.1.1 目录和标题 R Markdown 文件中使用的目录都是自动目录，是根据文档的层次结构（一级标题、二级标题等）自动生成的。这一部分介绍如何在 HTML 文档中设置自动目录。 3.1.1.1 显示目录 在开头的元数据中，使用 toc: true 可以打开文档的目录。目录会从 HTML 的标题自动生成，目录的层级由 toc_depth 的值确定（默认为 3）。例如： --- title: &quot;标题&quot; output: html_document: toc: true toc_depth: 2 --- 在上面的例子中，目录中将包含 HTML 文档中的一级标题和二级标题。 3.1.1.2 悬停目录 当把 toc_float 设为 true 的时候，目录会在侧边栏悬停。这样就可以随时借助目录在一篇比较长的文档中跳转了。 --- title: &quot;标题&quot; output: html_document: toc: true toc_float: true --- 通过改变 toc_float 的选项，可以控制侧边栏的折叠和动画。其中： collapsed （默认为 true）控制文档第一次打开时目录是否被折叠。如果为 true 则只显示高级别的标题（二级标题及以上元素）； smooth_scroll （默认为 true）控制页面滚动时，标题是否会随之变化。 --- title: &quot;标题&quot; output: html_document: toc: true toc_float: collapsed: false smooth_scroll: false --- 3.1.1.3 显示标题编号 使用 number_sections 可以在标题开头加上编号。一级标题编号为 “1 一级标题”，二级标题为”1.1 二级标题”。 --- title: &quot;标题&quot; output: html_document: toc: true number_sections: true --- 3.1.1.4 使用标签页展示小标题的内容 在 HTML 文档中使用标签页非常简单，只需要在标题后附加 {.tabset} 标签即可。 ## 季度报表（应用 `.tabset` 标签） {.tabset} ### 按产品汇总 （具体的报表内容） ### 按区域汇总 （具体的报表内容） 在此基础上，添加相关的额外标签还可以控制标签的样式和行为。其中： .tabset-fade 将为标签切换过程加入淡入淡出的动画效果； .tabset-pills 将为标签文字加上预设的 .tabset-pills 样式（图 3.1）。 图 3.1: 标签的默认样式及 .tabset-pills 样式 3.1.2 主题和样式 3.1.2.1 可选的文档主题样式 为了满足颜值党的差异化需求，html_document 自带了多个不同的主题。这些主题来自于 Bootswatch。可用的主题名称包括 default，cerulean，journal，flatly，darkly，readable，spacelab，united，cosmo，lumen，paper，sandstone，simplex 和 yeti 等等。 主题使用 theme 参数来指定，这里以 darkly 作为一个例子，感兴趣的读者可以自行尝试其它样式（图 @ref(fig:first-rmd-theme-darkly）： --- title: &quot;标题&quot; output: html_document: theme: darkly --- 图 3.2: 应用 darkly 主题后的文档样式 如果设置为 theme: null，那么将不会应用任何主题，此时可以通过指定自定义的 CSS 样式表来进行格式化。 --- title: &quot;标题&quot; output: html_document: theme: null css: style.css --- 3.1.2.2 可选的代码高亮样式 代码高亮也有可选的多种样式，包括 default，tango，pygments，kate，monchrome，espresso，zenburn，haddock，breezedark 和 textmate 等。 在元数据中，使用 highlight 参数指定代码高亮样式。下面的示例中将代码高亮设为 tango，更多的代码高亮样式见图 3.3。 --- title: &quot;标题&quot; output: html_document: highlight: tango --- code_highlight_examples = list.files(&quot;examples/&quot;, &quot;code-highlight-example.*\\\\.png&quot;, full.names = TRUE) knitr::include_graphics(path = code_highlight_examples, dpi = NA) 图 3.3: 可选的代码高亮样式 跟上面的 theme 属性一样，highlight 也可以设为 null，这样的话代码将不显示高亮。 3.1.2.3 自定义样式表 不论有没有应用主题和代码高亮，用户都可以使用 css 参数指定附加样式表。附加样式表中的定义优先级更高，当被应用到特定元素上去之后，可以改变元素的外观。 --- title: &quot;标题&quot; output: html_document: theme: null highlight: null css: styles.css --- 如果在 styley.css 中定义了两个名为 #nextsteps 和 .emphasized 的新样式，分别用于指定 HTML 文档中 id = \"nextsteps\" 和 class = \"emphasized\" 这两种元素的外观。 #nextsteps { color: blue; } .emphasized { font-size: 1.2em; } 那么，就可以通过在行尾大括号中添加元素 id 和 CSS 类的方法，对某个二级标题（此处为“这里强调一下下一步”）应用这个样式： ## 这里强调一下下一步 {#nextsteps .emphasized} 如果要应用多个 CSS 配置文件，可以这样写： output: html_document: css: [&quot;style-1.css&quot;, &quot;style-2.css&quot;] 3.1.2.4 通过 CSS 代码块定义样式 除了像上面那样导入一个预定义的样式表，还可以直接在 R Markdown 中添加新的 CSS 定义。不过这种方法只适合针对个别元素进行个性化设置，如果 CSS 代码有很多行，或者想要在其它 R Markdown 文件中中交叉使用同样的定义，那么将其放在自定义样式表文件中会更加合适（参见 3.1.2.3）。 --- title: &quot;对代码块使用自定义的 CSS 样式&quot; output: html_document --- 首先定义一个新样式 `watch-out`。 ```{css, echo=FALSE} .watch-out { background-color: lightpink; border: 3px solid red; font-weight: bold; } ``` 使用代码块属性 `class.source` 可以将新样式指定给这一区块。 ```{r class.source=&quot;watch-out&quot;} mtcars[1:5, &quot;mpg&quot;] ``` 图 3.4: 一个具有浅红色背景和深红色边框的代码块 3.1.2.5 使用丰富多样的内置 CSS 样式 大多数时候，用户并不需要自己定义 CSS 样式，因为 HTML 内置的主题中已经包含了丰富且高级的内置样式。 默认情况下，R Markdown 输出的 HTML 文档中，已经内嵌了 Bootstrap 框架4，因此可以使用一系列预定义的 CSS 样式。其中，可用的背景样式就包括 \"bg-primary\"，\"bg-success\"，\"bg-info\"，\"bg-warning\" 和 \"bg-danger\" 等。 只需要在代码块属性中使用 class.source 标签，就可以应用这些预定义的 CSS 样式。 --- title: 改变代码块的样式 output: html_document --- 当你对一个数据框取子集的时候，其输出跟选取的列的数目有关。 如果选取了 2 个以上的列，则输出仍然是一个数据库； 如果选取了 1 个列，则输出的结果将会是一个向量。 因此，我们对这个操作应用了 `bg-danger` 和 `bg-warning` 的样式。 ```{r class.source=&quot;bg-danger&quot;, class.output=&quot;bg-warning&quot;} mtcars[1:5, &quot;mpg&quot;] ``` 为了确保始终能够得到数据框，则需要添加 `drop = FALSE` 参数。 为了显示这个结果，我们应用了 `bg-success` 样式。 ```{r df-drop-ok, class.source=&quot;bg-success&quot;} mtcars[1:5, &quot;mpg&quot;, drop = FALSE] ``` 以上内容生成 HTML 文档后的样子如图 3.5 所示： 图 3.5: 在代码块上应用内置 CSS 样式 3.1.2.6 代码折叠 当 Knitr 的代码块参数 echo = TRUE 时，R 代码将会输出到最终生成的文档中。 如果不需要显示源代码，可以直接设为 echo = FALSE。 如果既想要保留代码但又让其默认不显示， 则可以通过 code_folding: hide 参数来实现。 --- title: &quot;代码折叠&quot; output: html_document: code_folding: hide --- code_folding: hide 将折叠所有的代码块，用户可以通过点击来查看折叠的代码。如果想让部分代码块在一开始就显示，则可以在代码块选项中使用 class.source = 'fold-show'（图 3.6）。 --- title: &quot;代码的折叠和显示&quot; output: html_document: code_folding: hide --- ```{r} 1 # 折叠的 ``` ```{r class.source = &#39;fold-show&#39;} 2 # 显示的 ``` ```{r} 3 # 还是折叠的 ``` 图 3.6: 代码块的折叠和显示。图中每个代码区块旁边都有一个按钮，可以控制相应代码区块的显示方式；文档的右上角也有一个按钮，可以控制文档中全部代码区块的显示方式。 这种操作也可以反向进行，即默认显示全部的代码区块，然后再将部分代码区块设为折叠。如下配置即可： --- output: html_document: code_folding: show --- ```{r} 1 # 代码默认是显示的 ``` ```{r class.source = &#39;fold-hide&#39;} 2 # 这一块代码将被折叠 ``` 如图 3.6 所示，在页面和每一个代码块的右上方有一个按钮。页面右上方的按钮可以控制全部代码块的显示和隐藏，代码块右上方的按钮则可以控制对应代码块的显示和隐藏。 3.1.2.7 设置代码块内容可滚动 如果想限制代码块的高度，特别是代码执行过程中输出内容的高度，还可以从相应内容的 CSS 样式上着手，即通过 class.output 和 class.source 来定义内容的高度。 下面是一个限制设定代码区块高度后，再通过滚动查看完整内容的例子： --- title: 可以滚动的代码和输出 output: html_document --- ```{css, echo = TRUE} pre { max-height: 300px; overflow-y: auto; } pre[class] { max-height: 100px; } ``` 我们首先定义了上述 CSS 规则，用来限制代码块的高度。 ```{r} # 假如这里有 N 多行的代码 if (1 + 1 == 2) { # 然后再打印一个非常长的数据 print(mtcars) # 如果不够长的话，再加上这行注释可能就够了 } ``` 现在添加一个新的 CSS 类 `scroll-100`，以用来限制代码块的输出高度为 100 像素。 然后，将这个类赋值给代码块中的 `class.output` 参数。 ```{css, echo=FALSE} .scroll-100 { max-height: 100px; overflow-y: auto; background-color: inherit; } ``` ```{r, class.output=&quot;scroll-100&quot;} print(mtcars) ``` 因为代码块是位于 &lt;pre class=\"sourcecode\"&gt; 标签内的，所以 pre[class] 操作符将限制代码块的高度为不超过 100 像素。 而将 class.output 设为 scroll-100 则限制输出部分的高度为不超过 100 像素。最终效果如图 3.7 所示。 图 3.7: 可以滚动的代码块 3.1.3 图片和数据框 3.1.3.1 设置图片的属性 下列参数可以调整生成的 HTML 文档中图片的属性： fig_width，fig_height 指定图片显示时的宽和高（默认为 7 × 5，单位英寸）； fig_retina 开启视网膜屏幕优化（默认为 2，设为 null 时关闭优化）； fig_caption 控制是否渲染图注； dev 设置图片输出设备，默认为 png。可以设置多个图片输出设备。 --- title: &quot;标题&quot; output: html_document: fig_width: 7 fig_height: 6 fig_caption: true dev: c(&quot;png&quot;,&quot;pdf&quot;) --- 在代码框属性中，仍然可以通过 fig.height，fig.width，fig.asp 等参数来指定生成图片的高度、宽度和宽高比。 3.1.3.2 插入外源图片 虽然在 R Markdown 中可以使用 Markdown 语法和 HTML 语法插入图片，但是推荐使用 knitr::include_graphics() 的方式来完成这一操作。例如： ```{r} knitr::include_graphics(&quot;https://r-project.org/Rlogo.png&quot;) ``` 使用这种方法插入外源图片，可以方便地添加图注（使用 fig.cap 参数），以及设置图片的宽高等属性（图 3.8）。 图 3.8: 插入外源图片的推荐方式 3.1.3.3 输出数据框 数据框是常见的数据结构，通过设置 df_print 参数，可以调整数据框的输出格式。可用的参数如表 3.1 所示。 表： (#tab:df-print) html_document 可以被设置的 df_print 参数及其对应的含义。 取值 说明 default 调用 print.data.frame 的通用方法 kable 使用 knitr::kable 函数 tibble 使用 tibble::print.tbl_df 函数 paged 使用 rmarkdown::paged_table 来创建一个分页的表格 3.1.3.4 分页打印数据框时的附加参数 {html-df-print-paged} 若把 df_print 参数设为 paged，数据框将支持行列的分页，效果如图 3.9 所示。 --- title: &quot;发动机测试和汽车道路测试&quot; output: html_document: df_print: paged --- ```{r} mtcars ``` 图 3.9: HTML文档中分页显示的数据框 表 @ref(#tab:paged) 列出了这种情况下可以使用的附加参数。 表 3.2: 分页 HTML 表格的附加可用参数。 参数名 说明 max.print 显示的总行数 rows.print 一页显示的行数 cols.print 一页显示的列数 cols.min.print 最少显示几列 pages.print 下方显示页面导航链接的数目 paged.print 设为 FALSE 则不输出分页的表格 rownames.print 设为 FALSE 时不显示行的名称 这些参数可以在代码块中使用。 ```{r cols.print=3, rows.print=3} mtcars ``` 3.1.4 组件和内容 3.1.4.1 理解 HTML 文档的依赖关系 R Markdown 输出 HTML 文档时依赖于软件包提供的 HTML 模板。 实际上，HTML 文档的样式和功能很大程度上依赖于一些 CSS 样式和 JavaScript 库的支持。 这里面包括 Bootstrap5，JQuery 等优秀的开源项目。前者是一个通用的网站开发框架，后者是一个通用的 JavaScript 库。 默认情况下，R Markdown 输出的 HTML 文档是一个单一的 .html 文件。这是由 self_contained: true 控制的。.html 文件中，会使用 data: 存储包括 JavaScript、CSS、图片和视频在内的全部资料。这样的一个封装，使得用户可以像分享 PDF 或 Word 文档那样分享文件，同时享受超链接、动态效果等一系列 HTML 特性。 如果指定 self_contained: false，那么 HTML 文档将会将自身的依赖文件单独存放。 --- title: &quot;标题&quot; output: html_document: self_contained: false --- 默认情况下，在 .html 文件同一目录会生成同名的 _files 文件夹，存放相应的依赖文件。下面是默认情况下一份 HTML 文档所包含的依赖文件。 +---anchor-sections-1.0 +---bootstrap-3.3.5 | +---css | | \\---fonts | +---fonts | +---js | \\---shim +---header-attrs-2.5 +---highlightjs-9.12.0 +---jquery-1.11.3 \\---navigation-1.1 存放这些依赖文件的文件夹位置可以由 lib_dir: xxx 指定，例如： --- title: &quot;标题&quot; output: html_document: self_contained: false lib_dir: libs --- 依赖文件的内容会随配置变化，例如当在 YAML 配置中加入 df_print: paged 之后，依赖文件中会多一个 pagedtable-1.1 的子文件夹出来。 显然，存放依赖的子文件夹依据 库名 + 版本号 的规则命名。要弄清楚库文件的全部特性，可能要对库本身有相当的理解才行。而 R Markdown 则是把最常用的功能整合提供给了用户。 当文档的内容比较少，同时又有多个类似的文档的时候，库文件所占的存储空间可能比自己编写的内容还要大得多。这种情况下，将库文件统一存储在指定的 libs 文件夹，可以实现库文件公用。 另外，有些库文件不常用，或者文件太大，还可以通过库文件的服务器调用。例如下面一节要讲的 MathJax 库。 3.1.4.2 MathJax 库的配置 HTML 文档需要 MathJax 脚本来渲染 Latex 和 MathML 公式6，调用 MathJax 的方式则可以通过 mathjax 参数来调整。 \"default\"：默认配置，会通过 HTTPS 链接从 RStudio 的 CDN 网络服务器上调用； \"local\"：与 self_contained: false 联合使用时，会将 MathJax 库文件保存在本地目录中； 还可以将 mathjax 的值设置成一个 URL 链接，指向可用的 MathJax 库文件地址； null：完全不使用 MathJax。 例如，使用 MathJax 的本地拷贝可以如下配置： --- title: &quot;标题&quot; output: html_document: mathjax: local self_contained: false --- 为 MathJax 配置一个新的可用来源。 --- title: &quot;标题&quot; output: html_document: mathjax: &quot;http://example.com/MathJax.js&quot; --- 不使用 MathJax。 --- title: &quot;标题&quot; output: html_document: mathjax: null --- 3.1.4.3 是否保留 Markdown knitr 处理 R Markdown 文件时，会先生成一个 Markdown 文件（*.md），随后再由 Pandoc 转换成 HTML 文档。如果需要保留这个 Markdown 文件，可以使用 keep_md 选项。 --- title: &quot;标题&quot; output: html_document: keep_md: true --- 3.1.4.4 使用自定义的 HTML 模板 使用 template 选项，可以配置 Pandoc 转换时使用的模板。 --- title: &quot;标题&quot; output: html_document: template: another_template.html --- Pandoc 模板遵循特定的格式，有关的进一步信息可以在 Pandoc 模板 页面获得。 下面是一个 HTML 模板的示例： &lt;html&gt; &lt;head&gt; &lt;title&gt;$title$&lt;/title&gt; $for(css)$ &lt;link rel=&quot;stylesheet&quot; href=&quot;$css$&quot; type=&quot;text/css&quot; /&gt; $endfor$ &lt;/head&gt; &lt;body&gt; $body$ &lt;/body&gt; &lt;/html&gt; 这其中包括一些变量，如 $title$，$body$ 等。这些变量由 Pandoc 定义，完整的变量列表可以 参见 Pandoc 的官方文档。 这样的 HTML 模板使得高度定制化的输出成为可能。例如，可以在 &lt;head&gt; 区域加入任意的 CSS 样式， JavaScript 代码，以及其它的开源库。 另外，还可以定义一些新变量来控制文档的格式化。例如，定义一个布尔值 draft 来确定文档是一个草稿还是最终版本。 &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; .logo { float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;logo&quot;&gt; $if(draft)$ &lt;!-- 使用 draft.png 以表明这是一份草稿 --&gt; &lt;img src=&quot;images/draft.png&quot; alt=&quot;您正在阅读的是一份草稿&quot; /&gt; $else$ &lt;!-- 在最终版本中插入正式 LOGO --&gt; &lt;img src=&quot;images/logo.png&quot; alt=&quot;您正在阅读本文档的正式版本&quot; /&gt; $endif$ &lt;/div&gt; $body$ &lt;/body&gt; draft 变量可以通过 YAML 元数据来赋值。这样根据 draft 设定的不同值，R Markdown 可以编译出具有不同 LOGO 图像的 HTML 文档，从而可以直观的显示读者目前看到的这份文档是一个草案还是最终版本。 --- title: &quot;一份重要的报告&quot; draft: true output: html_document: template: my-template.html --- 说明：rmarkdown 软件包默认使用自带的 HTML 模板，一些方面与 Pandoc 默认的模板存在差异。如果有 template: null 的话，则 Pandoc 的模板会被使用。 3.1.4.5 包含其它文件 使用 includes 选项，可以在 HTML 文档的不同位置嵌入其它的 HTML 格式内容。可选的位置包括在 HTML 文档的 header、body 前/后等7。 --- title: &quot;标题&quot; output: html_document: includes: in_header: header.html before_body: doc_prefix.html after_body: doc_suffix.html --- 这种方式可以很方便的为文档加入一些第三方功能和公用的元件。例如在 in_header 中导入预定义的 CSS 样式表和 Javascript 脚本，在 before_body 中加入导航栏，在 after_body 中加入一个底栏等。 下面的例子中，即添加了一个简单的底栏。将其中内容保存到一个 HTML 文件中，放在 after_body 后面即可。 &lt;div class=&quot;footer&quot;&gt;Copyright &amp;copy; R Markdown 指南 2021&lt;/div&gt; 除了以上几种常用的位置，还可以在任意地方插入 HTML 内容。实现这一功能的途径至少有两种。 一是使用 htmltools::includeHTML() 方法： ```{r, echo=FALSE, results=&#39;asis&#39;} htmltools::includeHTML(&#39;file.html&#39;) ``` 二是使用 xfun::file_string() 方法： ```{r, echo=FALSE, results=&#39;asis&#39;} xfun::file_string(&#39;file.html&#39;) ``` 需要注意的是，导入的 HTML 文件必须是 HTML 片段，而不能是一个完整的 HTML 文档。完整的 HTML 文件中有 &lt;html&gt; 标签，解析时会造成错误。比如下面就是一个无效的例子： &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; 父 HTML 文件。 &lt;!-- htmltools::includeHTML() 将插入下列 HTML 代码 --&gt; &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; 子 HTML 文件。 &lt;/body&gt; &lt;/html&gt; &lt;!-- 上面的内容即插入的 HTML 代码，插入后新文档的解析会出错 --&gt; &lt;/body&gt; &lt;/html&gt; 3.1.4.6 生成 HTML 片段 HTML 片段是一个不完整的 HTML 文件，这种片段适合用于嵌入其它的网页或者内容管理系统（如博客）中。HTML 片段也不自带主题和代码高亮，而通过继承的方式使用其嵌入文件或系统的设置。这样的 HTML 片段，也非常适合用于包含在其它文件中（参见 ??）。 --- output: html_fragment --- 下面是一个 HTML 片段的例子： &lt;p&gt;HTML 片段可以有标题和代码区域，但是不包含任何 CSS 定义。&lt;/p&gt; &lt;pre class=&quot;r&quot;&gt;&lt;code&gt;head(mtcars)&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code&gt;## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1&lt;/code&gt;&lt;/pre&gt; 将这些内容保存为一个 HTML 文件，导入此处，则效果如下所示： HTML 片段可以有标题和代码区域，但是不包含任何 CSS 定义。 head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 HTML 片段的内容到此结束。 3.1.4.7 使用自定义的浏览器图标 通过在 in_header 部位导入 HTML 内容，可以为 HTML 文档设定一个自定义的浏览器图标。 将下面的内容保存到一个名为 header.html 的文档中。 &lt;link rel=&quot;shortcut icon&quot; href=&quot;{path to favicon file}&quot; /&gt; 然后通过 includes 导入文件的内容，则可以改变浏览当前文档时的浏览器图标。 output: html_document: includes: in_header: header.html 3.1.4.8 共用 YAML 配置文件 当前目录中的 _output.yml 文件是一个配置文件，其中的设置可以被目录下所有的 R Markdown 文档公用。需要注意的是，该文件中的内容不需要使用--- 和 output 标签。 如下所示： html_document: self_contained: false theme: united highlight: textmate 而不应该写成下面这种样子： --- output: html_document: self_contained: false theme: united highlight: textmate --- 3.1.4.9 允许下载源文件 当分享一个 R Markdown 生成的 HTML 文档给他人的时候，对方可能还需要提供 .Rmd 源文件。在头文件中配置 code_download 参数可以在 HTML 文档中嵌入源文件。 output: html_document: code_download: true 打开 code_download 选项后，页面中会出现一个下载按钮，点击下载按钮即可获得源文件。 3.1.4.10 嵌入数据或其它文件 嵌入 .Rmd 源文件可能还不足以重现 R Markdown 中结果，通常还会需要原始数据等其它内容。要将这些内容嵌入 HTML 文档中，也是很容易实现的。 这一功能通过 xfun 软件包(Xie 2022d) 实现，依赖于 htmltools 和 mime 软件包。要使用这一功能，首先确保这两个软件包可用。 xfun::pkg_load2(c(&#39;htmltools&#39;, &#39;mime&#39;)) 现在，就可以随意嵌入各种文件了。 ```{r echo=FALSE} # 不但可以嵌入一个文件 xfun::embed_file(&#39;source.Rmd&#39;) # 还可以嵌入多个文件 xfun::embed_files(c(&#39;source.Rmd&#39;, &#39;data.csv&#39;)) # 甚至一个目录也不在话下 xfun::embed_dir(&#39;data/&#39;, text = &#39;Download full data&#39;) ``` 不仅如此，还可以编程技巧嵌入所需的文件。 # 嵌入当前目录下所有的 Rmd 和 csv 文件 xfun::embed_files(list.files(&#39;.&#39;, &#39;[.](Rmd|csv)$&#39;)) 说明：当嵌入多个文件时，其工作原理是：首先将这些文件压缩成 Zip 格式，然后将 Zip 文件嵌入到 HTML 文档中。 3.2 PDF 文档 这一部分讲述将 R Markdown 输出为 PDF 的功能。PDF 是便携式文档格式（Portable Document Format）的缩写，这是一种常见的文档格式， 特别是在文件、学术论文中广泛使用。它具有文件体积小、保真度高和安全的特点。 R Markdown 并不能直接输出 PDF 文档，而是会输出 LaTeX 文件，LaTeX 文件经过处理后生成 PDF。因此，使用 R Markdown 输出 PDF 文件时，可以充分发挥 LaTeX 的优势。在需要的时候，可以直接使用 LaTeX 代码编写内容，应用 LaTeX 的包和模板，添加标题、脚注、子图等。 不过，LaTeX 技术对于大多数人可能都还比较陌生，而在生成 PDF 文档的过程中，很多问题都跟 LaTeX 的配置有关。这几乎是不可避免的，因此在开始正式的内容前，需要确保已经安装了 TinyTex 以及一些依赖的 LaTeX 组件。具体的安装步骤和疑难解答请参见前文（2.2.2），此处不再赘述。 3.2.1 从 R Markdown 到 PDF 文档 要输出 PDF 文档，只需要在 R Markdown 开头的 YAML 配置中指定 pdf_document 即可。 --- output: pdf_document --- 只需要这样一个改动，就可以得到一份 PDF 文档。 3.2.2 在 PDF 文档中使用中文的注意事项 如果这份 PDF 中仅含有英文，那么不需要做额外的设置。 但是对于中文用户而言，可能会出现错误。这是因为，PDF 所依赖的 LaTeX 系统对中文的支持与 HTML 不同，需要做一些合适的设置。包括导入中文语言支持的 LaTeX 模块 ctex，以及使用一个对 Unicode 支持更好的 xelatex 引擎。 下面就是一份中文 PDF 文档的示例。 import_example(&quot;examples/PDF-document-in-chinese.Rmd&quot;) --- title: &quot;这是一个 R Markdown 生成的 PDF 文档&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document: latex_engine: xelatex header-includes: - \\usepackage{ctex} --- 既然你在看这本书，想必你想制作的 PDF 文档难免会包括中文。 要想让 PDF 更好的支持中文，需要做一些额外的设置。 包括设置一个对 Unicode 支持更好的 `xelatex` 引擎，以及在 PDF 文档开始的配置部分 使用中文语言支持软件包 `ctex`。 我们接下来将会分别介绍这些功能。 将这份 R Markdown 编译后，将会生成一份 PDF 文档。 knitr::include_graphics(&quot;examples/PDF-document-in-chinese.png&quot;, dpi = NA) 3.2.3 与 HTML 文档中相通的一些设置 下面的这些设置与前文介绍的 HTML 文档中相应配置的用法基本相同（参见 3.1）。 3.2.3.1 显示目录 使用 toc 在 PDF 文档中加入目录，toc_depth 控制目录的深度。这点与 HTML 文档的用法一致8。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： toc: true toc_depth: 2 --- 如果 toc_depth 没有指定，则默认索引到二级标题（在 HTML 文档中默认索引到三级标题）。 使用 number_sections 可以在标题前面加入编号。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： toc: true toc_depth: 2 number_sections: true --- 3.2.3.2 图片相关的配置 fig_width 和 fig_height 用于控制图片默认的宽和高（默认为 6.5 x 4.5 英寸）。 fig_crop 控制 pdfcrop 的效果，功能是去掉图片边缘的空白（默认为 true）。 pdfcrop 是一个 LaTeX 组件，默认并没有被 tinytex 安装。推荐用户运行 tinytex::tlmgr_install(\"pdfcrop\") 来安装它。同时，pdfcrop 依赖于系统中的存在的 ghostscript，因此还需要安装 ghostscript 才能正常使用 pdfcrop。 fig_caption 控制是否为图片添加图注（默认为 true）。 dev 控制用于渲染图片的图像设备（默认为 pdf）。 --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： fig_width: 7 fig_height: 6 fig_caption: true --- 3.2.3.3 打印数据框 通过配置 df_print，可以调整打印数据框的格式（表 3.3）。 表 3.3: 输出 PDF 时 df_print 可选的值。 配置 说明 default 调用 print.data.frame 泛型函数 kable 使用 knitr::kable() 函数 tibble 使用 tibble::print.tbl_df() 函数 一个自定义函数 使用自定义函数创建一个表格。参见 ?? --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： df_print: kable --- 3.2.3.4 代码高亮 与 HTML 文档相同，这里可用 highlight 参数配置代码高亮的样式（参见 ?? 部分内容）。例如： --- title: &quot;五一劳动节加班三倍工资&quot; author: &quot;张三&quot; date: &quot;2021年5月1日&quot; output: pdf_document： highlight: tango --- 3.2.4 LaTeX 选项 很多 LaTeX 的配置，可以通过头部 YAML 的设定传递给 PDF 文档。 3.2.4.1 通用文档部件 一个 LaTeX 文档的结构大概是这样子： \\documentclass{article} % 序言/preamble \\begin{document} % 主体/body \\end{document} 在这个文档中，首先通过 \\documentclass{} 指定了文档的类，然后在序言部分（preamble）导入一些 LaTeX 的包（组件）和进行必要的设置，接下来在 \\begin{document} 后开始文档的主体内容。 一个 R Markdown 文档基本上都是在配置主体部分（body）的内容。 如果需要在序言部分加入一些内容，则可以使用 includes 选项。该选项包括 3 个 部分：in_header，before_body 和 after_body。每一个都支持一个或多个文件路径。 in_header 指定文件的内容将会被添加到序言部分，before_body 和 after_body 指定文件的内容会分别被添加到文档主体的前面和后面。 举例来说，下面的一个小技巧可以将正文中的链接地址以脚注的形式显示在 PDF 文档中， 这对于打印出来的文本而言，避免了无法看到链接地址的尴尬。将这几行代码保存为 tex 文件， 导入到序言部分，就可以实现这一功能。 % 在添加脚注前先保存 \\href 的值 % \\let\\oldhref\\href \\renewcommand{\\href}[2]{#2\\footnote{\\url{#1}}} 如果保存的文件名为 preamble.tex 则可以通过下面的形式将其添加到所有的 PDF 页面中。 output: pdf_document: includes: in_header: &quot;preamble.tex&quot; 不过，Pandoc 默认的 LaTeX 模板中已经内嵌了这一用法，所以实际上可以直接设置 links-as-notes 为 true 即可。 output: pdf_document: links-as-notes: true 在本书的 PDF 版本中，就使用了这种方法来添加页眉、页脚等内容。 3.2.4.2 选择 LaTeX 模板 通过 template 可以指定输出 PDF 文档时采用的 LaTeX 模板。 --- output: pdf_document: template: quarterly-report.tex --- 3.2.4.3 配置 LaTeX 模板的参数 每个 LaTeX 模板会有很多参数，用来指定文档的语言、字体、文字大小、页边距等内容。 表 3.4 列示了常见的一些参数，完整的参数则可以在 Pandoc 手册 中查看。 表 3.4: 在 YAML 配置中可用的 LaTeX 变量 变量名称 说明 lang 文档的语言代码 fontsize 文字大小 （如 10pt，11pt，12pt） documentclass LaTeX 文档类型 （如 article） classoption 文档类型的选项（如 oneside） geometry 页边距（如 margin=1in） mainfont, sansfont, monofont, mathfont 文档的字体（仅在使用 xelatex 和 lualatex 时可用） linkcolor, urlcolor, citecolor 内部链接、外部链接和引文链接的颜色 使用这些参数的时候，需要将其写在 YAML 头信息的最顶层，例如： --- title: &quot;这是一个PDF&quot; output: pdf_document fontsize: 11pt geometry: margin=1in --- 3.2.5 使用 LaTeX 包处理参考文献 默认情况，文档中的引用使用 pandoc-citeproc 来处理，这种方法不限制输出文档的类型，适用性最广。 不过，在 LaTeX 系统中也有非常优秀的引用工具，例如 natbib 和 biblatex。 如果想使用它们，只需要在 citation_package 中指定即可9。 --- output: pdf_document: citation_package: natbib --- 3.2.6 LaTeX 的渲染引擎 PDF 文档默认通过 pdflatex 渲染。其它可用的引擎还包括 pdflatex，xelatex和lualatex等。 不同的引擎可通过 latex_engine 来选择。 一般情况下，使用 xelatex 或者 lualatex 的主要理由是它们对 Unicode 的支持更加优秀，以及它们更容易使用系统中已有的字体10。 --- output: pdf_document: latex_engine: xelatex --- 3.2.7 保留生成的 TeX 中间文件 R Markdown 首先转化为 TeX 文件，然后才能转化为 PDF 文档。默认情况下，PDF 文档生成后，TeX 文档将会被删除。通过改变 keep_tex 的设置，可以保留生成的 TeX 文档（可用于向某些杂志投稿）。 --- output: pdf_document: keep_tex: true --- 3.3 PPT 幻灯片 本章讲述使用 R Markdown 生成幻灯片（俗称“PPT”）的技巧。 幻灯片可以被看做一个精简的文档，它的基本单位是单独的一页，每页含有标题、内容和其它元素。R Markdown 文档可以直接输出为 HTML 或者 PDF 格式的幻灯片，并且可以通过额外的软件包丰富幻灯片的具体样式。这一部分将首先介绍 R Markdown 基础幻灯片的使用，然后介绍如何使用 xaringan 软件包创建更加具有科技感的幻灯片。 使用基础幻灯片不需要安装额外的包。 R Markdown 支持 4 种不同样式的幻灯片，分别是 ioslides，Slidy，Beamer 和 PowerPoint。 在 RStudio 中，可以通过菜单中的 “New File -&gt; R Markdown…” 打开如下一个窗口（图 3.10），然后选择 “OK” 后即可新建一个幻灯片。 以上介绍的 5 种幻灯片格式中（含 xaringan），ioslides、Slidy 和 xaringan 都是基于 HTML 技术实现的（文档扩展名为 .html），Beamer 是基于 LaTeX 实现的（文档扩展名为 .pdf），PowerPoint 则是基于微软 Office 的文档格式实现的（文档扩展名为 .pptx）。 图 3.10: 新建 R Markdown 时可选的幻灯片格式 3.3.1 ioslides 幻灯片 首先看 ioslides 幻灯片。新建的幻灯片，也是一个 R Markdown 文档，在它的头部 YAML 中， output: ioslides_presentation 设定了其输出格式。 import_example(&quot;examples/ioslides-presentation.Rmd&quot;) --- title: &quot;Ioslides Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: ioslides_presentation --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` 这个文档经过编译后，得到的幻灯片如图 3.11 所示。 由此可见，在 R Markdown 幻灯片中，源文件中的 ## 代表一张幻灯片的开头和标题， ## 后面的内容是这一张幻灯片中的内容。R Markdown 会自动将命令和输出的内容添加到幻灯片中。 图 3.11: 新建文件编译后生成的 ioslides 幻灯片 除了 ##，使用 --- 也能开始一张新的幻灯片，并最终生成一个不带标题的幻灯片。 另外，还可以通过 “|” 来为幻灯片添加副标题。例如下面的例子： ## 起床 | 今天准备干点什么呢 3.3.1.1 使用快捷键控制显示模式 ioslides 幻灯片支持以下快捷键更改播放时的模式： 'f'：全屏模式，幻灯片将会占满屏幕。 'w'：宽屏模式，幻灯片将会以宽屏模式显示。 'o'：预览模式，幻灯片将会缩小并同时显示多个。 'h'：启用代码高亮模式，突出显示指定的几行代码。具体使用方法下面介绍。 'p'：显示演讲者备注，演讲者备注需要以指定的方式添加。具体使用方法下面介绍。 按下 'Esc' 键将会退出以上所有模式。 3.3.1.2 依次显示列表中的项目 使用 incremental 选项可以控制列表项目依次出现，相当于添加了简单的播放动画。 import_example(&quot;examples/ioslides-presentation-increment-bullets.Rmd&quot;) --- output: ioslides_presentation --- # ioslides 幻灯片 {data-background=ioslides-presentation.png data-background-size=cover} 一级标题产生了一个背景为灰色的幻灯片，我们为它加入了背景图片。 ## 列表项的内容 | 这里加入了一个副标题 默认情况下，整个幻灯片将会同时显示。 - Bullet 1 - Bullet 2 - Bullet 3 ## 列表项的内容 {.smaller} 但是 `&gt;` 可以作用于列表，这样以下内容将会在播放时依次出现（点击鼠标或者使用键盘）。 &gt; - Bullet 1 &gt; - Bullet 2 &gt; - Bullet 3 ## 下面的内容将会依次显示 {.build} 幻灯片标题后面的 `{.build}` 将会为这张幻灯片添加一个效果。首先显示这一段话，然后才显示下面的列表。 - 这个列表中的项目并不会依次显示 - 而是会作为一个整体出现 接下来的列表，因为使用了 `&gt;` 方法，其中的项目则可以依次出现。 &gt; - 先出现这个 &gt; - 然后才是这个 ## Future Steps {#future-steps .emphasized} 在 `style.css` 中，添加下列定义。 ```{css} #future-steps { color: blue; } .emphasized { font-size: 1.5em; } ``` 这几个字特别重要。 ## 代码高亮 大家看，这两步运算非常关键。 ```{r} cat(&#39;接下来进入计算过程&#39;) ### &lt;b&gt; x &lt;- 10 y &lt;- x * 2 ### &lt;/b&gt; cat(&#39;计算完毕&#39;) ``` 为所有幻灯片添加这样的效果有时候显得有点过分，所以 R Markdown 还提供了针对个别幻灯片 添加依次呈现效果的方法，即在前面加上一个 &gt; 号。 &gt; - 项目 1 &gt; - 项目 2 3.3.1.3 幻灯片适配宽屏幕显示器 在配置中使用 widescreen 可以将幻灯片样式改为宽屏。 --- output: ioslides_presentation: widescreen: true --- 3.3.1.4 幻灯片播放速度 ioslides 幻灯片翻页时会有淡入淡出的效果，使用 transition 可以控制效果的时长。 transition 设置为 \"default\"，\"slower\"，\"faster\"，或者一个以秒为单位的数字（如0.5）均可。如下所示： --- output: ioslides_presentation: transition: slower --- 3.3.1.5 依次显示幻灯片元素 每一张幻灯片的标题都可以加上 .build 属性，这样幻灯片的内容在播放的时候将会一块块的依次显示出来。 这一点与 incremental 属性有些类似，不过后者针对的是列表中的项目，而前者针对的是 一段话，一整个列表。 ## 下面的内容将会依次显示 {.build} 首先显示这一段话，然后才显示下面的列表。 - 这个列表中的项目并不会依次显示 - 而是会作为一个整体出现 接下来的列表，因为使用了 `&gt;` 方法，其中的项目则可以依次出现。 &gt; - 先出现这个 &gt; - 然后才是这个 3.3.1.6 设置幻灯片的背景图像 幻灯片中可以使用 data-background 添加背景图片，并使用其它的相关属性来 配置背景图片的行为，如 data-background-size， data-background-position， data-background-repeat 等等。 ## 添加背景图像 {data-background=foo.png data-background-size=cover} 这些配置来自于 CSS 中图片的属性，background，background-size，background-position， 以及 background-repeat 等。用户可能需要对 CSS 有所了解，才能准确把握这些属性的用途。 3.3.1.7 使用自定义 CSS 因为 ioslides 幻灯片本质上是一个 HTML 文档，所以可以像 HTML 文档一样通过自定义 CSS 来设定幻灯片中不同元素的样式。 要在幻灯片中附加一个自定义样式表，可以使用 css 属性。 --- output: ioslides_presentation: css: styles.css --- 为某一张幻灯片中添加样式的方式，也是通过大括号语法完成的。 ## Future Steps {#future-steps .emphasized} 这张幻灯片中的所有元素将会应用 CSS 定义的样式。 在 style.css 中，添加下列定义。 #future-steps { color: blue; } .emphasized { font-size: 1.2em; } 这种方式并不会影响幻灯片的标题，而是会影响这一张幻灯片中其它内容。 最终，这张幻灯片中所有的文字都会显示为蓝色、120% 的大字号。 3.3.1.8 突出显示部分代码 为了强调关键代码的作用，可以使用特定的注释来高亮它们。例如： ### &lt;b&gt; x &lt;- 10 y &lt;- x * 2 ### &lt;/b&gt; 在播放时，当按下键盘上的快捷键 'h' 时，高亮的代码将会突出显示，其它部分的代码则会变淡。 3.3.1.9 添加 LOGO 使用 logo 可以为幻灯片添加一个 LOGO 图片。默认情况下，这个 LOGO 将会以 85 x 85 像素显示在标题幻灯片上，并且缩小后显示在后面每一张幻灯片的左下角。 --- output: ioslides_presentation: logo: logo.png --- 使用自定义的 CSS 可以修改首页 LOGO 的显示效果。例如： .gdbar img { width: 300px !important; height: 150px !important; margin: 8px 8px; } .gdbar { width: 400px !important; height: 170px !important; } 左下角的 LOGO 显示样式同样可以使用 CSS 定义。例如： slides &gt; slide:not(.nobackground):before { width: 150px; height: 75px; background-size: 150px 75px; } 3.3.1.10 幻灯片的布局 如果想居中显示幻灯片的内容，可以在标题后面加入 .flexbox 和 .vcenter 的属性。 ## 统统居中显示 {.flexbox .vcenter} 使用 CSS class 的方法为美化幻灯片非常灵活。但是在标题中应用样式不能精确到一张 幻灯片中的某个具体元素。因此要实现幻灯片的复杂布局，只能使用类似 HTML 的语法。 居中显示某一段文字，可以采用下面的语法。 &lt;div class=&quot;centered&quot;&gt; 这部分文本将会居中显示。 &lt;/div&gt; 如果要以左右两栏的形式展示某一张幻灯片中的内容，可以使用下面的语法11。 &lt;div class=&quot;columns-2&quot;&gt; ![](image.png) - 项目 1 - 项目 2 - 项目 3 &lt;/div&gt; 3.3.1.11 文字颜色 使用 HTML 语法还可以修改其它的属性，比如文字的颜色。只需要将颜色以 CSS 类的形式赋值给元素即可。例如： &lt;div class=&quot;red2&quot;&gt; 这部分文本将显示为红色。 &lt;/div&gt; 可用的颜色包括 red，blue，green，yellow，grey等，以及它们的变体如 red2，blue3，green4等等 3.3.1.12 打印幻灯片 打印幻灯片可以在浏览器中进行，目前保真度最高的浏览器可能是 Google Chrome。 此外，使用 Chrome 中 “另存为 PDF” 的功能，还可以将幻灯片保存为一份 PDF 文档。 在 R 语言终端，使用 pagedown::chrome_print() 函数也可以完成这一操作（便于自动化和批处理）。 不过需要事先安装 pagedown 软件包(R-pagedown?)。 3.3.1.13 其它功能 ioslides 幻灯片中，通用的 R Markdown 语法通常可用，包括 HTML 文档输出中的配置， 图片的属性设置，数学公式，数据库的打印，中间文件的保留，外部文档的引入等等。 3.3.2 Slidy 幻灯片 Slidy 是 HTML 幻灯片的另一个规范。 要通过 R Markdown 创建一个 Slidy 幻灯片，只需要将文档输出设为 slidy_presentation 即可。 import_example(&quot;examples/slidy-presentation.Rmd&quot;) --- title: &quot;Slidy Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: slidy_presentation: font_adjustment: +1 footer: &quot;Copyright (c) 2021, Cosname&quot; duration: 45 --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown {.smaller} This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets {.bigger} - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` Slidy 幻灯片的内容设置基本与 ioslides 幻灯片相似，不过其默认样式与之有异。 一份 Slidy 幻灯片大体是这样的（图 3.12）。 图 3.12: Slidy 幻灯片 3.3.2.1 使用快捷键控制显示模式 Slidy 中也可以通过快捷键控制显示模式，不过其按键定义与 ioslides 不同。 'c'：显示幻灯片目录。Slidy 会自动生成目录，默认可以通过点击页脚左下角的 “Contents” 访问。 'f'：是否显示页脚的开关。 'a'：显示全部幻灯片的开关。 's'：缩小字体大小。 'b'：放大字体大小。 3.3.2.2 设置页脚内容 在 YAML 配置中使用 footer 可以为幻灯片设置页脚显示的内容。 --- output: slidy_presentation: footer: &quot;Copyright (c) 2021, Cosname&quot; --- 使用 duration 还可以方便的在页脚添加一个计时器（单位为分钟）。 --- output: slidy_presentation: duration: 45 --- 3.3.2.3 其它功能 Slidy 幻灯片继承了 HTML 文档中的多数功能（3.1），以及 ioslides 中的列表内容依次显示等功能（参见 3.3.1）。 3.3.3 Beamer 幻灯片 Beamer 是一个功能强大且灵活的 LaTeX 类，用于创建美观的幻灯片。 要从 R Markdown 创建 Beamer 幻灯片，只需要在 YAML 头文件中将输出格式设定为 beamer_presentation 即可。可以使用一级标题 # 和二级标题 ## 新建幻灯片 （使用 --- 也可以创建一张新的没有标题的幻灯片）。例如： import_example(&quot;examples/beamer-presentation.Rmd&quot;) --- title: &quot;Beamer Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: beamer_presentation: latex_engine: xelatex header-includes: - \\usepackage{ctex} --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## Beamer 幻灯片中的中文支持 要使用中文，需要做适当的配置，包括应用 `ctex` 包（支持中文的 LaTeX 包）和使用 `xelatex` 引擎。 与 HTML 格式的幻灯片相比，这可能是制作 Beamer 演示文稿时唯一需要额外做出配置的地方了。 ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` Beamer 幻灯片编译后的文件是一个 PDF 文档，大概像下面这个样子（图 3.13）。 图 3.13: Beamer 幻灯片示例 3.3.3.1 Beamer 幻灯片的中文支持 如果要生成中文的 Beamer 幻灯片，参考 3.2.2 中的设置。 3.3.3.2 Beamer 幻灯片的主题 Beamer 支持多个幻灯片主题，在 R Markdown 中使用 theme，colortheme 和 fonttheme 设定。 例如： --- output: beamer_presentation: theme: &quot;AnnArbor&quot; colortheme: &quot;dolphin&quot; fonttheme: &quot;structurebold&quot; --- 这样，上面的幻灯片就会变成下面这个样子（图 3.14）。 这个主题为标题幻灯片添加了页眉和页脚，显示作者、主题、日期和页码等信息。 图 3.14: 应用主题后的 Beamer 幻灯片 Beamer 支持数十个主题和颜色样式，在 这里 可以查看可用的选项。 (TODO?): (此部分可以扩展) 3.3.3.3 Beamer 幻灯片的边界 slide_level 参数用来指定一张幻灯片开始的位置。默认情况下，二级标题会被识别为一张幻灯片的开始，但是可以将它改为其它的大纲等级。 --- output: beamer_presentation: slide_level: 2 --- 3.3.3.4 Beamer 幻灯片的其它功能 Beamer 幻灯片从 HTML 文档中继承了目录内容、图片属性、样式、数据框打印、组件、 模板、Pandoc 参数和分享等功能（参加 3.1），从 PDF 文档和 ioslides 幻灯片中继承了列表动画、保留 TeX 文件等功能（参见 3.2, 3.3.1）。 3.3.4 PowerPoint 幻灯片 要制作 PowerPoint 幻灯片，只需要将输出格式设置为 powerpoint_presentation 即可。 这需要满足 rmarkdown 版本 ≥ v1.9，Pandoc 版本 ≥ 2.0.5 的条件12。 import_example(&quot;examples/powerpoint-presentation.Rmd&quot;) --- title: &quot;PowerPoint Presentation&quot; author: &quot;张三&quot; date: &quot;2021/4/28&quot; output: powerpoint_presentation --- ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = FALSE) ``` ## R Markdown This is an R Markdown presentation. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see &lt;http://rmarkdown.rstudio.com&gt;. When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. ## Slide with Bullets - Bullet 1 - Bullet 2 - Bullet 3 ## Slide with R Output ```{r cars, echo = TRUE} summary(cars) ``` ## Slide with Plot ```{r pressure} plot(pressure) ``` R Markdown 生成的 PowerPoint 幻灯片大概长这个样子（图 3.15）： 图 3.15: PowerPoint 幻灯片 PowerPoint 幻灯片采用的幻灯片标记与 Beamer 相同，默认为 3 级标题。使用 slide_level 可以控制新建一张幻灯片所需要的大纲等级。此外，使用 --- 可以新建一张没有标题的幻灯片。另外，R Markdown 中包括的图片和表格都会自动的被放到一张新的幻灯片中。也就是说，除了幻灯片的标题、图片/表格的标注之外，其它所有元素都不能与二者共存。这一点与其它格式幻灯片的行为有明显不同。 一般情况下，PowerPoint 幻灯片中的图片会被自动缩放到适合幻灯片的大小。如果自动缩放无效，那么对于静态图片可以使用 width 和 height 来分别设置，例如：![caption](foo.png){width=40%}。对于 R 语言生成的动态图形，则可以使用代码块的参数 fig.width 和 fig.height 来定义宽和高。 PowerPoint 幻灯片中可以使用的 Markdown 标记（参见 ??）包括粗体、斜体，脚注，列表，LaTeX 数学表达式， 图片，表格等。 3.3.4.1 两栏布局 正如 Beamer 幻灯片的高级应用需要借助于 LaTeX 语法一样， PowerPoint 幻灯片的高级应用需要借助于对 Pandoc 的深入了解。 使用 Pandoc 的语法，可以设置一个多栏的布局（请参见 Pandoc 的用户手册）： :::::: {.columns} ::: {.column} 左侧栏目的内容 ::: ::: {.column} 右侧栏目的内容 ::: :::::: 3.3.4.2 自定义模板 PowerPoint 幻灯片的模板可以用 reference_doc 来设置。 模板中的样式将会被应用到 R Markdown 生成的 PowerPoint 幻灯片中。 --- title: &quot;使用自己喜欢的 PowerPoint 模板&quot; output: powerpoint_presentation: reference_doc: my-styles.pptx --- 3.3.4.3 其它功能 PowerPoint 幻灯片从 HTML 文档中继承了目录内容、图片属性、样式、数据框打印、组件、 模板、Pandoc 参数和分享等功能（参加 3.1）。 目前并不支持播放列表项目时候的动画效果。 3.3.5 Xaringan 幻灯片 虽然 R Markdown 提供的基础幻灯片已经能够实现了基本的幻灯片功能，而且没有额外的学习成本， 但是，善于制作精良幻灯片的“忍者”通常使用一个额外的包来创建幻灯片，这个包的名字叫做 xaringan。 xaringan 这个名字来源于火影忍者中的写轮眼 “Sharingan” （图 3.16）13。写轮眼有两大能力： 洞察眼 催眠眼 其实做演示就是将自己的洞见传递给听众；好的演讲通常有催眠效果，因为它可以深度震撼人心14。 图 3.16: 幻灯忍者：写轮眼 与其它工具相比，xaringan 创建的幻灯片样式更加精美，功能更加丰富，且具有高度的可定制性（图 3.17）。 图 3.17: xaringan 幻灯片的实例 3.3.5.1 Xaringan 的安装和入门 要创建“写轮眼”幻灯片，需要先安装 xaringan 软件包(Xie 2022c)）。 if (!requireNamespace(&quot;xaringan&quot;)) install.packages(&quot;xaringan&quot;) 安装完成之后，在 RStudio 中新建 R Markdown 文件，并在左侧选择 “From Template”，然后选择 “Ninja Presentation (Simplified Chinese)”。填写必要信息之后，即可创建一个新的“写轮眼”幻灯片（图 3.18）。 图 3.18: 创建一个新文档 然后点击 Knit 按钮编译文档，或者点击 RStudio 插件 “Infinite Moon Reader” 在 RStudio 里实时预览幻灯片（每次保存文档的时候，它会自动重新编译）。 原理： xaringan 将 R Markdown 的查克拉注入了 remark.js。浏览器中的幻灯片是 remark.js 渲染出来的，而它的 Markdown 源文档是从 R Markdown 生成的（实际上主要是 knitr）。 3.3.5.2 Xaringan 幻灯片的自动播放 播放设置 nature 下面的 autoplay 选项可以用来自动播放幻灯片，它的取值是毫秒，例如：每 30 秒播放一张片子： output: xaringan::moon_reader: nature: autoplay: 30000 nature 下面的 countdown 选项可以为每一页幻灯片添加一个（倒数）计时器，取值同样为毫秒，例如每一页片子都用 60 秒倒计时： output: xaringan::moon_reader: nature: countdown: 60000 3.3.5.3 Xaringan 幻灯片的快捷键 点击按键 h 或者 ? 之后可以看到所有快捷键示意图（图 3.19） knitr::include_graphics(&quot;images/xaringan-help.png&quot;, dpi = NA) 图 3.19: 展示所有快捷键 p 进入演讲者模式（可以看见自己写的注释，比如：提醒自己要讲的笑话，图 3.20）。 图 3.20: 进入演讲者模式 点击按键 c 可以复制幻灯片到新窗口。演讲时可以在自己面前的屏幕上显示演讲者模式，把新窗口中正常的幻灯片拖到大屏幕投影上给观众看（见图 3.21）。 图 3.21: 复制幻灯片到新窗口 3.3.6 Xaringan 幻灯片的扩展包 3.3.6.1 配置 Xaringan 幻灯片的主题 Aden-Buie 写了一个叫做 xaringanthemer 包(R-xaringanthemer?)的包，可以更改写轮眼幻灯片的主题，使用起来也非常方便，接下来看教程。 可以从 CRAN 或者 Github安装 xaringanthemer 包。 # 通过 CRAN 安装 install.packages(&quot;xaringanthemer&quot;) # 通过 Github 安装 # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;gadenbuie/xaringanthemer&quot;) 创建完新文档后，将 xaringan-themer.css 文件添加到 xaringan 幻灯片的 YAML 中。 output: xaringan::moon_reader: css: xaringan-themer.css 然后，在 chunck 中加载 xaringanthemer 并 设置主题 即可。下面给出一个简单的例子（图 3.22）， 展示了设置主题后的界面预览。当然该包还给出了很多其他主题，下面给出一些主题模板预览。 library(xaringanthemer) style_mono_accent( base_color = &quot;#1c5253&quot;, header_font_google = google_font(&quot;Josefin Sans&quot;), text_font_google = google_font(&quot;Montserrat&quot;, &quot;300&quot;, &quot;300i&quot;), code_font_google = google_font(&quot;Fira Mono&quot;) ) 图 3.22: 主题设置后的界面预览 注意：在 chunck 头部中设置 include=FALSE, warning=FALSE 可以隐藏代码。 3.3.6.2 Xaringan 幻灯片自动匹配 ggplot 主题 xaringanthemer 包提供了 theme_xaringan() 函数，可用于修改 ggplot2 生成图片的主题，使图片与幻灯片主题中所配置的颜色和字体保持一致。 另外，xaringanthemer 建立在 showtext 包 (R-showtext?) 的基础上，可以使用更多的字体（包括系统提供的字体和网上的字体）。有关更多详细信息，可以在 ?scale_xaringan 和 vignette(“ggplot2-themes”)中找到（图 3.23）。 library(ggplot2) ggplot(diamonds) + aes(cut, fill = cut) + geom_bar(show.legend = FALSE) + labs( x = &quot;切割工艺质量&quot;, y = &quot;产品数量&quot;, title = &quot;钻石切割工艺质量与产品数量&quot;) + theme_xaringan(background_color = &quot;#FFFFFF&quot;) + scale_xaringan_fill_discrete() 图 3.23: 前面例子对应的 ggplot 配色 3.3.6.3 Xaringanthemer 的自动补全功能 xaringanthemer 包对 Tab 键十分友好，该功能可以在查找每个主题中调整模板的函数。对应的 gif 演示可见官网教程。 if (knitr::is_html_output()){ knitr::include_graphics(&quot;https://raw.githubusercontent.com/gadenbuie/xaringanthemer/assets/example-rstudio-completion.gif&quot;, dpi = NA) } 图 3.24: xaringanthemer 支持自动补全功能 3.3.6.4 Xaringanthemer 提供的可选主题 该包提供各式各样的主题模板，可以根据喜好选择自己想要的主题，在正文开头加入以下代码，就会得到相应的模板了！这里给出 6 个模板函数以及对应的界面预览图，更多模板可见https://pkg.garrickadenbuie.com/xaringanthemer/articles/themes.html。 记得在使用以下函数前，先加载 xaringanthemer 包。 style_mono_light() style_mono_light(base_color = &quot;#23395b&quot;) 图 3.25: Moon Light 模板 style_mono_dark() style_mono_dark(base_color = &quot;#cbf7ed&quot;) 图 3.26: Mono Dark 模板 style_mono_accent() style_mono_accent(base_color = &quot;#43418A&quot;) 图 3.27: Mono Accent 模板 style_mono_accent_inverse() style_mono_accent(base_color = &quot;#43418A&quot;) 图 3.28: Mono Accent Inverse 模板 style_duo() style_duo(primary_color = &quot;#1F4257&quot;, secondary_color = &quot;#F97B64&quot;) 图 3.29: Duo 模板 style_solarized_light() style_solarized_light() 图 3.30: Solarized Light 模板 3.3.6.5 扩展 xaringan 幻灯片的功能 xaringanExtra 包(R-xaringanExtra?) 扩展了 Xaringan 幻灯片的功能，涵盖了很多写轮眼的并不具备的常用功能，具体如下所示： 并列方式展示演示文稿 在线编辑演示文稿 分享幻灯片样式 通过广播向观众实时播放幻灯片 在演示幻灯片上进行涂鸦 幻灯片切换时有声音提示 加入幻灯片切换动画 将选项卡面板加入幻灯片中 给幻灯片添加全局 logo 添加搜索框 使用 Tachyons CSS 实用程序工具包 添加网络摄像头进行实时视频 使用剪贴板添加一键式代码复制 从幻灯片开始就播放 GIF 调整幻灯片的大小以填充浏览器窗口 添加额外的 CSS 样式 这里仅仅列出了一些平时使用比较多的功能，在项目的 官方网站 另外列出了该软件包更多的特性。 可以从 GitHub 安装最新版本的 xaringanExtra。 # install.packages(&quot;remotes&quot;) remotes::install_github(&quot;gadenbuie/xaringanExtra&quot;) 3.3.6.6 并列方式展示 Xaringan 幻灯片 使用方法：将以下代码块添加到幻灯片 R Markdown 文件中，之后对该 R Markdown 文件进行重新渲染。 ```{r xaringan-tile-view, echo=FALSE} xaringanExtra::use_tile_view() ``` 渲染后在幻灯片的放映界面中按 O 键（ Overview 的第一个字母）即可得到以下界面，再按 O 键即可回到默认形式。 图 3.31: 并列方式展示演示文稿 该功能类似 PowerPoint 中的幻灯片浏览模式。黄色的框表示当前所在的位置，可以通过鼠标直接切换到想要的位置。这个功能非常方便实用，而且操作简单，只要加入前面的代码就可以了。 3.3.6.7 在线编辑 Xaringan 幻灯片 这个功能无敌！可以在放映的幻灯片上直接书写内容，实时更新。主要是使用 .can-edit [...] 实现。 使用方法：只需将下面代码加入创建的 rmd 文档中： ```{r xaringan-editable, echo = FALSE} xaringanExtra::use_editable(expires = 1) ``` 使用 .can-edit[] 使幻灯片组件可编辑。 ## .can-edit[可以在此修改幻灯片的标题] 每当将幻灯片重新加载到浏览器中时，.can-edit 类的可编辑字段将被重置。如果要存储已编辑并使它们在浏览器会话之间持久存在，请为每个可编辑字段提供一个 .key-&lt;NAME&gt; 类。例如： ## .can-edit.key-firstSlideTitle[可以在此修改幻灯片标题并将修改后的标题保存到当前会话中] 对于更复杂的 HTML 元素，最好仅使一部分文本可编辑，例如 你好 .can-edit[张三]，欢迎光临！ 或者使用占位符文本。 ## 我所钟爱的东西 .can-edit.key-likes[ - 好东西甲 - 好东西乙 ] 官方给出了 gif 的演示。在教学的时候非常合适，可以增加与学生，观众的互动。 3.3.6.8 在 Xaringan 幻灯片上涂鸦 使用方法：只需在 rmd 文件中加入下面代码，重新编译即可得到这个效果。 ```{r xaringan-scribble, echo=FALSE} xaringanExtra::use_scribble() ``` 单击铅笔图标或按 S 键进行绘图。按 S 或启动绘图模式切换涂鸦工具箱。也可以使用橡皮擦来删除线条或单击“清除（trash）”按钮清除当前幻灯片上的所有涂鸦。 注意，当更改幻灯片时，图纸将保持在每张幻灯片上。在绘图模式下不能更改幻灯片。事实上，可以使用 ← 和→ 键来撤消或重做您的图纸。 如果想将幻灯片与涂鸦一起保存，最好的方法是从浏览器中打印演示文稿，官方给出了 gif 演示。 3.3.6.9 切换时 Xaringan 幻灯片时播放声音提示 使用方法：只需在 R Markdown 文件中加入下面代码，重新编译即可得到这个效果。当然，官方也给出了 gif 演示。 ```{r xaringan-slide-tone, echo=FALSE} xaringanExtra::use_slide_tone() ``` 3.3.6.10 Xaringan 幻灯片加入动画 使用方法：在 R Markdown 文件中加入下面代码 ```{r xaringan-animate-css, echo=FALSE} xaringanExtra::use_animate_css() ``` 然后将 animated 类和所需动画添加到对应的幻灯片中。下面给出一个代码的例子： 注意：退出动画只应用于退出时的幻灯片。 --- class: animated slideInRight fadeOutLeft ## 这张幻灯片将会…… - 一开始从屏幕右侧出现 - 并将会从屏幕左侧消失 这时，该张幻灯片将从右边滑入。如果想使所有幻灯片使用同一个转化形式，可以使用：use_animate_all()，代码如下（建议加到正文前部）。除此之外，官方给出了 gif 演示。 ```{r xaringan-animate-all, echo=FALSE} xaringanExtra::use_animate_all(&quot;slide_left&quot;) ``` 3.3.6.11 在 Xaringan 幻灯片使用选项卡 使用方法：在 R Markdown 文件中加入下面代码 ```{r xaringan-panelset, echo=FALSE} xaringanExtra::use_panelset() ``` 然后，创建一个包含若干个 .panel[] 的 .panelset [...]。每个 .panel [] 应该具有 .panel-name [] 和想写的内容，例如： .panel[.panel-name[NAME] 在此输入你的内容 ] 下面是演示幻灯片中使用的例子。 --- ## 我是庄闪闪 .panelset[ .panel[.panel-name[R Code] 欢迎关注[庄闪闪的R语言手册]呀！ ```{r panel-chunk,fig.align=&#39;center&#39;,out.width=&quot;60%&quot;} library(ggplot2) (g &lt;- ggplot(mpg) + aes(hwy, cty, color = class) + geom_point()) ``` ] .panel[.panel-name[Plot] &lt;center&gt;&lt;img src=&quot;https://octodex.github.com/images/labtocat.png&quot; height=&quot;300&quot; /&gt;&lt;/center&gt; ] ] 图 3.32 给出了上面代码的结果。官网给出了 gif 演示。 图 3.32: 将选项卡面板加入幻灯片中 要定制面板的外观，可以使用直接在幻灯片的 R 块中调用 style_panelset_tabs()。将下面代码加到前面的代码块下，这时代码块的颜色发生了变化。 ```{r echo=FALSE} xaringanExtra::style_panelset_tabs(foreground = &quot;honeydew&quot;, background = &quot;seagreen&quot;) ``` 3.3.6.12 给 Xaringan 幻灯片添加 LOGO 使用方法：在 R Markdown 文件中加入下面代码 ```{r xaringan-logo, echo=FALSE} xaringanExtra::use_logo( image_url = &quot;https://gitee.com/zhuang_liang_liang0825/other/raw/master/%E6%B8%A9%E5%B7%9E%E5%A4%A7%E5%AD%A6logo.png&quot; ) ``` 这时，所有幻灯片右上角都加上了对应的 LOGO 啦！如果想在某几张不显示 LOGO，可以使用 hide_logo 隐藏特定幻灯片的徽标，具体例子如下（图 3.33）： 图 3.33: 给幻灯片添加全局 logo 3.3.6.13 播放 Xaringan 幻灯片时使用摄像头 使用方法：在 R Markdown 文件中加入下面代码，然后重新渲染。 ```{r xaringan-webcam, include = FALSE} xaringanExtra::use_webcam() ``` 之后点击 w 键（记得用浏览器打开哦！）就会得到以下界面（图 3.34）。这里镜头的位置可以任意拖动。 图 3.34: 添加网络摄像头进行实时视频 当通过视频会议进行陈述时，包括演讲者的视频，或者在录制一节课或讲座时，这个功能真的非常好用！ 3.3.6.14 调整 Xaringan 幻灯片的大小 使用方法：在 R Markdown 文件中加入下面代码，然后重新渲染。 ```{r xaringan-fit-screen, echo=FALSE} xaringanExtra::use_fit_screen() ``` 使用快捷键 Alt / Option + F 使幻灯片适合屏幕，并忽略幻灯片比例（重新加载幻灯片以恢复正常）。官网给出了 gif 的演示。 3.4 Word 文档 要从 R Markdown 生成 Word 文档，可以使用输出格式 word_document。如果希望在文档中包含交叉引用，可以考虑输出格式 bookdown::word_document2，详细说明可见这。 --- output: word_document: default bookdown::word_document2: default # for cross-references --- 关于 Word 输出的最常见问题有： 如何将自定义 Word 模板应用于文档？ 如何在原始 R markdown 文件中纳入 Word 中所做的更改？ 如何更改单个文档元素的样式？ 本章将一一解答以上问题。 3.4.1 创建 word 模板 在 Rstudio 中打开一个新的 R 脚本并选择 Ducument 中的 Word（图 3.35）。 图 3.35: 新建 R Markdown 时可选的 word 格式 这时对应 R Markdown 文档中的 YAML 头所包含的内容为： --- title: &quot;标题&quot; author: &quot;张三&quot; date: &quot;6/26/2021&quot; output: word_document --- 之后就可以在这个模板下，将正文部分进行修改，并通过 Knit 进行编译。之后会跳出编译好的结果，通过系统默认应用打开。这就是基于 word 模板的工作流程。 3.4.2 自定义 Word 模板 可以将 Word 模板 文档中定义的样式应用到从 R Markdown 生成的新 Word 文档。 这种模板文档也称为“参考样式文档”。 关键之处：必须先通过 Pandoc 创建此模板文档，再更改其中的样式定义。 然后将此模板的路径传递给 word_document 的 reference_docx 选项，例如： --- output: word_document: reference_docx: &quot;template.docx&quot; --- template.docx 文档必须从 Pandoc 生成。 可以从具有 word_document 输出格式的任意 R Markdown 文档创建此模板（该文档的实际内容无关紧要，但它应该包含想要设置样式的元素类型）。 然后打开.docx 文件，并编辑样式。 图 3.36: 查找特定文档元素的样式。 图 3.36 说明了可以通过 Word 中的“主页”选项卡打开“样式”窗口。当将光标移动到文档中的特定元素时，样式列表中的项目将被突出显示。如果想修改任何类型元素的样式，可以单击突出显示项的下拉菜单，将看到如图 3.37 的对话框。 图 3.37: 修改 Word 文档中元素的样式。 修改完样式后，可以保存文档（使用一个不会被意外覆盖的文件名），并将其作为以后 Word 文档的模板。 当 Pandoc 使用该参考模板，并渲染出新的 Word 文档时，它会读取模板中的样式并将它们应用到新文档中。 如果想了解更多关于如何创建自定义样式 Word 模板的详细教程的话。可以观看一段短视频 https://vimeo.com/110804387，或者阅读这篇文章 https://rmarkdown.rstudio.com/articles_docx.html。 有时，查找元素的样式名称并不简单，可能有多种样式应用于同一个元素，并且只会在样式列表中看到其中一个突出显示。这时，可能需要通过猜测或在线搜索才能确定要修改的实际样式。例如：需要点击“管理样式”按钮 （图3.36 中样式列表底部从左到右的第三个按钮）。之后找到对应的样式并进行修改，例如，添加边框 （见图 3.38）。 图 3.38: 修改 Word 文档中的表格样式。 3.4.3 R Markdown 和 Word 之间的双向工作流程 虽然从 R Markdown 生成 Word 文档很容易，但当其他人编辑 Word 文档并且必须手动将更改移植回原始 R Markdown 时，事情会变得特别痛苦。幸运的是，Noam Ross 为这个问题提供了一个非常不错的解决方案。 redoc 包 (https://github.com/noamross/redoc) 允许生成和修改一个 Word 文档，并将修改后的 Word 文档转换回 R Markdown。 注意，截至撰写本文时（2020 年 6 月），redoc 包仍处于测试阶段，并且作者已暂停开发。如果想尝试一下，可以从 GitHub 安装这个包： remotes::install_github(&quot;noamross/redoc&quot;) 安装包后，在输出格式中加入 redoc::redoc: --- output: redoc::redoc --- 这种输出格式会生成一个 Word 文档，实际上存储的是原始 Rmd 文档，因此可以将 Word 文档转换回 Rmd。 Word 中的跟踪更改将转换为使用 CriticMarkup 语法 (http://criticmarkup.com) 编写的文本。 例如，{++ important ++} 表示在文本中插入“重要”一词。 可以通过 redoc::dedoc() 函数将 redoc::redoc 生成的 Word 文档转换为 Rmd，例如 redoc::dedoc(\"file.docx\") 会生成 file.Rmd。 在此过程中，可以通过“track_changes”参数决定如何处理 Word 中的跟踪更改，例如，可以接受或拒绝更改，或将跟踪更改转换为 CriticMarkup。 建议使用 track_changes = 'criticmarkup' 以避免跟踪更改的永久丢失。 在编辑 Word 文档时，应该编辑_不是_由 R Markdown 中的代码块或内联 R 表达式自动生成的部分。 例如，如果表是由代码块中的 knitr::kable() 自动生成的，则不能编辑它，因为当通过 dedoc() 将 Word 转换为 Rmd 时，此类更改将丢失。为避免意外编辑代码块的自动结果，可以在 redoc::redoc 格式中将选项 highlight_outputs 设置为 true，这意味着自动输出的内容将在 Word 中突出显示（带有背景颜色）。 换句话说，就是告诉的合作者，他们不应触碰 Word 文档中这些突出显示的部分。 注意： redoc 包仍处于测试阶段，目前还不清楚它的未来，所以这里的介绍较为简短。如有疑问，建议阅读 GitHub 上的文档。 3.4.4 个人风格元素 由于 Markdown 的简单性，可以将一些全局样式应用到 Word 文档中（参见 3.4.1 部分），但是对单个元素进行样式设置并不简单，例如：更改单词的颜色、段落居中。 为了在 R 中处理 Office 文档更加容易，David Gohel 于 2018 年开始开发 officedown 包 (Gohel and Ross 2022)，目的是在 R Markdown 中加入一些 officer (Gohel 2022) 特性。 在撰写本文时，该软件包原始版本已在 CRAN 上发布，但仍处于测试阶段。 可以从 CRAN 或 GitHub 安装它： # 通过 CRAN 来安装 install.packages(&quot;officedown&quot;) # 或者通过 GitHub 安装 remotes::install_github(&quot;davidgohel/officedown&quot;) 安装包后，在 R Markdown 文档中通过以下代码加载它： ```{r, setup, include=FALSE} library(&quot;officedown&quot;) ``` officedown 包中输出格式为 rdocx_document，默认情况下，是基于 rmarkdown::word_document 并具有其他一些功能，例如：样式表和绘图。该包还允许通过 officer 包设置特定 Word 元素的样式。 例如，可以通过 officer::fp_text() 函数 创建样式，并通过内联 R 表达式 ftext() 将样式应用于一段文本： --- title: 带有officedown的样式文本 output: officedown::rdocx_document: default --- ```{r} library(officedown) library(officer) ft &lt;- fp_text(color = &#39;red&#39;, bold = TRUE) ``` # 检验 **officedown** 包是 `r ftext(&#39;awesome&#39;, ft)`! 除了 officer 中的功能，officedown 还允许使用一些特殊的 HTML 注释来执行 officer 任务。 例如，函数 officer::block_pour_docx() 可用于将外部 Word 文档 导入当前文档，或者可以使用 R Markdown 中的 HTML 注释： &lt;!---BLOCK_POUR_DOCX{file: &#39;my-file.docx&#39;}---&gt; 这相当于内联 R 表达式： `r block_pour_docx(file = &#39;my-file.docx&#39;)` 通过使用 officedown 和 officer 包还可以进行其他操作： 插入分页符； 将内容放在多列布局中； 更改段落设置； 插入目录； 更改页面方向（横向或纵向）。 如果想了解更多有关 officedown 的信息，可以通过以下文档 https://davidgohel.github.io/officedown/ 查阅信息。 3.5 创建新的文档格式 作为实现 R Markdown 技术最重要的软件包之一，rmarkdown 软件包中已经包括了很多 文档和演示文稿的输出格式。这些文档格式的背后，本质上仍然是一些 R 语言的函数。当 在 YAML 区块中指定输出格式的时候，实际上是在调用相应的函数并将函数的参数传递给它。 因此，也可以通过自定义一个新的函数来创建新的文档格式。新文档格式的函数通常需要 整合到新的 R Markdown 文档模板中去（参见第 ?? 章）。这是因为 文档模板是通过 R 语言软件包创建的，原本就可以加入新的函数。于是，通过 R 语言的软件包， 就实现了文档格式和模板的分发。这也是现有的 R Markdown 文档格式、模板的一贯做法15。 3.5.1 从现有文档格式衍生新格式 创建新的文档格式最简单的办法就是基于现有的文档格式衍生出新的文档格式。rmarkdown 内嵌的文档格式都是高度可定制的，包含众多可用参数。只需要为这些参数赋值，就可以创建 出一个新的文档格式出来。 下面的例子创建了一个新的文档格式函数 quarterly_report 以进行季度报告。 这个函数是基于 rmarkdown 的内嵌函数 html_document 工作的。 quarterly_report = function(toc = TRUE) { # 查找软件包的安装位置 pkg_resource = function(...) { system.file(..., package = &quot;mypackage&quot;) } # 在软件包的子目录中找到新文档格式依赖的文档模板 css = pkg_resource(&quot;reports/styles.css&quot;) header = pkg_resource(&quot;reports/quarterly/header.html&quot;) # 调用 html_document 函数并指定其参数 rmarkdown::html_document( toc = toc, fig_width = 6.5, fig_height = 4, theme = NULL, css = css, includes = rmarkdown::includes(before_body = header) ) } 这个新的输出格式实现了下列几项功能： 提供了一个参数 toc 来决定是否显示文档目录（参数最后被传递给了 html_document）； 指定了图片默认的长度和高度（这可以避免文档中的图片出现大小参差不齐的现象）； 指定了一个新的 CSS 样式表，同时也禁用了默认的 Bootstrap 主题样式表； 在每一份文档中都添加了一个标准的头文件。 值得一提的是，第 3 项和第 4 项功能依赖于软件包提供的外部文件。也就是说， 在 quarterly_report 函数中，分别获取了 \"mypackage\" 的软件包中携带的 CSS 文件和 一个 HTML 文档，然后分别将 CSS 定义传递给了 html_document 函数的 css 和 includes 参数。在这里，后者使用了一个 rmarkdown::includes() 函数，从而将这个 HTML 文档（片段） 作为文档 before_body 的内容嵌入到使用该格式的文档中去。 3.5.2 完全的自定义输出格式 在基于现有格式衍生新输出格式之外，也可以从底层出发创建出一个完全的新格式。 为此需要了解文档格式的底层工作原理，简单来说 R Markdown 的输出格式 由下列几个部分构成： 一系列的参数来确保 knitr 将 Rmd 文件正确的编译为 Markdown 格式的文档； 另外的一些参数来指导 Pandoc 将 Markdown 文档转换为其它输出格式（如 HTML）； 其它的一些标记或过滤器（通常用于处理输出格式的支持文件）。 可以使用 rmarkdown 软件包中的函数 output_format() 来创建一个新的输出格式。 下面是一个例子： simple_html_format = function() { # 这里使用了完整的引用方式来使用 output_format、knitr_options 和 # pandoc_options 等 3 个函数。 rmarkdown::output_format( knitr = rmarkdown::knitr_options(opts_chunk = list(dev = &#39;png&#39;)), pandoc = rmarkdown::pandoc_options(to = &quot;html&quot;), clean_supporting = FALSE ) } 在这个函数中，knitr 和 Pandoc 的参数分别由两个参数指定，其内容可以相当的复杂 （参见 ?rmarkdown::knitr_options 和 ?rmarkdown::pandoc_options 了解更多）。 而 clean_supporting 则控制是否清理文档编译过程中使用的临时文件。 output_format() 函数中还有一个 base_format 参数用来指定一个原有的输出格式， 并在此基础上进行配置（相当于衍生格式）。 如果有其它的一些支持文件无法通过 includes 参数指定，那么还需要使用 output_format() 中的其它参数来帮助处理这些文件（例如，使用 intermediates_generator 来讲它们拷贝 到文档的输出目录中去）。 学习创建一个新的文档输出格式最好的方法可能是阅读原有格式的源代码。从 rmarkdown 的 html_document 和 pdf_document 开始是个不错的主意，其源代码的位置在 https://github.com/rstudio/rmarkdown/tree/master/R。如果新格式需要用到 Pandoc 模板，则请参见 ?? 及 Pandoc 的使用手册。 3.5.3 使用新的文档输出格式 新的文档格式在创建完成后，需要安装到用户的本地环境中去（参见 ??）。 这样新的输出格式便可以通过 YAML 区块来应用。加入一个 名为 mypackage 的软件包中的 quarterly_report （假设该软件包已经安装成功），那么： --- title: &quot;文档标题&quot; output: mypackage::quarterly_report: toc: true --- 这里面就设置了新的输出格式，并且将 toc 参数传递给了 quarterly_report() 函数。 参考文献 "],["rmarkdown-working.html", "第 4 章 基于 R Markdown 工作与学习 4.1 发邮件：blastula 4.2 制作 R 包：fusen 4.3 制作简历：datadrivencv 4.4 写书和记学习笔记：bookdown 4.5 制作网站：blogdown 4.6 制作科技论文的支撑材料", " 第 4 章 基于 R Markdown 工作与学习 4.1 发邮件：blastula 4.2 制作 R 包：fusen 4.3 制作简历：datadrivencv 4.4 写书和记学习笔记：bookdown 4.5 制作网站：blogdown 4.5.1 blogdown 简介 在当今的互联网时代世界，无论从事什么职业，个人网站几乎成为了一张人手必备的的“电子名片”。谢益辉开发的 blogdown 包提供了一种功能全面，且设置简单快速的个人网站架设途径。 基于 Rmarkdown 的 blogdown 包为个人用户提供一种轻便快速的建立个人静态网站的方案。不同于市面上多数的网站建立方案，静态网站有着众多好处，如文件体型小，铺设速度快，所以更换服务器时更加省时省力。与此同时，blogdown 依赖 R Markdown 文件为基础来生成网站。而 R Markdown 文件本身支持众多强大功能，包括文本的书写，编辑与排版（包括对 \\(LaTeX\\) 的支持），数据分析，交互性插件（如交互性图表）等。 本书的这个小节将通过一个对新手十分友好的案例来手把手的展示如何快速建立一个可满足日常基本需求的网站，以便用户可快速上手 R 的 blogdown 包。 4.5.2 具体操作 4.5.2.1 安装 blogdown 在开始之前，用户需要确认个人主机已经安装最新版本的 R 和 RStudio。 首先，通过以下一行命令从 CRAN 安装 blogdown 包： # 安装 blogdown install.packages(&quot;blogdown&quot;) 4.5.2.2 创建项目 一个网站可被视为一个 R 项目。想要创建一个新的网站项目，只需要按照下图提示，在 RStudio 菜单栏依次选择文件，新项目，新目录 （File -&gt; New Project -&gt; New Directory）。完成后，选择用 blogdown 建设网站 （Website using blogdown），即可看到一个网站项目的具体设置界面。 图 4.1: 在 RStudio 中创建一个新网页项目 图 4.2: 基于 blogdown 创建一个新网页项目 设置好目录名，只需点击创建项目（Create Project），RStudio 即会通过 blogdown 包来自动生成一个网站项目。 4.5.2.3 网站铺设 用户可以便捷的通过 RStudio 的基础功能在本地浏览自己的网页项目。用户既可以直接在控制台 （Console） 键入 blogdown::serve_site()，或在 RStudio 上方的插件 （Addins） 选项选择铺设网站 （Serve Site）。 图 4.3: 通过控制台在本地浏览你的网站 图 4.4: 通过插件的铺设选项在本地浏览你的网站 然后 RStudio 应会显示与下图相似的页面。 图 4.5: 在本地铺设网站 显示本地铺设成功后，用户既可以通过图形交互页面，点击在本地浏览器打开（在 RStudio 右上角的 Show in new window）来通过本地浏览器在本地浏览刚刚编辑好的网页。只要网页项目在本地浏览器中被打开后，之后任何在源文件上的改动都会自动在浏览器中进行实时加载，所以并不需要在每次改动后重复点击铺设 (knit) 网站。 4.5.2.4 内容编辑 位于 RStudio 的右下角，用户可以通过进入内容 content 文件夹来查看并编辑当下网站项目的所有内容页。作为一个初始例子，这里首先打开 2020 年 12 月 01 日的一个文件 content/post/2020-12-01-r-rmarkdown/index.Rmd。 可以注意到，打开的 Rmarkdown/Rmd 文件的最上方是含有标题 title，作者 author 等字眼的代码部分，而这个部分被称为 YAML 代码区 （用于设定网页形态）。 当编辑具体网页内容时，用户只需要在 YAML 代码区下方的空白部分进行编写即可。 接下来，这里展示如何在网页中添加代码。如下图所示，只需添加一个 R 代码块，然后输入以下内容，代码就会自动展示在网页上。 library(ggplot2) summary(Orange) ## Tree age circumference ## 3:7 Min. : 118.0 Min. : 30.0 ## 1:7 1st Qu.: 484.0 1st Qu.: 65.5 ## 5:7 Median :1004.0 Median :115.0 ## 2:7 Mean : 922.1 Mean :115.9 ## 4:7 3rd Qu.:1372.0 3rd Qu.:161.5 ## Max. :1582.0 Max. :214.0 ggplot(Orange, aes(x = age, y = circumference, color = Tree)) + geom_point() + geom_line() + guides(color = FALSE) + theme_bw() 此时，如果编辑中的网站项目已经在本地浏览器中打开，用户只需要点击左上角的保存，几秒后即可在浏览器内看到如下图的内容。如果此时用户并没有在本地浏览网页，点击编译 knit，网站便会在本地的 RStudio 自动生成。 图 4.6: 给 Rmd 文件添加 R 代码 4.5.2.5 网站配置 除了通过编辑 Rmd 文件来实现网站内容的编辑外，用户还可以通过修改 config.yaml 文件内的设定来自定义自己的网站。 例如，打开 config.yaml 文件后，用户可能会看到如下内容： baseurl: / title: A Hugo website theme: hugo-lithium ignoreFiles: - \\.Rmd$ - \\.Rmarkdown$ - _cache$ - \\.knit\\.md$ - \\.utf8\\.md$ permalinks: post: /:year/:month/:day/:slug/ menu: main: - name: About url: /about/ - name: GitHub url: https://github.com/rstudio/blogdown - name: Twitter url: https://twitter.com/rstudio 只需在相应的部分进行编辑，用户就可以根据个人的需求自定义自己的网站，如： title: 我的网站 ：将网站标题修改为“我的网站” name: Weibo url: 你的微博url ：在菜单中添加个人 Weibo 信息页面的链接 4.5.2.6 小结 目前为止，此节已经展示了如何创建并编辑一个个人化 blogdown 网站的三条基本知识： 通过 RStudio 的铺设 Serve Site 功能 或在控制台内键入 blogdown::serve_site() 来在本地浏览自己的网站。 通过编辑 config.yaml 文件来自定义自己的网站（标题，菜单栏，主题等）。 通过编辑处于目录夹中 content 文件夹内的 Rmd 文件来编辑具体的网页信息。通过进阶的学习，用户还可以通过修改自定义 Rmd 文件的位置来改变他们在网站上显示的结构。 4.5.2.7 部署 那么下一步是什么？选择自然有很多，但最重要的莫过于通过部署编辑完成的网站，以便让他人可以通过互联网直接浏览网站上的内容。 就像之前简短提到过的，因为静态网站本质上就是一个文件夹，所以静态网站与大多数动态网站相比较的一个重要优点就是部署更加简单且快速。那么如何选择用于部署的服务器呢？权衡过上手友好度以及性价比后，Netlify (https://www.netlify.com/) 是一个很不错的选择。 4.5.2.8 Netlify Netlify 提供的免费服务功能多元，足够满足大多数用户的需求，且部署也十分简单。就算用户之前没有部署网站的经验，也只需创建一个 Github 账户，并使用此账户注册并登陆属于用户个人的 Netlify 账户。登陆成功后，只需将网站项目目录中由 blogdown 生成的名为公共 Public/ 的文件夹拖入 Netlify 部署页面即可。 图 4.7: 在网站项目文件夹中找到名为Public的文件夹 图 4.8: 将此文件夹拖拽入部署页面的部署区域即可完成部署 一般只需几秒钟，网站就会被成功部署在 Netlify 的服务器上，并可以通过一个格式为 random-word-12345.netlify.com 的域名访问。此域名是 Netlify 自动生成的一个子域名，并支持通过设置修改至自己偏好的字眼。Netlify 提供的一体化部署服务省去了用户在其他服务器上实现自定义设置时往往需要面对的许多麻烦。 不过需要注意的是，每次在本地的 RStudio 编辑完个人网站后，用户需要在控制台输入以下代码来更新你的公共文件夹 Public/。只有在更新完成后，才可以通过在 Netlify 上次最新版本的 Public/ 文件夹来部署你改动过后的网站。 blogdown::build_site() 4.6 制作科技论文的支撑材料 "],["rmarkdown-interaction.html", "第 5 章 使用 R Markdown 创建动态交互文档 5.1 Web 交互界面：Shiny 小程序 5.2 交互式仪表盘：Dashboards 5.3 在 R package 中使用 R Markdown", " 第 5 章 使用 R Markdown 创建动态交互文档 5.1 Web 交互界面：Shiny 小程序 Shiny 小程序是由 R 驱动的交互式 Web 应用程序。基于 Shiny 的 Web 应用程序（Shiny App）用途十分广泛，功能也很强大，实现的方式也多种多样。本书主要介绍与 R Markdown 文档应用相关的一部分知识，欲了解更多请参见 Shiny 官网。 Shiny 包是由 R 驱动的交互式 Web 应用程序。如果读者想从 R Markdown 文档中调用 Shiny 代码，只需在 YAML 元数据中添加 runtime: shiny 即可。由于 Shiny 构建 Web 应用程序功能十分强大，本书只介绍部分的 Shiny 知识。在阅读本章之前，如果不了解该包，可以先通过以下网站 https://shiny.rstudio.com 进行大致了解。 5.1.1 入门指南 在 YAML 元数据中加入 runtime: shiny，可以将任何基于 html 的 R Markdown 文档变成 Shiny 文档，例如： --- title: &quot;Shiny Document&quot; output: html_document runtime: shiny --- 注意，R Markdown 文档的输出格式必须是 HTML 格式。也就是说，文档最后生成的是一个 Web 页面（*.html 文件）。 注意： 非 html 格式，如 pdf_document 和 word_document 将不能与 Shiny 同时运行。另外，一些演示格式也是 HTML 格式，比如ioslides_presentation 和 slidy_presentation，它们是可以与 Shiny 相结合的。 当然，也可以通过 RStudio 构建一个新的 Shiny 文档。步骤如下：File -&gt; new File -&gt; R Markdown 并选择 Shiny，具体见图 5.1。 图 5.1: 在 RStudio 中创建一个新的 Shiny 文档。 如果读者想在 RStudio 中运行 Shiny 文档，需要单击工具栏上的 “Run Document” 按钮（当 RStudio 检测到这是 Shiny 文档时，它会自动将 Knit 按钮替换为 Run Document）。如果读者没有使用 RStudio，或者想在 R 控制台运行文档进行故障排除，可以调用函数 rmarkdown::run() 并将文件名传递给它。 可以在文档中嵌入 Shiny 的输入和输出。如果输入发生变化时，输出将自动更新。例如，创建一个名称为 rows 的数字输入（ numericInput ），然后在输出中通过 input$rows 引用其值： ```{r, echo=FALSE} numericInput(&quot;rows&quot;, &quot;How many cars?&quot;, 5) renderTable({ head(cars, input$rows) }) ``` 图 5.2: 增加 Shiny 文档中表中的行数。 在上面的示例中，输出代码包含在 renderTable() 中。 Shiny 中还有许多其他渲染功能，可用于图片、结果输出等。 下面使用 renderPlot() 输出可交互柱状图： ```{r, echo=FALSE} sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, 30, min = 1, max = 50) renderPlot({ x = faithful[, 2] # Old Faithful Geyser data bins = seq(min(x), max(x), length.out = input$bins + 1) # 用指定的格子大小绘制可交互的直方图 hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) ``` 图 5.3: Shiny 文档输出可交互的直方图。 5.1.2 Shiny 部署 如果在本地运行一个 Shiny 文档时，默认情况下它会使用本地 R 会话，并且只有运行的人能与该文档进行交互。如果希望与没有安装 R 的用户共享文档，或者不希望在本地运行文档，则必须将文档部署到服务器上，并共享文档的 URL。那么其他人只需要一个 web 浏览器就可以访问你的文档。 有两种方法可以部署 Shiny 文档。1. 使用 RStudio 提供的托管服务；2. 搭载到自己的服务器上。 5.1.2.1 ShinyApps.io 读者可以把 Shiny 文档发布到 ShinyApps (https://shinyapps.io) 进行托管。 需要满足以下两个条件： 在 ShinyApps 上注册账号。 安装了最新版本的 rsconnect 包。安装方式如下： install.packages(&quot;rsconnect&quot;) 然后，对需要部署的 Shiny 文档所对应的工作目录中执行以下语句： rsconnect::deployApp() 如果使用的是 RStudio，在运行 Shiny 文档时，也可以使用窗口右上角的 Publish 按钮(图 5.4)。 图 5.4: 部署 Shiny 文档到 ShinyApps.io. 上。 如果目录中有一个名为 index.Rmd 的文件，它将用作该目录的默认文档。如果想访问 Rmd 文档，则应在 URL 中指定 Rmd 文件的显式路径。 例如，部署到 ShinyApps 的 index.Rmd 的 URL 可以采用以下形式 https://example.shinyapps.io/appName/，而 test.Rmd 的 URL 可以采用以下形式 https://example.shinyapps.io/appName/test.Rmd。 5.1.2.2 Shiny Server / RStudio Connect 除此之外，Shiny Server （https://www.rstudio.com/products/shiny/shiny-server/） 和 RStudio Connect（https://www.rstudio.com/products/connect/） 都可以发布 Shiny 文档，但是读者需要熟悉有关 Linux 的知识。由于该内容较为复杂与丰富，超出本书读者的需求，所以在此不做过多介绍。 5.1.3 嵌入 Shiny 应用程序 除了在 R Markdown 中嵌入单个 Shiny 的输入和输出外，还可以在文档中嵌入一个独立的 Shiny 应用程序。有两种方法可以做到这一点： 使用 shinyApp() 函数内部定义应用程序; 使用 shinyAppDir() 函数引用外部应用程序。 注意：这两个函数在 shiny 包中，当在 YAML 元数据指定 runtime: shiny 时，它们会被自动加载。因此，读者不必调用 library(shiny) 来加载 shiny。 5.1.3.1 内部定义应用程序 下面例子将 Shiny 应用程序写在了 Rmarkdown 内部中： ```{r, echo=FALSE} shinyApp( ui = fluidPage( selectInput(&quot;region&quot;, &quot;Region:&quot;, choices = colnames(WorldPhones)), plotOutput(&quot;phonePlot&quot;) ), server = function(input, output) { output$phonePlot = renderPlot({ barplot(WorldPhones[,input$region]*1000, ylab = &quot;Number of Telephones&quot;, xlab = &quot;Year&quot;) }) }, options = list(height = 500) ) ``` 注意：使用 height 参数来确定嵌入式应用程序应该占用多少高度。 5.1.3.2 外联应用程序 下面例子展示嵌入了一个定义在另一个目录中的 Shiny 应用程序。 ```{r, echo = FALSE} shinyAppDir( system.file(&quot;examples/06_tabsets&quot;, package=&quot;shiny&quot;), options = list(width = &quot;100%&quot;, height = 700) ) ``` 注意：在上面的所有代码块中，都使用了 echo = FALSE 的选项。这是防止代码块中的 R 代码与 Shiny 组件一起呈现到输出文档中。 5.1.4 Shiny 小部件 Shiny 小部件使你能够使用一个函数调用创建包含在 R Markdown 文档中的可重复使用的 Shiny 组件。还可以直接从控制台调用 Shiny 小部件(在创作过程中很有用)，并在 RStudio Viewer 窗格或外部 Web 浏览器中显示它们的输出。 5.1.4.1 shinyApp() 函数 Shiny 窗口小部件的核心是使用 shinyApp() 函数创建的微型应用程序。 你无需像传统的 Shiny 应用程序那样，既要创建用户界面（UI），又要创建服务器端（Server）。而是将 UI 和 Server 定义作为参数传递给 shinyApp() 函数。 本书会在第 5.1.3.1 节中给出了一个示例。 接下来，先给出最简单的 Shiny 小部件类型———返回 shinyApp() 的 R 函数。 5.1.4.2 例子：k-means 聚类 rmdexamples 包 (https://github.com/rstudio/rmdexamples) 包含以上形式实现的 Shiny 小部件示例。 kmeans_cluster() 函数接受单个数据集（dataset）参数，并返回一个小部件来显示 k-Means 聚类的结果。读者可以在 R Markdown 文档中使用它： ```{r, echo = FALSE} library(rmdexamples) kmeans_cluster(iris) ``` 图 5.5 展示了在运行文档时小部件的样子。 图 5.5: 在数据集上应用 k-Means 聚类的 Shiny 小部件。 下面是 kmeans_cluster() 函数的源代码： kmeans_cluster = function(dataset) { library(shiny) vars = names(dataset) shinyApp( ui = fluidPage( fluidRow(style = &quot;padding-bottom: 20px;&quot;, column(4, selectInput(&#39;xcol&#39;, &#39;X Variable&#39;, vars)), column(4, selectInput(&#39;ycol&#39;, &#39;Y Variable&#39;, vars, selected = vars[2])), column(4, numericInput(&#39;clusters&#39;, &#39;Cluster count&#39;, 3, min = 1, max = 9)) ), fluidRow( plotOutput(&#39;kmeans&#39;, height = &quot;400px&quot;) ) ), server = function(input, output, session) { # 将选定的变量组合到一个新的数据框中 selectedData = reactive({ dataset[, c(input$xcol, input$ycol)] }) clusters = reactive({ kmeans(selectedData(), input$clusters) }) output$kmeans = renderPlot(height = 400, { res = clusters() par(mar = c(5.1, 4.1, 0, 1)) plot(selectedData(), col = res$cluster, pch = 20, cex = 3) points(res$centers, pch = 4, cex = 4, lwd = 4) }) }, options = list(height = 500) ) } 5.1.4.3 小部件的大小和布局 Shiny 小部件可以嵌入在不同的地方，包括标准的全宽页面、页面内的小列，甚至在 HTML5 幻灯片中。为了让小部件的大小和布局在上文所述的文档中稳定工作，作者建议小部件的总高度不高于 500 像素。当然，还可以在创建小部件的函数中添加一个显式的 height 参数（默认值为 500）。 5.1.5 Shiny 文档间的链接 可以使用 Markdown 链接语法并指定文档的相对路径，链接到其他 Shiny 文档上，例如： [另一个Shiny文档](another.Rmd)。如果在一个页面上单击指向另一个 Rmd 文档的链接，该 Rmd 文档将作为当前交互式 Shiny 文档启动。 默认情况下，只能链接到调用 rmarkdown::run() 的文件所在目录中的 R Markdown 文件(例如，你无法连接到 ../foo.Rmd)。 但是，可以使用 rmarkdown::run() 的 dir 参数来定义根目录。 5.1.6 Shiny 文档的渲染 5.1.6.1 延迟渲染 Shiny 文档通常在每次 R Markdown 文档渲染时都会显示。这时，较大或计算量较大的文档可能需要一些时间来加载。 如果文档包含不需要立即渲染的交互式 Shiny 组件，你可以在 rmarkdown::render_delayed() 函数中封装 Shiny 代码。这个函数保存它的参数，直到文档呈现完成并显示给用户，然后计算它，并在计算完成时将其注入输出文档。 例如，以下代码中，首先渲染出数值输入的结果，加载完文档并显示给用户之后， render_delayed() 才会执行内部代码，并将其加载到文档中。 ```{r, echo = FALSE} numericInput(&quot;rows&quot;, &quot;How many cars?&quot;, 5) rmarkdown::render_delayed({ renderTable({ head(cars, input$rows) }) }) ``` 5.2 交互式仪表盘：Dashboards 本节将介绍通过 flexdashboard 包 (Iannone, Allaire, and Borges 2020) 设计一个仪表盘的方法。 仪表盘在业务风格的报告中特别常见。它们可以用来展示报告的概要和关键内容。仪表盘的布局通常是基于网格搭建的，各个组件排列在各种大小的“盒子”中。 使用 flexdashboard 包，读者可以 通过 R Markdown，展示一组数据的可视化图表。 嵌入各种各样的组件，包括 HTML 小部件、R 图形、表格数据和文本注释等内容。 可以指定按行或列进行布局(各组件会自动调整大小以填满浏览器，并且在移动设备上也十分适配)。 可以创建区域来呈现可视化图形和相关注释。 使用 Shiny 驱动动态可视化图表。 5.2.1 Dashboards 入门 首先，安装 flexdashboard 包： install.packages(&quot;flexdashboard&quot;) 其次，通过点击 File -&gt; New File -&gt; R Markdown 对话框在 RStudio 中创建文档，并选择 “Flex Dashboard” 模板。操作界面如图 5.6 所示： 图 5.6: 创建新的 dashboard 文件。 注：如果没有使用 RStudio 进行操作，那么你也可以从 R 控制台创建一个新的 flexdashboard 的 R Markdown 文件，具体操作如下： rmarkdown::draft( &quot;dashboard.Rmd&quot;, template = &quot;flex_dashboard&quot;, package = &quot;flexdashboard&quot; ) 本章只介绍一些基本特性和用法。如果读者想更进一步了解 flexdashboard，可以查看它的完整文档： https://rmarkdown.rstudio.com/flexdashboard/ 。 仪表盘有许多与 HTML 文档相同的特性，比如图形选项，外观和风格，MathJax 公式，头部和正文前后内容和 Pandoc 参数，等等。除此之外，也建议浏览 R 帮助页面 ?flexdashboard::flex_dashboard 来了解更多 flexdashboard 选项和其特性。 当然 RStudio 官网也给出了该包 介绍 与案例，读者可以基于案例到学习实现快速入门。 5.2.2 Dashboards 排版 关于仪表盘布局的总体规则是： 一级标题：生成页面； 二级标题：生成列（或行）； 三级标题：生成框（包含一个或多个仪表盘组件）。 下面给出一个简单的例子： --- title: &quot;入门例子&quot; output: flexdashboard::flex_dashboard --- ```{r setup, include=FALSE} library(flexdashboard) ``` 第一列 -------------------------------------------------- ### 图表 A ```{r} ``` 第二列 -------------------------------------------------- ### 图表 B ```{r} ``` ### 图表 C ```{r} ``` 注意，第一行文本（第一列）下的一系列破折号是二级标题的另一种 Markdown 语法形式，即： 第一列 -------------------------------------------------- 等同于 ## 第一列 这里使用一系列减号，只是为了让二级标题在源文档中更为显眼罢了。读者可以根据自身喜好，选择任意一种语法形式。 默认情况下，二级标题在仪表板上生成列，三级标题在列中自上而下排列。所以在默认情况下，不必在仪表盘上设置列，因为它默认一列一列自上而下排列显示。 注意：二级标题的内容将不会显示在输出中。二级标题仅用于布局（例如，例子中的“第一列” 不会显示在输出中），因此二级标题的实际内容一点都不重要。相比之下，一级标题和三级标题更加重要。 图 5.7 显示了上述示例的结果，一共是两列，第一列为 “图表 A”，第二列为 “图表 B” 和 “图表 C”。 注：本例中，作者并没有在代码块中加入任何 R 代码，因此框内都是空的。在实际使用中，读者可以编写任意的 R 代码来生成 R 图、HTML 小部件或其他组件，并将其加入到框中。 图 5.7: 简单仪表盘布局示例。 5.2.2.1 基于行的布局 通过修改 orientation 选项将默认布局（列导向）改为以行导向的布局，例如： output: flexdashboard::flex_dashboard: orientation: rows 此时，二级结构将会按照行进行排列，三级结构会按照行中的列进行排放。将上述例子修改后，输出结果如图 5.8 所示： 图 5.8: 基于行布局的结果。 5.2.2.2 节属性 二级结构头部还可以加入一些属性，例如：设置列宽度为 350。 窄栏 {data-width=350} -------------------------------- 在基于行布局的情况下，可以为行设置 data-height 属性。而基于列布局的情况下，可以使用 {.tabset} 使得三级结构以制表符的形式排列，例如： 两个选项卡 {.tabset} ------------------ ### 选项卡 A ### 选项卡 B 结果如图 5.9 所示： 图 5.9: 以制表符的形式排列。 5.2.2.3 多页 如果 R Markdown 文档中有多个一级结构的内容时，这时仪表盘会将每个一节结构分别显示为单独页面。下面给出一个简单的例子： --- title: &quot;多页显示&quot; output: flexdashboard::flex_dashboard --- 图形 {data-icon=&quot;fa-signal&quot;} ===================================== ### 图 A ```{r} ``` ### 图 B ```{r} ``` 表格 {data-icon=&quot;fa-table&quot;} ===================================== ### 表 A ```{r} ``` ### 表 B ```{r} ``` 图 5.10: 仪表盘上的多个页面情况。 注：多个等号是一级标题的另一种 Markdown 语法（也可以使用单个井号 # 表示）。 从图 5.10 可以看到： 页面标题显示在仪表盘顶部的导航菜单中。一级结构单独构成一个页面。 本例中，还做了一个小拓展，通过 data-icon 属性将图标应用于页面标题中。当然也可以从该网址 https://fontawesome.com 找到其他可用图标。例如，图 5.11 给出部分可用图标。 图 5.11: 网站中部分可用图标。 5.2.2.4 故事板 除了基于列或行布局外，还可以通过故事板（storyboard）进行布局，呈现一些可视化图形或其他说明。下面给出一个简单的例子： --- title: &quot;故事板&quot; output: flexdashboard::flex_dashboard: storyboard: true --- ### 散点图 ```{r} plot(cars, pch = 20) grid() ``` --- 可以添加一些评论。 ### 直方图 ```{r} hist(faithful$eruptions, col = &#39;gray&#39;, border = &#39;white&#39;, main = &#39;&#39;) ``` --- 可以添加一些评论。 图 5.12: 基于故事板布局的结果。 如图 5.12 所示，读者可以通过顶部的左右导航按钮来浏览所有故事板内容。 5.2.3 Dashboards 组件 仪表盘布局中可以包含各种各样的组件，包括： 基于 HTML 小部件的交互式 JavaScript 数据可视化图形。 R 图形，包括基础、栅栏和网格图形； 表格（可选选项包括：排序，过滤和分页等）； 数值框（展示重要数据）； 仪表盘； 文本注释； 导航栏（提供与仪表盘相关的更多链接）。 注：无论输出格式如何，前三个组件在大多数 R Markdown 文档中均可使用。 而后四个组件是仪表盘特有的，本节主要介绍后四个组件。 5.2.3.1 数值框 如果希望在仪表盘中包含一个或多个数值，那么读者可以使用 flexdashboard 包中的 valueBox() 函数来实现这个需求。下面给出一个简单的例子： --- title: &quot;数值框&quot; output: flexdashboard::flex_dashboard: orientation: rows --- ```{r setup, include=FALSE} library(flexdashboard) # 这些计算函数只是简单的例子 computeArticles = function(...) return(45) computeComments = function(...) return(126) computeSpam = function(...) return(15) ``` ### 每日文章数 ```{r} articles = computeArticles() valueBox(articles, icon = &quot;fa-pencil&quot;) ``` ### 每日评论数 ```{r} comments = computeComments() valueBox(comments, icon = &quot;fa-comments&quot;) ``` ### 每日垃圾邮件数 ```{r} spam = computeSpam() valueBox( spam, icon = &quot;fa-trash&quot;, color = ifelse(spam &gt; 10, &quot;warning&quot;, &quot;primary&quot;) ) ``` 图 5.13: 仪表盘上并排的三个值。 图 5.13 展示了三个并排的仪表，每个仪表都显示了一个数值和标题。这里重点解释下第三个代码块（### 每日垃圾邮件数）。这里的 valueBox() 函数定义了一个值( spam )和一个图标( icon = \"fa-trash\" )。并使用 color 设置参数框的颜色。内部使用了一个 ifelse() 语句，使得不同值表示不同的颜色。当然，可用的颜色还包括： \"info\", \"success\" 和 \"danger\"（默认值为： \"primary\"）。也可以指定任何有效的 CSS 颜色（例如：\"#ffffff\"， \"rgb(100, 100, 100)\" 等）。 5.2.3.2 仪表 在指定数值范围内显示仪表上的数值。例如，下面展示了三个仪表并排的结果（见图 5.14）。 --- title: &quot;仪表&quot; output: flexdashboard::flex_dashboard: orientation: rows --- ```{r setup, include=FALSE} library(flexdashboard) ``` ### 接触率 ```{r} gauge(91, min = 0, max = 100, symbol = &#39;%&#39;, gaugeSectors( success = c(80, 100), warning = c(40, 79), danger = c(0, 39) )) ``` ### 平均额定值 ```{r} gauge(37.4, min = 0, max = 50, gaugeSectors( success = c(41, 50), warning = c(21, 40), danger = c(0, 20) )) ``` ### 取消数 ```{r} gauge(7, min = 0, max = 10, gaugeSectors( success = c(0, 2), warning = c(3, 6), danger = c(7, 10) )) ``` 图 5.14: 三个仪表并排放在仪表盘上。 这个示例需要解释以下几点： 通过 gauge() 函数设置一个仪表盘。其内部三个参数需要确定：value， min 和 max （可以是任何数值）。 可以指定一个可选的符号（symbol）和值一起显示（本例中， “%” 用来表示百分比）。 可以使用 gaugeSectors() 函数指定一组自定义的颜色扇区，默认颜色为绿色。扇区选项（sectors）可以指定三个值的范围（success, warning 和 danger） 使得仪表盘的颜色根据它的值变化而变化。 5.2.3.3 文本注释 可以通过以下方式在仪表盘中包含额外的叙述说明： 在页面顶部加入相应文本内容。 定义不包含图表，而是仅包含任意内容（文本、图像和方程等）的指示板。 如图 5.15 所示，顶部包含了一些内容说明和右下角包含了一个只有内容的指示板： --- title: &quot;文本注释&quot; output: flexdashboard::flex_dashboard: orientation: rows --- 英国 1974-1979 年每月死于支气管炎、肺气肿和哮喘的人数 （来源于：P. J. Diggle, 1990, Time Series: A Biostatistical Introduction. Oxford, table A.3） ```{r setup, include=FALSE} library(dygraphs) ``` 行 {data-height=600} ------------------------------------- ### 总肺癌死亡数 ```{r} dygraph(ldeaths) ``` 行 {data-height=400} ------------------------------------- ### 男性死亡人数 ```{r} dygraph(mdeaths) ``` &gt; 1974-1979 年英国每月死于肺病的人数。 ### 备注 本例使用了 dygraphs 包。该包为绘制时间序列数据提供了丰富的工具。 图 5.15: 仪表盘上的文本注释。 注意：仪表盘中的每个组件都可以包括标题和注释部分。三级结构 (###) 后面的文本为标题；&gt; 开头的文本是注释。 5.2.3.4 导航栏 默认情况下，仪表盘的导航栏包括：标题（title）、作者（author）和日期（date）。当仪表盘有多个页面时（第 5.2.2.3 节），导航条左侧还包含指向各个页面的链接。当然，也在可以仪表盘上添加社交链接。 除此之外，使用 navbar 选项可以在导航栏中添加自定义链接。例如，在导航栏中添加 “关于” 链接： --- title: &quot;导航栏&quot; output: flexdashboard::flex_dashboard: navbar: - { title: &quot;关于&quot;, href: &quot;https://example.com/about&quot; } --- 这时得到的界面如图 5.16 所示： 图 5.16: 导航栏中添加自定义链接。 注意：导航栏必须包括标题或图标（或两者都包含）。还可以使用 href 作为导航目标。如果想调整文本对齐方式，可以使用 align 参数 （默认情况下为右对齐）。 5.2.4 Dashboards 与 Shiny 在仪表盘中添加 Shiny，可以通过交互界面手动更改参数，并显示实时结果。或者当仪表盘的数据发生变化时，让仪表盘进行实时更新（请参阅 shiny 包中的 reactiveFileReader() 和 reactivePoll() 函数）。这是通过将 runtime: shiny 添加到标准仪表盘文档来实现的，然后添加一个或多个输入控件或响应表达式来动态驱动仪表板内组件的外观。 在 flexdashboard 中使用 Shiny 可以将一个静态的 R Markdown 报告变成一个交互式文档。需要注意的是，交互式文档需要部署到 Shiny 的服务器上，以便广泛共享（而静态 R Markdown 文档是可以附加到电子邮件或从任何标准 Web 服务器提供的独立 Web 页面）。 注意，shinydashboard 包提供了用 Shiny 创建仪表板的另一种方法。 5.2.4.1 入门指南 在仪表盘中添加 Shiny 组件的步骤如下： 在文档顶部 YAML 元数据中添加 runtime: shiny。 在仪表盘第一列添加 {.sidebar} 属性，使其成为 Shiny 控件输入的控制台 注：这一步不是必须的，但这是基于 Shiny 仪表盘的经典布局。 根据需求，添加 Shiny 的输入和输出。 当代码中包含绘图函数时（例如：hist()），得将它们封装在 renderPlot() 中。这有利于界面在布局更改时，自动调整尺寸大小。 5.2.4.2 Shiny 仪表盘的一个示例 图 5.17 给出了 Shiny 仪表盘的一个示例： --- title: &quot;间歇泉喷发&quot; output: flexdashboard::flex_dashboard runtime: shiny --- ```{r global, include=FALSE} # 在全局块中加载数据，以便仪表盘的所有用户可以共享 library(datasets) data(faithful) ``` 列 {.sidebar} -------------------------------------------------- 美国怀俄明州黄石国家公园的 Old Faithful 间歇泉在喷发和喷发之间的等待时间。 ```{r} selectInput( &quot;n_breaks&quot;, label = &quot;条形数：&quot;, choices = c(10, 20, 35, 50), selected = 20 ) sliderInput( &quot;bw_adjust&quot;, label = &quot;带宽调整：&quot;, min = 0.2, max = 2, value = 1, step = 0.2 ) ``` 列 -------------------------------------------------- ### 间歇泉喷发持续时间 ```{r} renderPlot({ erpt = faithful$eruptions hist( erpt, probability = TRUE, breaks = as.integer(input$n_breaks), xlab = &quot;Duration (minutes)&quot;, main = &quot;Geyser Eruption Duration&quot;, col = &#39;gray&#39;, border = &#39;white&#39; ) dens = density(erpt, adjust = input$bw_adjust) lines(dens, col = &quot;blue&quot;, lwd = 2) }) ``` 图 5.17: 基于 Shiny 的交互式仪表盘。 其中，仪表盘的第一列包含了 {.sidebar} 属性和两个 Shiny 的输入控件；第二列包含了绘制图表的 Shiny 代码。 注意：文档顶部标记为 global 的 R 代码块在全局环境中都可以被调用。这将为用户带来更好的启动性能，强烈推荐大家使用。 5.2.4.3 输入栏 通过添加 {.sidebar} 属性设置一个默认布局为左对齐，250 像素宽度的左侧边栏。 在搭建多个页面的仪表盘时，如果想创建一个应用于所有页面的工具条。这时，可以使用一级结构来定义侧边栏。 5.2.4.4 拓展 下面给出一些学习 Shiny 和创建交互式文档的资源： Shiny 官方网站( http://shiny.rstudio.com) ：包含大量的文章、教程和示例。 Shiny 网站上的文章“Introduction to Interactive Documents”，这是一个很好的入门指南。 关于部署交互式文档，读者可以使用 Shiny Server 或 RStudio Connect：https://www.rstudio.com/products/shiny/shiny-server/。 5.3 在 R package 中使用 R Markdown 5.3.1 写软件包的文档 5.3.2 定义一个自动化报告函数 参考文献 "],["rmarkdown-operation.html", "第 6 章 R Markdown 的操作技巧 6.1 表格操作进阶 6.2 块选项 6.3 与其他语言的结合 6.4 输出钩子 (*) 6.5 缓存 (*) 6.6 其它使用 knitr 的小技巧 (*)", " 第 6 章 R Markdown 的操作技巧 6.1 表格操作进阶 在日常报告中，表格是展示结果的主要方式之一，例如下表展示了某中学某次考试的学生成绩： 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 然而，该成绩表并不美观，例如有些人习惯将内容居中，一般情况下给表格添加标题会更容易让人读懂，即得到表 6.1 的结果： 表 6.1: 考试成绩 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 除了居中操作以及添加标题外，在制作表格时还会产生各种各样的特定需求，例如合并单元格、添加底色等。本节将系统地介绍在 R Markdown 中生成表格和进一步对其个性化的方法，主要包括下列内容： 介绍表格生成函数 knitr::kable() 的所有特征； 使用 kableExtra (Zhu 2021) 包来展现更高级的个性化制作方法； 提供其它生成表格的 R 包以供读者参考。 6.1.1 利用函数 knitr::kable() 生成复杂的表格 在 R Markdown 中，通常使用 knitr 包中的函数 kable() 来快速创建一个表格。kable() 可以处理数据框、矩阵等“矩形数据”，快速生成表格，而表格的外观则可以通过修改函数参数来自定义，下面将对这些参数进行介绍： kable(x, format, digits = getOption(&quot;digits&quot;), row.names = NA, col.names = NA, align, caption = NULL, label = NULL, format.args = list(), escape = TRUE, ...) 6.1.1.1 目前已支持的表的格式 在大多数情况下，如果只需要制作一个简单表格，knitr::kable(x) 就足够了。其中 format 参数会根据 knitr 源文档自动设置。它可能的取值是 pipe （列与列之间由短的竖线分隔的表），simple （仅包含横向分割线 的简单表格），latex （LaTex 表格），html （HTML 表格），和 rst （reStructuredText 表格）。为了展示各个取值的不同，这里直接给出了各个取值在不同编程语言中的原始代码。 对于 R Markdown 文档，kable() 默认使用 pipe 格式的表格，输出结果如下所示： grade &lt;- data.frame(姓名 = c(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;), 语文 = c(89,90,85), 数学 = c(93,97,91), 英语 = c(92,85,97)) knitr::kable(grade, &#39;pipe&#39;) |姓名 | 语文| 数学| 英语| |:----|----:|----:|----:| |张三 | 89| 93| 92| |李四 | 90| 97| 85| |王五 | 85| 91| 97| 也可以生成一个（基于 Pandoc 的）简单的表格，或 HMTL、LaTex 以及 reStructuredText 格式的表格： knitr::kable(grade, &#39;simple&#39;) 姓名 语文 数学 英语 ----- ----- ----- ----- 张三 89 93 92 李四 90 97 85 王五 85 91 97 knitr::kable(grade, &#39;html&#39;) &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; 姓名 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 语文 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 数学 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 英语 &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 张三 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 89 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 93 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 92 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 李四 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 90 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 97 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 85 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 王五 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 85 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 91 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 97 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; knitr::kable(grade, &#39;latex&#39;) \\begin{tabular}{l|r|r|r} \\hline 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\hline 张三 &amp; 89 &amp; 93 &amp; 92\\\\ \\hline 李四 &amp; 90 &amp; 97 &amp; 85\\\\ \\hline 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\hline \\end{tabular} knitr::kable(grade, &#39;rst&#39;) ==== ==== ==== ==== 姓名 语文 数学 英语 ==== ==== ==== ==== 张三 89 93 92 李四 90 97 85 王五 85 91 97 ==== ==== ==== ==== 需要注意的是，只有 pipe 和 simple 格式是“可移植”的，也就是说，它们适用于任何输出文档的格式，而其他格式则只适用于特定的输出格式，例如，format = 'latex' 只适用于 LaTex 输出文档。使用特定的表格格式可以带来更多的自主控制能力，但代价是牺牲了可移植性。 如果在一个报告中，只需要一种非默认的表格格式，可以直接设置全局的 R 选项 knitr.table.format。例如若只需要 LaTex 格式的表格，则可以设置： options(knitr.table.format = &#39;latex&#39;) 这一选项也可以是一个返回格式字符串或 NULL 的函数。在 NULL 的情况下，knitr 将自动决定适当的格式。例如，可以只在输出格式为 LaTeX 时使用 latex 格式: options(knitr.table.format = function() { if (knitr::is_latex_output()) &#39;latex&#39; else &#39;pipe&#39; }) 6.1.1.2 修改表的列名 在一些情况下，在数据框（data frame）中定义的列的名称可能与想要显示给读者的内容不同，需要进行修改。在使用英文时，数据的列名通常不使用空格来分隔单词，而是使用点、下划线以及大小写来进行分隔。而在制作表格时，这样的变量名会显得有些不自然。在中文环境下，虽然空格的问题较少，但也存在变量名过长的情况，在 R 中也往往使用简化的名词或对应的英文简写来代替。在这种情况下，可以使用 col.names 参数将列名替换为一个包含新名称的向量，即 col.names = c(...)。例如，可以在上文成绩表的列名中提供更多信息： knitr::kable(grade, col.names = c(paste0(&#39;第1组&#39;, colnames(grade)))) 第1组姓名 第1组语文 第1组数学 第1组英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 col.names 参数可以接受任意的字符向量（不一定是通过 paste0() 等函数修改的列名），只要向量的长度等于数据对象的列数即可，例如可以把列名换成英文： knitr::kable(grade, col.names = c(&#39;Name&#39;, &#39;Chinese&#39;, &#39;Math&#39;, &#39;English&#39;)) Name Chinese Math English 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.1.3 指定列的对齐方式 如果想要改变表格中列的对齐方式，可以使用由字符 l （left，左对齐）、c （center，居中）以及 r （right，右对齐）组成的值向量或一个多字符的字符串来进行对齐，即 kable(..., align = c('c', 'l')) 和 kable(..., align = 'cl') 是等价的。在默认情况下，数字列是右对齐的，其他列是左对齐的。例如可以对成绩表进行调整，使得前两列右对齐，后两列左对齐： knitr::kable(grade, align = &#39;rrll&#39;) 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 而当对齐方式统一时，也可以用一个字母来代替，例如可以把成绩表所有列都居中表示： knitr::kable(grade, align = &#39;c&#39;) 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.1.4 添加表格标题 给表格添加标题需要用到 caption 参数，如表 6.2 所示： knitr::kable(grade, caption = &#39;考试成绩&#39;) 表 6.2: 考试成绩 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 正如本书2.6.4节所提到的那样，当一个表格有标题并且以 bookdown 来输出格式时，它可以被交叉引用，而在基础的 html_document 和 pdf_document 中则不行。 6.1.1.5 调整数字格式 有的时候，表格中的数字位数很长，展示的时候需要缩短，这时可以通过 digits 参数（会被传递给 round() 函数）来设置最大的小数位数，以及通过 format.args（会被传递给 R 中的 format() 函数）来设置其他格式化参数。 首先是几个简单的 round() 和 format() 的例子，从而可以更好地理解之后的 kable() 中 digits 参数是如何工作的: round(1.234567, 0) ## [1] 1 round(1.234567, digits = 1) ## [1] 1.2 round(1.234567, digits = 3) ## [1] 1.235 format(1000, scientific = TRUE) ## [1] &quot;1e+03&quot; format(10000.123, big.mark = &#39;,&#39;) ## [1] &quot;10,000.12&quot; 可以将数字四舍五入并格式化成表格： d = cbind(X1 = runif(3), X2 = 10^c(3, 5, 7), X3 = rnorm(3, 0, 1000)) # 保留最多四位小数 knitr::kable(d, digits = 4) X1 X2 X3 0.4513 1e+03 -300.9029 0.7838 1e+05 528.2758 0.7097 1e+07 -622.8860 # 每列分别设置 knitr::kable(d, digits = c(5, 0, 2)) X1 X2 X3 0.45127 1e+03 -300.90 0.78378 1e+05 528.28 0.70968 1e+07 -622.89 # 不使用科学计数法 knitr::kable(d, digits = 3, format.args = list(scientific = FALSE)) X1 X2 X3 0.451 1000 -300.903 0.784 100000 528.276 0.710 10000000 -622.886 # 给 big numbers 添加逗号 knitr::kable(d, digits = 3, format.args = list(big.mark = &#39;,&#39;, scientific = FALSE)) X1 X2 X3 0.451 1,000 -300.903 0.784 100,000 528.276 0.710 10,000,000 -622.886 6.1.1.6 显示缺失值 有的时候，表中可能会存在缺失值，如该学生没有缺考或没有选修某个课。在默认情况下，R 中缺失值（如NA）在表格中显示为字符串NA，如： grade2 &lt;- data.frame(姓名 = c(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;), 物理 = c(NA,90,85), 政治 = c(93,97,NA), 计算机 = c(92,NA,97)) knitr::kable(grade2) # 默认显示 NA 姓名 物理 政治 计算机 张三 NA 93 92 李四 90 97 NA 王五 85 NA 97 为了表格美观，也可以使用其他的值来替换它们，或者通过使用全局 R 选项 knitr.kable.NA来调整显示的内容（例如使NA对应的单元格为空）。例如，可以将下面第一个表中的NA单元格设为空，然后在第二个表中显示**： # 用空值代替 NA opts = options(knitr.kable.NA = &#39;&#39;) knitr::kable(grade2) 姓名 物理 政治 计算机 张三 93 92 李四 90 97 王五 85 97 # 用指定字符（**） 代替 NA options(knitr.kable.NA = &#39;**&#39;) knitr::kable(grade2) 姓名 物理 政治 计算机 张三 ** 93 92 李四 90 97 ** 王五 85 ** 97 options(opts) # 恢复全局 R 选项 6.1.1.7 特殊字符的转义 HTML 或者 LaTeX 对应的编程语言之中包含了一些特殊的字符，例如在 LaTeX 中输入公式可能需要的 $ 等。为了使结果能够正常输出，kable() 将默认通过参数 escape = TRUE 来“转义”这些特殊字符，即令这些特殊字符失去其特殊含义，使得所有的字符可以逐字生成，而不会生成特殊符号（如 \\beta 将不会自动显示为 \\(\\beta\\)）。例如对于 HTML 格式的表格，&gt; 将被替换为 &amp;gt;；而对于 LaTeX 格式的表格，_ 将被转义为 \\_ 16。 如果接触过这些字符，并且知道如何正确使用它们，那么可以通过 escape = FALSE 来禁用这个参数，但要注意必须确保特殊字符不会在 LaTeX 或 HTML 中触发语法错误。表 6.3 展示了转义之后的结果，表 6.4 则展示了一些包含特殊字符（$、\\ 以及 _）的 LaTeX 数学表达式： # 添加数学表达式 g_range &lt;- data.frame(成绩范围 = c(&quot;$\\\\ge 90$&quot;,&quot;$\\\\ge 80$&quot;, &quot;$\\\\ge 70$&quot;), 语文 = c(6,10,20), 数学 = c(3,7,16), 英语 = c(5,15,20)) colnames(g_range) &lt;- c(&quot;成绩范围&quot;, &quot;$Chinese_{Jan}$&quot;, &quot;$Math_{Jan}$&quot;, &quot;$English_{Jan}$&quot;) knitr::kable(g_range, escape = TRUE, caption = &quot;escape = TRUE 生成的表&quot;) 表 6.3: escape = TRUE 生成的表 成绩范围 \\(Chinese_{Jan}\\) \\(Math_{Jan}\\) \\(English_{Jan}\\) \\(\\ge 90\\) 6 3 5 \\(\\ge 80\\) 10 7 15 \\(\\ge 70\\) 20 16 20 knitr::kable(g_range, escape = FALSE, caption = &quot;escape = FALSE 生成的表&quot;) 表 6.4: escape = FALSE 生成的表 成绩范围 \\(Chinese_{Jan}\\) \\(Math_{Jan}\\) \\(English_{Jan}\\) \\(\\ge 90\\) 6 3 5 \\(\\ge 80\\) 10 7 15 \\(\\ge 70\\) 20 16 20 如表 6.3 所示，如果设置 escape = TRUE，特殊字符将被转义或替换。例如，在 LaTeX 格式的表格中，$ 会被转义为 \\$、_ 被转义为 \\_ 以及 \\ 被替换为 \\textbackslash{}： knitr::kable(g_range[,1:2], format = &#39;latex&#39;, escape = TRUE) \\begin{tabular}{l|r} \\hline 成绩范围 &amp; \\$Chinese\\_\\{Jan\\}\\$\\\\ \\hline \\$\\textbackslash{}ge 90\\$ &amp; 6\\\\ \\hline \\$\\textbackslash{}ge 80\\$ &amp; 10\\\\ \\hline \\$\\textbackslash{}ge 70\\$ &amp; 20\\\\ \\hline \\end{tabular} 其他 LaTeX 中常见的特殊字符包括#、%、&amp;、{ 以及 }；HTML 中常见的特殊字符包括&amp;、&lt;、 &gt; 以及 \"。在生成带有 escape = FALSE 的表格时，需要格外小心并确保正确地使用了特殊字符。一个常见的错误是在使用 escape = FALSE 时，在 LaTeX 表格的列名或标题中包含 % 或 _ 等字符，而没有意识到它们是特殊的字符。 如果想知道 escape = TRUE 参数会如何转义特殊字符，可以通过 knitr 中两个内部辅助函数 escape_latex 和 escape_html 来分别查询在 LaTeX 和 HTML 格式的表格中的转义结果：。下面是一些例子： knitr:::escape_latex(c(&#39;100%&#39;, &#39;# 一个观点&#39;, &#39;文字_1&#39;)) ## [1] &quot;100\\\\%&quot; &quot;\\\\# 一个观点&quot; &quot;文字\\\\_1&quot; knitr:::escape_html(c(&#39;&lt;address&gt;&#39;, &#39;x = &quot;字符&quot;&#39;, &#39;a &amp; b&#39;)) ## [1] &quot;&amp;lt;address&amp;gt;&quot; &quot;x = &amp;quot;字符&amp;quot;&quot; &quot;a &amp;amp; b&quot; 6.1.1.8 多张表格并排 有的时候，将多张表格并排放置可以便于比较，将数据框或矩阵以列表的形式传递给 kable() 就可以实现这一功能。例如，表 6.5 包含了之前展示过的两张表： # 数据对象 grade 和 grade2 由之前的代码块生成 knitr::kable( list(grade, grade2), caption = &#39;两张表并排放置&#39;, booktabs = TRUE, valign = &#39;t&#39; ) 表 6.5: 两张表并排放置 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 姓名 物理 政治 计算机 张三 NA 93 92 李四 90 97 NA 王五 85 NA 97 需要注意的是，此功能仅适用于 HTML 和 PDF 格式的输出。 另外，如果在并排放置各个表的时候，想能够分别自定义它们，可以使用 kables() 函数（即 kable() 的复数形式），并将一个对象为 kable() 的列表传递给它。例如，在表 6.6 中，可以更改左表中的列名，并将右表中的小数点位数设置为 4： # 数据对象 grade 和 d 由之前的代码块生成 knitr::kables( list( # 第一个 kable()：修改列名 knitr::kable( grade, col.names = c(&#39;Name&#39;, &#39;Chinese&#39;, &#39;Math&#39;, &#39;English&#39;), valign = &#39;t&#39; ), # 第二个 kable()：设置 digits 选项 knitr::kable(d, digits = 4, valign = &#39;t&#39;) ), caption = &#39;由 knitr::kables() 生成的两张表&#39; ) 表 6.6: 由 knitr::kables() 生成的两张表 Name Chinese Math English 张三 89 93 92 李四 90 97 85 王五 85 91 97 X1 X2 X3 0.4513 1e+03 -300.9029 0.7838 1e+05 528.2758 0.7097 1e+07 -622.8860 6.1.1.9 利用for循环生成多个表 (*) 对于 kable()，有一个常见的错误认识是它不能在 for 循环中工作。这个问题并不特定于 kable()，同时也存在于许多其他的 R 包中。其背后原因较为复杂,对技术细节感兴趣的读者可以参考博文 “The Ghost Printer behind Top-level R Expressions.”。 例如，直观上下面的代码块可能可以生成三个表，但事实上它并不会： ```{r} for (i in 1:3) { knitr::kable(grade) } ``` 若想要实现生成多个表的目的，则必须显式打印 kable() 结果，并应用块选项 results = 'asis'，例如： ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(grade)) } ``` 通常情况下，在利用 for 循环输出结果时，最好添加一些换行符（\\n）或 HTML 注释（&lt;!-- --&gt;），从而清晰地分隔所有输出的元素，例如： ```{r, results=&#39;asis&#39;} for (i in 1:3) { print(knitr::kable(grade, caption = &#39;标题&#39;)) cat(&#39;\\n\\n&lt;!-- --&gt;\\n\\n&#39;) } ``` 如果没有这些分隔符，Pandoc 可能无法检测到单个元素。例如，当一个图片之后面紧跟着一个表格时，这个表格并不会被识别到： ![](logo.png) 姓名 语文 数学 英语 ----- ----- ----- ----- 张三 89 93 92 李四 90 97 85 王五 85 91 97 但如果像这样有一个清晰的分隔（注意，在图像下面添加了一个空行），它将变成： ![](logo.png) 姓名 语文 数学 英语 ----- ----- ----- ----- 张三 89 93 92 李四 90 97 85 王五 85 91 97 或者 ![](logo.png) &lt;!-- --&gt; 姓名 语文 数学 英语 ----- ----- ----- ----- 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.1.10 自定义 LaTeX 表格 (*) 如果只需要 LaTeX 格式的输出时，可以在 kable() 中使用一些额外的选项。注意在其他类型的输出中（如 HTML），这些选项将被忽略。除非已经设置了全局的表格格式选项（见本书 6.1.1.1 节），否则必须像本节的例子那样使用 kable() 的 format 参数，例如： knitr::kable(grade, format = &#39;latex&#39;, booktabs = TRUE) 当给一个表格分配一个标题时（见本书 6.1.1.4 节）， kable() 将使用 table 环境来纳入这个表，即： \\begin{table} % 表格 (通常为 tabular 环境) \\end{table} 不同的环境具有不同的性质，例如熟悉 LaTeX 的读者可能了解浮动体，即某些环境下图表的位置会在页面的底部或顶部“浮动”，如 table 及 figure 等环境。可以通过 table.envir 参数来对环境进行调整： knitr::kable(grade, format = &#39;latex&#39;, table.envir = &#39;Table&#39;) \\begin{Table} \\begin{tabular}{l|r|r|r} \\hline 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\hline 张三 &amp; 89 &amp; 93 &amp; 92\\\\ \\hline 李四 &amp; 90 &amp; 97 &amp; 85\\\\ \\hline 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\hline \\end{tabular} \\end{Table} 表格的位置由参数 position 来控制。例如，可以通过 position = \"!b\" 来强制将表格固定到页面的底部： knitr::kable(grade, format = &#39;latex&#39;, table.envir = &#39;table&#39;, position = &#39;!b&#39;) \\begin{table}[!b] \\begin{tabular}{l|r|r|r} \\hline 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\hline 张三 &amp; 89 &amp; 93 &amp; 92\\\\ \\hline 李四 &amp; 90 &amp; 97 &amp; 85\\\\ \\hline 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\hline \\end{tabular} \\end{table} 当表格有标题时，也可以通过 caption.short 参数给它分配一个短的标题，例如： knitr::kable(grade, caption = &#39;一个很长很长的标题！&#39;, caption.short = &#39;短标题&#39;) 短标题将会进入 LaTeX 中 \\caption[]{} 命令的方括号中，经常在 PDF 输出文档的表格目录中使用（如果不提供短标题，那里则会显示完整的标题）。 如果熟悉用于生成可供发布（即高质量）表格的 LaTeX 包 booktabs{LaTeX package!booktabs}，则可以设置booktabs = TRUE。 knitr::kable(grade, format = &#39;latex&#39;, booktabs = TRUE) \\begin{tabular}{lrrr} \\toprule 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\midrule 张三 &amp; 89 &amp; 93 &amp; 92\\\\ 李四 &amp; 90 &amp; 97 &amp; 85\\\\ 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\bottomrule \\end{tabular} 需要注意的是，当在 R Markdown 文档中需要额外的 LaTeX 包时（如 booktabs），必须在 YAML 中声明这些包（请参阅第 3.2.4 节了解如何声明）。【！！！现有目录需要补充】 参数 booktabs 取 FALSE （默认值）或 TRUE 时，表的外观是不同的，见表 ?? 和表 ?? 。 knitr::kable(grade, format = &#39;latex&#39;, booktabs = FALSE, caption = &#39;booktabs = FALSE 时的表格&#39;) knitr::kable(grade, format = &#39;latex&#39;, booktabs = TRUE, caption = &#39;booktabs = TRUE 时的表格&#39;) 对于 booktabs = FALSE： 表的列由垂直线分隔。可以通过 vline 参数来删除垂直线，例如 knitr::kable(grade, vline = \"\") （默认值是vline = \"|\"）。也可以将这个选项设置为一个全局的R选项，这样就不需要为每个表设置它，例如 options(knitr.table.vline = \"\")。 水平线可以通过参数 toprule、midrule、linesep 以及 bottomrule 来定义，它们的默认值都是\\hline。 对于 booktabs = TRUE： 表格中没有垂直线，但可以通过 vline 参数来添加。 表格只有标题和底部行有水平线。默认参数值是 toprule = \"\\\\toprule\"、midrule = \"\\\\midrule\" 以及 bottomrule = \"\\\\bottomrule\"。默认情况下，每 5 行加一个行间距（\\addlinespace），这是由参数 linesep 控制的，默认值为 c(\"\", \"\", \"\", \"\", \"\\\\addlinespace\")。如果想每 1 行加一个 \\addlinespace，则可以这样做： knitr::kable(grade, format = &#39;latex&#39;, linesep = c(&#39;\\\\addlinespace&#39;), booktabs = TRUE) \\begin{tabular}{lrrr} \\toprule 姓名 &amp; 语文 &amp; 数学 &amp; 英语\\\\ \\midrule 张三 &amp; 89 &amp; 93 &amp; 92\\\\ \\addlinespace 李四 &amp; 90 &amp; 97 &amp; 85\\\\ \\addlinespace 王五 &amp; 85 &amp; 91 &amp; 97\\\\ \\bottomrule \\end{tabular} 如果想删除所有的行间距，可以使用linesep = ''。 有的时候，表可能比一页还长。可以使用参数 longtable = TRUE，该参数使用 LaTeX 包 longtable 将表跨到多个页面。 另外，当表格被包含在 table 环境中时（例如，当表有标题时），表格默认居中对齐。如果不想让表格居中，可以使用参数 centering = FALSE。 6.1.1.11 自定义 HTML 表格 (*) 如果想自定义通过 knitr::kable(format = \"html\") 生成的表，除了前面提到的常见参数外，只有一个额外的参数需要注意：table.attr。这个参数允许用户向 &lt;table&gt; 标签添加任意属性。例如可以向表格中添加一个类striped： knitr::kable(grade, table.attr = &#39;class=&quot;striped&quot;&#39;, format = &quot;html&quot;) &lt;table class=&quot;striped&quot;&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=&quot;text-align:left;&quot;&gt; 姓名 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 语文 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 数学 &lt;/th&gt; &lt;th style=&quot;text-align:right;&quot;&gt; 英语 &lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 张三 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 89 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 93 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 92 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 李四 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 90 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 97 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 85 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;text-align:left;&quot;&gt; 王五 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 85 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 91 &lt;/td&gt; &lt;td style=&quot;text-align:right;&quot;&gt; 97 &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 然而，类的名称不足以改变表的外观，必须定义 CSS17 类的规则。例如，要制作奇数行和偶数行有不同颜色的条纹表，可以为偶数行或奇数行添加浅灰色背景： .striped tr:nth-child(even) { background: #eee; } 上面的 CSS 规则意味着所有 striped 类的元素的子元素，且具有偶数行号（:nth-child(even)）的行（即 &lt;tr&gt; 标签），将它们的背景颜色设置为 #eee。 使用一点 CSS 可以使一个普通的 HTML 表看起来好看很多。图 6.1 是一个 HTML 表格的截图，其中应用了以下 CSS 规则： table { margin: auto; border-top: 1px solid #666; border-bottom: 1px solid #666; } table thead th { border-bottom: 1px solid #ddd; } th, td { padding: 5px; } thead, tfoot, tr:nth-child(even) { background: #eee; } 图 6.1: 利用 HTML 和 CSS 创建的条纹表 6.1.2 利用 kableExtra 美化表格 kableExtra 包(Zhu 2021) 设计的目的为扩展 knitr::kable() 生成表格的基本功能（见第 6.1.1 节）。由于 knitr::kable() 的设计很简单，就像很多其他的 R 包一样，它肯定有很多缺失的功能，而 kableExtra 完美地填补了空白，可以配合 knitr::kable() 生成更好看的表格。最令人惊讶的是，kableExtra 的大多数表格的特性都适用于 HTML 和 PDF 格式，例如，借助 kableExtra 包可以绘制如图 6.1 的条纹表。 一般情况下，kableExtra 包可以通过 CRAN 安装，也可以尝试 GitHub 上的开发版本 (https://github.com/haozhu233/kableExtra)： # 通过 CRAN 安装 install.packages(&quot;kableExtra&quot;) # 安装开发版本 remotes::install_github(&quot;haozhu233/kableExtra&quot;) https://haozhu233.github.io/kableExtra/ 提供了大量的文档，介绍了很多关于如何自定义 kable() 的 HTML 或 LaTeX 输出结果的例子。本节只提供几个示例，更多内容可参见该文档。 另外，kableExtra 包支持使用管道操作符 %&gt;%，可以将 kable() 的输出结果连到 kableExtra 的样式函数上，例如表 6.7： library(knitr) library(kableExtra) kable(grade, caption = &quot;条纹表&quot;) %&gt;% kable_styling(latex_options = &quot;striped&quot;) 表 6.7: 条纹表 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.2.1 设定字体尺寸 有的时候，在展示一些表格时，需要设定字体的尺寸，如放大或缩小某些特定问题。kableExtra 包中的 kable_styling() 函数可以帮助用户对整个表进行样式化。例如，可以指定页面上表格的对齐方式、表格的宽度和字体大小。表 6.8 展示了一个使用小字体的例子： kable(grade, booktabs = TRUE, caption = &quot;字体较小的表格&quot;) %&gt;% kable_styling(font_size = 8) 表 6.8: 字体较小的表格 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 6.1.2.2 特定的行或列的样式 有时还需要对表格的行或列的具体样式进行调整，如加粗某行等。函数 row_spec() 和 column_spec() 可分别用于样式化单独的行和列。表 6.9 将第一行文字加粗并设为斜体，将第二行添加黑色背景，同时更改字体颜色为白色并旋转，给第三行文字加下划线并更改其字体，并给第四列加删除线： kable(grade, align = &#39;c&#39;, booktabs = TRUE, caption = &quot;更改特定行或列的样式&quot;) %&gt;% row_spec(1, bold = TRUE, italic = TRUE) %&gt;% row_spec(2, color = &#39;white&#39;, background = &#39;black&#39;, angle = 45) %&gt;% row_spec(3, underline = TRUE, monospace = TRUE) %&gt;% column_spec(4, strikeout = TRUE) 表 6.9: 更改特定行或列的样式 姓名 语文 数学 英语 张三 89 93 92 李四 90 97 85 王五 85 91 97 类似地，也可以使用 cell_spec() 函数来给单个单元格设定样式。 6.1.2.3 给行或列分组 回想 Excel 里的操作，对单元格进行合并的操作可以给行或列进行分组。在 R Markdown 中，行和列可以分别通过函数 pack_rows() 和 add_header_above() 来进行分组。另外，也可以通过 collapse_rows() 来折叠行，这样一个单元格可以跨越多个行。表 6.10 展示了一个给标题列分组后的表格： grade3 &lt;- data.frame(姓名 = c(&quot;张三&quot;,&quot;李四&quot;,&quot;王五&quot;), 物理 = c(90,90,85), 化学 = c(86,92,80), 生物 = c(94,85,90), 政治 = c(93,97,95), 历史 = c(92,84,80), 地理 = c(99,89,95), 计算机 = c(92,95,97), 体育 = c(85,99,95)) kable(grade3, booktabs = TRUE, caption = &quot;对标题列进行分组&quot;) %&gt;% add_header_above(c(&quot; &quot; = 1, &quot;理科&quot; = 3, &quot;文科&quot; = 3, &quot;其它&quot; = 2)) 表 6.10: 对标题列进行分组 理科 文科 其它 姓名 物理 化学 生物 政治 历史 地理 计算机 体育 张三 90 86 94 93 92 99 92 85 李四 90 92 85 97 84 89 95 99 王五 85 80 90 95 80 95 97 95 对于 add_header_above() 中的命名向量，其名称是显示在表头中的文本，向量的整数值表示一个名称应该跨越多少列，例如，\"理科\" = 3 表示 理科 应该跨越三列。 表 6.11 提供了 pack_rows() 的示例，其中 index 参数的含义类似于之前解释过的 add_header_above() 参数： kable(grade3, booktabs = TRUE, caption = &quot;对行进行折叠&quot;) %&gt;% pack_rows( index = c(&quot;一班&quot; = 1, &quot;二班&quot; = 2) ) 表 6.11: 对行进行折叠 姓名 物理 化学 生物 政治 历史 地理 计算机 体育 一班 张三 90 86 94 93 92 99 92 85 二班 李四 90 92 85 97 84 89 95 99 王五 85 80 90 95 80 95 97 95 6.1.2.4 按比例缩小LaTex中的表格 有一些特性是 HTML 或 LaTeX 输出格式特有的。例如，横向打印格式只在 LaTeX 中有意义，所以 kableExtra 中的 landscape() 函数只对 LaTeX 格式的输出有效。对于一个比较宽的表格（表 6.12），（表 6.13）展现了如何将表格按比例缩小以适应页面的宽度（否则该表格会太宽）： grade4 &lt;- merge(grade, grade3, by = &quot;姓名&quot;) kable(grade4, booktabs = TRUE, caption = &quot;原始表格（太宽）&quot;) 表 6.12: 原始表格（太宽） 姓名 语文 数学 英语 物理 化学 生物 政治 历史 地理 计算机 体育 张三 89 93 92 90 86 94 93 92 99 92 85 李四 90 97 85 90 92 85 97 84 89 95 99 王五 85 91 97 85 80 90 95 80 95 97 95 kable(grade4, booktabs = TRUE, caption = &quot;缩小后的表格&quot;) %&gt;% kable_styling(latex_options = &quot;scale_down&quot;) 表 6.13: 缩小后的表格 姓名 语文 数学 英语 物理 化学 生物 政治 历史 地理 计算机 体育 张三 89 93 92 90 86 94 93 92 99 92 85 李四 90 97 85 90 92 85 97 84 89 95 99 王五 85 91 97 85 80 90 95 80 95 97 95 注意如果在浏览 HTML 版本的话，表 6.12 和表 6.13 表格是没有差异的。 6.1.3 其它生成表格的包及功能介绍 还有很多其他的R包可以用来生成表格。本节引入 kable() （见第 6.1.1 节）和 kableExtra （见第 6.1.2 节）的主要原因不是它们比其他包更好，而是因为作者们只熟悉它们，而且它们的功能可以涵盖大部分的日常使用需求。接下来本节将列出一些已知的其它软件包，感兴趣的读者可以去尝试并决定哪一个最适合自己。 flextable (R-flextable?) 和 huxtable (Hugh-Jones 2021)：flextable 和 huxtable 支持多种表格输出格式的包。它们都支持 HTML、LaTeX 以及 Office 格式，并且包含最常见的表格特性（例如条件格式化）。更多关于 flextable 的信息可参见：https://davidgohel.github.io/flextable/，huxtable 的说明文档则在：https://hughjonesd.github.io/huxtable/。 gt (R-gt?)：这个 R 包允许用户将表格的不同部分组合在一起，例如表头（标题和副标题）、列标签、表格主体、行组标签以及表格的脚注，从而组成一个完整的表格，其中有些部分是可选择性添加的。还可以格式化数字，并为单元格添加背景阴影。目前 gt 主要支持 HTML 输出。18更多关于 gt 的信息可参见：https://gt.rstudio.com。 formattable (R-formattable?)：这个 R 包提供了一些格式化数字的工具函数（如 percent() 和 accounting()），以及对列进行样式化的函数（如格式化文本，用背景阴影或颜色条注释数字，或在单元格中添加图标等等）。和 gt 相同，formattable 包也主要支持HTML格式。更多信息可参见GitHub项目：https://github.com/renkun-ken/formattable/。 DT (R-DT?)：它只支持 HTML 格式。DT 构建在 JavaScript 库 DataTables 之上，它可以将静态表转换为HTML页面上的交互式表。你可以对表进行排序、搜索和分页。DT 还支持格式化单元格，与 Shiny 一起构建交互式应用程序，并包含了大量的 DataTables 扩展（例如，可以将表格导出到Excel，或交互式重新排列表格的列）。更多信息可参见：https://github.com/rstudio/DT/。 reactable (R-reactable?)：与 DT 类似，这个包也基于 JavaScript 库创建交互式表。它在某些方面比 DT 更好（比如行分组和聚合操作，以及嵌入HTML小部件），但 reactable 并不包含 DT 全部的特性。更多信息可参见：https://glin.github.io/reactable/。 rhandsontable(R-rhandsontable?)：这个包也类似于 DT，并且和 Excel 比较像（例如，可以直接在表中编辑数据）。更多信息可参见：https://jrowen.github.io/rhandsontable/。 pixiedust (R-pixiedust?)：这个包通过 broom 包(R-broom?)来为为模型结果（如线性模型）创建表格，它支持 Markdown、HTML 以及 LaTeX 输出格式。更多信息可参见：https://github.com/nutterb/pixiedust/。 stargazer (R-stargazer?)：格式化回归模型和汇总统计表。更多信息可参见：https://cran.r-project.org/package=stargazer/。 xtable (Dahl et al. 2019)；这个包可能是最早的创建表格的包，其第一次发布是在 2000 年。它同时支持LaTeX和HTML格式。该软件包可在 CRAN 上访问：https://cran.r-project.org/package=xtable/。 还有一些其它生成表格的包，这里不再进一步介绍，只是在这里列出它们，以供感兴趣者参考：tables (R-tables?)、pander (Daróczi and Tsegelskyi 2022)、tangram (R-tangram?)、ztable (R-ztable?) 以及 condformat (R-condformat?)。 6.2 块选项 在之前的章节中，R 包 knitr 展现了其在 R Markdown 中起到的关键作用。在本节和接下来的第 6.4、6.6 两节中，将进一步展示一些与 knitr 相关的编程技巧，从而更有效地辅助工作的开展。 事实上，在 R Markdown 的代码块中，有超过 50 个块选项可以用来微调 knitr 处理代码块的方式，选项的完整列表可参阅在线文档https://yihui.org/knitr/options/。 需要注意的是，接下来的几节只展示了将块选项应用到单个代码块的例子，但实际上，任何块选项都可以进行全局设置，应用于整个文档，而不必在每个代码块中重复。如果要设置全局的块选项，需要在代码块（通常为文档中的第一个代码块）中调用 knitr::opts_chunk$set()。例如若需要对整个文档调整文本输出中的前导符号（comment = \"#&gt;\"，见第 6.2.5 节）、隐藏源代码（echo = FALSE，见第 6.2.3 节）并控制图片大小（fig.width = 6，见第 2.6.1 节），可以进行如下设置： ```{r, include=FALSE} knitr::opts_chunk$set( comment = &quot;#&gt;&quot;, echo = FALSE, fig.width = 6 ) ``` 6.2.1 在块选项中使用变量 通常情况下，块选项中会使用常数（如：fig.width = 6），但有些时候仅使用常数无法满足需求，例如应展现的图像大小可能来源于其它代码块的结果，而非一成不变，每次根据结果来手动调整就会费时又费力。 实际上，块选项可以使用任意的 R 表达式，无论简单或复杂。一种特殊的情况是将变量传递给一个块选项（注意变量本身也可被视为一个 R 表达式）。例如，为了满足图像大小变化的需求，可以在文档的一个代码块中定义关于图像宽度的变量，然后在其他代码块中使用它： ```{r} my_width &lt;- 7 ``` ```{r, fig.width=my_width} plot(cars) ``` 另外，块选项中也可以使用更为复杂的函数，例如可以使用 if-else 语句来调整图片大小： ```{r} fig_small &lt;- FALSE # 输出更大的图片需要改为 TRUE width_small &lt;- 4 width_large &lt;- 8 ``` ```{r, fig.width=if (fig_small) width_small else width_large} plot(cars) ``` 不仅如此，还可以只在所需要的包可使用时才运行一个代码块（eval=FALSE 意味着不运行该代码）： ```{r, eval=require(&#39;leaflet&#39;)} library(leaflet) leaflet() %&gt;% addTiles() ``` 需要注意的是，require('package') 只有当这个包已安装且可使用时才会返回 TRUE，否则会返回 FALSE。 6.2.2 如何在遇到 error 的时候继续编译 在默认情况下，R Markdown 文档中代码块运行产生的错误将使程序终止。但瑕疵掩不住美玉，一次报错不妨碍整体的质量；失败是成功之母，一次报错更是珍贵的学习机会。出于种种原因，用户希望在代码块报错的时候显示错误并继续运行，可以使用块选项 error = TRUE，例如： ```{r, error=TRUE} 1 + &quot;a&quot; ``` 这样在编译 R Markdown 文档后，将在输出文档中看到如下的错误消息： Error in 1 + &quot;a&quot;: non-numeric argument to binary operator 实际上，在 R Markdown 中，默认设定为 error = FALSE，这也导致了 R 在运行代码块时，出现错误就会终止。 6.2.3 控制输出 默认情况下，knitr 会显示代码块的所有可能输出，包括源代码、提示信息（message）、警告（warning）、文本输出和图像输出等，但有时处于种种目的，只需要部分输出。本节将详细介绍如何控制各类结果的输出。 6.2.3.1 隐藏源代码、提示信息、警告、文本输出或图像输出 对于输出结果中的各类元素，可以使用相应的块选项来单独隐藏它们： 隐藏源代码： ```{r, echo=FALSE} 1 + 1 ``` 隐藏提示信息（message）： ```{r, message=FALSE} message(&quot;这个message不会显示&quot;) ``` 隐藏警告（warning）： ```{r, warning=FALSE} # 这将生成一个warning，但不会被输出 1:2 + 1:3 ``` 隐藏文本输出（也可以使用`results = FALSE`）： ```{r, results=&#39;hide&#39;} print(&quot;这个文本输出不会显示。&quot;) ``` 隐藏图形输出： ```{r, fig.show=&#39;hide&#39;} plot(cars) ``` 需要注意的是，上面的代码块会生成图形，它只是没有显示在输出中而已。 关于 knitr 的一个常见问题是如何隐藏包的加载消息。例如，在运行 library(tidyverse) 或 library(ggplot2) 时，可能会看到一些正在加载的 message。这类 message 也可以通过块选项 message = FALSE 来隐藏。 另外，还可以通过索引来有选择地显示或隐藏这些元素。下面的示例只输出了源代码的第四个和第五个表达式（注意，一个注释会被算作一个表达式）、前两个 message 以及第二个和第三个 warning： ```{r, echo=c(4, 5), message=c(1, 2), warning=2:3} # 一种生成服从N(0,1)分布的随机数的方法 x &lt;- qnorm(runif(10)) # 在实践中我们还可以使用 x &lt;- rnorm(10) x for (i in 1:5) message(&#39;这是 message &#39;, i) for (i in 1:5) warning(&#39;这是 warning &#39;, i) ``` 还可以使用负索引，例如，echo = -2 表示在输出中排除源代码的第二个表达式。 类似地，可以通过使用 fig.keep 选项 来选择显示或隐藏哪些图。例如，fig.keep = 1:2 意味着保留前两幅图。这个选项有一些快捷的方式，如 fig.keep = \"first\" 将只保留第一幅图、fig.keep = \"last\" 只保留最后的图以及 fig.keep = \"none\" 将丢弃所有的图。需要注意的是，fig.keep = \"none\" 和 fig.show = \"hide\" 这两个选项是不同的，后者将生成图像文件，只是会隐藏它们，而前者则根本不会生成图像文件。 对于 html_document 输出中的源代码块，如果不想完全省略它们（echo = FALSE），可以参考3.1.2.6节，来学习如何在页面上折叠它们，并允许报告用户通过单击展开按钮来展开它们。 6.2.3.2 隐藏代码块的所有输出 有的时候，可能想要执行一个代码块而根本不显示任何输出。与使用第 6.2.3.1 节中提到的单独选项不同，可以使用一个选项 include = FALSE 来隐藏代码块所有的输出，例如： ```{r, include=FALSE} # 任意的R代码 ``` 使用 include=FALSE 时，代码块将被运行（除非 eval=FALSE），但输出将被完全隐藏，报告用户将看不到任何的源代码、提示信息、警告、文本输出或图像输出等。 6.2.3.3 将文本输出压缩到源代码块中 在 R Markdown 报告中，输出结果中的文本输出部分和源代码部分之间会存在间隔。如果想去除这些间隔，可以考虑使用块选项 collapse = TRUE 将文本输出压缩到源代码块中。collapse = TRUE 时的输出如下所示： 1 + 1 ## [1] 2 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 若没有设定 collapse = TRUE（默认为FALSE），则会变成： 1 + 1 ## [1] 2 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 6.2.3.4 将文本输出调整为原始的 Markdown 形式 (*) 默认情况下，代码块的文本输出将逐字输出，并添加两个前导符号 ##（见第 6.2.5 节）。由于 knitr 将文本放在单独的代码块中，所以文本是逐字的。例如，对于代码 1:5，knitr 的原始输出为： ``` ## [1] 1 2 3 4 5 ``` 有的时候，比如在批量生成报告时，用户可能不希望逐字输出文本，而是将文本输出视为 Markdown 的内容。例如，如果想写一个类似 cat('# 这是一个标题') 的节标题，但原始的输出是： ``` ## # 这是一个标题 ``` 用户往往不希望文本位于单独的代码块（或开头的##）中，而希望原始输出与传递给cat()的字符串完全一致，即： # 这是一个标题 这个问题可以通过添加块选项 results = 'asis' 来解决。这个选项告诉 knitr 不要将文本输出逐字包装成代码块，而是“原样”对待它。当想要从 R 代码动态生成内容时，这一点特别有用。例如，可以使用选项 results = 'asis' 从以下代码块生成 iris 数据的列名列表: cat(paste0(&#39;- `&#39;, names(iris), &#39;`&#39;), sep = &#39;\\n&#39;) Sepal.Length Sepal.Width Petal.Length Petal.Width Species 连字符（-）是 Markdown 中用于生成无序列表的语法，其中反引号是可选的。若没有设置 results = 'asis' 选项，则上述代码块的输出为： cat(paste0(&#39;- `&#39;, names(iris), &#39;`&#39;), sep = &#39;\\n&#39;) ## - `Sepal.Length` ## - `Sepal.Width` ## - `Petal.Length` ## - `Petal.Width` ## - `Species` 下面是一个完整的例子，展示了如何在for循环中为mtcars数据的所有列生成节标题、段落和图： --- title: 以编程的方式生成内容 --- 通过代码块选项 `results = &#39;asis&#39;`，可以将文本作为原始的 Markdown 内容写出来， 同时也可以与图片混合。 ```{r, mtcars-plots, results=&#39;asis&#39;} for (i in names(mtcars)) { cat(&#39;\\n\\n# 变量 `&#39;, i, &#39;` 的概要\\n\\n&#39;) x &lt;- mtcars[, i] if (length(unique(x)) &lt;= 6) { cat(&#39;`&#39;, i, &#39;` 是一个分类变量。\\n\\n&#39;) plot(table(x), xlab = i, ylab = &#39;频率&#39;, lwd = 10) } else { cat(&#39;连续变量 `&#39;, i, &#39;` 的直方图。\\n\\n&#39;) hist(x, xlab = i, main = &#39;&#39;) } } ``` 需要注意的是，上述示例代码中添加了过多的换行符（\\n），从而将不同的元素在 Markdown 中清晰地分开。在不同的元素之间使用过多的换行符是无害的，但是如果换行符不够，就会产生问题。例如，下面的 Markdown 文本就会产生很多的歧义： # 这是一个标题吗？ 这是一个段落还是标题的一部分呢？ ![这张图片呢？](foo.png) # 这行又是什么？ 如果产生了更多的空行（可以由cat('\\n')生成），则歧义就会消失： # 这是一个标题！ 这绝对是个段落。 ![这是一张图。](foo.png) # 这是另一个标题 cat() 函数不是唯一可以生成文本输出的函数，另一个常用的函数是 print()。但需要注意的是，print() 经常被 隐式 调用来打印对象，这就是为什么在 R 控制台（console）中输入一个对象或值后会看到输出。例如，当在 R 控制台中输入 1:5 并按下 Enter 键时，会看到输出，这是因为 R 实际上隐式地调用了 print(1:5)。经常令人感到困惑的是，不能在表达式（例如 for 循环）中直接生成输出，而如果在 R 控制台上输入对象或值，它们将被正确打印出来。这个主题非常技术性，具体细节可以参看博文“The Ghost Printer behind Top-level R Expressions”。如果对技术细节不感兴趣，只要记住这条规则即可：如果在 for 循环中没有看到输出，那么可能应该使用 print() 函数来显式地打印对象。 6.2.4 重新格式化源代码 有的时候，因个人习惯以及代码熟练度的不同，源代码格式会有所不同，甚至有些杂乱，这会加大报告用户的阅读难度（尤其是当老师或助教阅读的时候，这会直接影响作业的分数）。本节将介绍如何通过块选项，让源代码自动地“变好看”。 当设置块选项 tidy = TRUE 时， R 的源代码将被 formatR 包 (Xie 2022a)的 tidy_source() 函数重新格式化。tidy_source() 可以在几个方面重新格式化代码，比如在大多数操作符周围添加空格、适当缩进代码以及用 &lt;- 替换赋值操作符 = 。块选项 tidy.opts 可以是传递给 formatR::tidy_source() 的一个参数列表，例如： ```{r, tidy=TRUE, tidy.opts=list(arrow=TRUE, indent=2)} # 混乱的 R 代码... 1+ 1 x=1:10#有些使用者更喜欢用 &#39;&lt;-&#39; 来作为赋值操作符 if(TRUE){ print(&#39;Hello world!&#39;) # 缩进 2 个空格 } ``` 输出结果为： # 混乱的 R 代码... 1 + 1 x &lt;- 1:10 #有些使用者更喜欢用 &#39;&lt;-&#39; 来作为赋值操作符 if (TRUE) { print(&quot;Hello world!&quot;) # 缩进 2 个空格 } 第 2.5.1 节介绍了如何控制输出的宽度。如果想进一步控制源代码的宽度，则可以在设置 tidy = TRUE 时使用 width.cutoff 参数，例如： ```{r, tidy=TRUE, tidy.opts=list(width.cutoff=50)} # 一个很长的表达式 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+ 1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1 ``` 输出结果为： # 一个很长的表达式 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 更多可能的参数可以参见帮助页 ?formatR::tidy_source，也可以浏览 https://yihui.org/formatR/ 来了解这个函数的示例和局限性。 另外，还可以通过设定块选项 tidy = 'styler' 来使用 styler 包(R-styler?)重新格式化 R 代码，其中的格式化函数为 styler::style_text()。styler 包比 formatR 具有更丰富的特性。例如，它可以对齐函数参数并使用管道操作符 %&gt;%。块选项 tidy.opts 同样可以用于将附加参数传递给 styler::style_text()，例如： ```{r, tidy=&#39;styler&#39;, tidy.opts=list(strict=FALSE)} # 对齐赋值操作符 a &lt;- 1#一个变量 abc &lt;- 2#另一个变量 ``` 在默认情况下，tidy = FALSE 并且 R 代码不会被重新格式化。 6.2.5 调整文本输出中的前导符号 默认情况下，R Markdown 会在文本输出的前面插入两个符号 ##，那么这个符号能不能更改或者干脆删除呢？第 6.2.3.4 节介绍了通过在添加 results = 'asis' 选项来生成 Markdown 形式输出的方法。但如果只是想调整前导符号，而仍然想将文本放在单独的块中，则可以通过块选项 comment 来实现。如果要删除 ##，可以使用空字符串，例如： ```{r, comment=&quot;&quot;} 1:100 ``` 当然，可以使用任何其他的字符值，例如，comment = \"#&gt;\"。那么为什么 comment 选项默认为 ## 呢？这是因为 # 表示 R 中的注释，当文本输出被注释掉时，从报告中的代码块中一次性复制所有代码并自己运行它将更容易，不需要担心运行文本输出（并非 R 代码）会报错。例如，在下面的代码块中，可以复制所有四行文本，并将它们作为 R 代码正确地运行： 1 + 1 ## [1] 2 2 + 2 ## [1] 4 而如果通过 comment = \"\" 删除 ## ，通常会无法直接运行所有的代码。如下面的例子所展示的，如果直接复制这四行，就需要手动删除第二和第四行： 6.2.6 为文本输出块添加属性 (*) 6.2.7 同一张图的多种图像输出格式 6.2.8 图像的后期加工 (*) 6.2.9 输出高质量的图像 (*) 6.2.10 带有低级绘图功能的逐步绘图 (*) 6.2.11 在代码块中自定义对象的打印格式 (*) 6.2.12 选项钩子 (*) 6.3 与其他语言的结合 在 R Markdown 中，knitr 软件包除了支持 R 语言外，还支持许多其他语言。 不同语言代码块表示方式类似，只需修改代码块中三个反引号后的花括号中的第一个单词即可。例如，```{r} 中的小 r 表示该代码块为 R 代码块，而 ```{python} 是指该代码块为 Python 代码块。本节将介绍一些读者可能不太熟悉的语言。 在 knitr 中，每种语言都通过语言引擎得到支持。语言引擎本质上是一些函数，它们以源代码和块的选项作为输入，最后输出一个字符串。并通过 knitr::knit_engines 进行管理。可以使用以下方式检查现有引擎： names(knitr::knit_engines$get()) ## [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; &quot;groovy&quot; &quot;haskell&quot; ## [7] &quot;lein&quot; &quot;mysql&quot; &quot;node&quot; &quot;octave&quot; &quot;perl&quot; &quot;psql&quot; ## [13] &quot;Rscript&quot; &quot;ruby&quot; &quot;sas&quot; &quot;scala&quot; &quot;sed&quot; &quot;sh&quot; ## [19] &quot;stata&quot; &quot;zsh&quot; &quot;asis&quot; &quot;asy&quot; &quot;block&quot; &quot;block2&quot; ## [25] &quot;bslib&quot; &quot;c&quot; &quot;cat&quot; &quot;cc&quot; &quot;comment&quot; &quot;css&quot; ## [31] &quot;ditaa&quot; &quot;dot&quot; &quot;embed&quot; &quot;exec&quot; &quot;fortran&quot; &quot;fortran95&quot; ## [37] &quot;go&quot; &quot;highlight&quot; &quot;js&quot; &quot;julia&quot; &quot;python&quot; &quot;R&quot; ## [43] &quot;Rcpp&quot; &quot;sass&quot; &quot;scss&quot; &quot;sql&quot; &quot;stan&quot; &quot;targets&quot; ## [49] &quot;tikz&quot; &quot;verbatim&quot; 目前，大多数非 R 语言的代码块都是独立执行的。例如，同一文档中的所有 bash 代码块都在各自的会话中单独执行，因此后面的 bash 代码块不能使用在先前 bash 代码块中创建的变量，更改后的工作目录（通过 cd ）在其他 bash 代码块中不会一直存在。只有 R、Python 和 Julia 代码块在同一个会话中执行。并且 R 会话和 Python 会话是两个不同的会话，但是可以从另一个会话访问或操作一个会话的对象(参见15.2节)。 R Markdown权威指南 (Xie, Allaire, and Grolemund 2018) 的2.7节 展示了如何在 R Markdown 中使用 Python, Shell, SQL, Rcpp, Stan, JavaScript, CSS, Julia, C，和 Fortran 代码。这里就不做进一步介绍，本节主要重点介绍更多的语言引擎。读者可以在下面的库中找到更多的例子： https://github.com/yihui/knitr-examples （查找包含单词引擎的文件名）。 首先，通过注册一个自定义语言引擎来说明语言引擎是如何工作的。 6.3.1 注册自定义语言引擎 (*) 使用 knitr::knit engines$set() 注册一个自定义语言引擎。它接受一个函数作为输入，例如： knitr::knit_engines$set(foo = function(options) { # 源代码在options$code }) 这样就已经注册了 foo 引擎，现在读者可以使用以 ```{foo} 开头的代码块了。该引擎函数中的 options 参数是代码块的块选项列表。可以在 options$code 中以字符向量的形式访问块的源代码。例如，对于代码块： ```{foo} 1 + 1 2 + 2 ``` options 的代码元素是一个字符向量 c('1 + 1', '2 + 2')。语言引擎实际上并不需要处理计算机语言，但可以处理代码块中的任何文本。首先，来展示一个简单的引擎示例，该引擎将代码块的内容转换为大写： knitr::knit_engines$set(upper = function(options) { code &lt;- paste(options$code, collapse = &#39;\\n&#39;) if (options$eval) toupper(code) else code }) 引擎的作用是将 toupper 函数应用于代码，并以单个字符串的形式返回结果（通过 \\n 连接所有代码行）。注意 toupper() 仅在 chunk 选项 eval = TRUE 时才应用，否则返回原始字符串。 以上已经向读者们展示了如何在引擎函数中使用 eval 之类的块选项。类似地，考虑在函数体中添加 if (options$results == 'hide') return() 来隐藏 chunk 选项时的输出 results = 'hide' 。下面是一个使用 upper 引擎及其输出的示例块 ```{upper} Hello, **knitr** engines! ``` HELLO, KNITR ENGINES! 接下来，将展示一个名为 py 的另一种 python 引擎的示例19。这个引擎是通过 R 函数 system2() 调用 python 命令来实现的： knitr::knit_engines$set(py = function(options) { code &lt;- paste(options$code, collapse = &#39;\\n&#39;) out &lt;- system2( &#39;python&#39;, c(&#39;-c&#39;, shQuote(code)), stdout = TRUE ) knitr::engine_output(options, code, out) }) 为了充分理解以上引擎的功能，读者需要了解以下内容： 给定 Python 代码作为字符串（上述函数中的代码），我们可以通过命令行调用 python -c 'code' 执行代码。 那就是 system2() 所做的。并通过在 system2() 中指定 stdout = TRUE 来收集（文本）输出。 将块选项、源代码和文本输出传递给函数 knitr::engine_output() 以生成最终输出。这个函数处理常见的块选项，比如 echo = FALSE 和 results = 'hide'，所以读者不需要注意这些情况。 knitr 中的许多语言引擎都是这样定义的(例如，使用 system2() 来执行与语言对应的命令)。如果读者对技术细节感兴趣，可以在这里的 R 源代码中查看大多数语言引擎的源代码 https://github.com/yihui/knitr/blob/master/R/engine.R。 现在，可以使用新的引擎 py，例如： ```{py} print(1 + 1) ``` ## 2 如果觉得自己的版本比现有的版本更好，读者甚至可以通过 knitr::knit_engines$set() 重写现有的语言引擎。但是，通常不建议读者这样做，因为这会让熟悉现有引擎的用户感到惊讶。不过无论如何都想读者意识到这种可能性。 6.3.2 运行 Python 代码并与 Python 交互 R Markdown 和 knitr 支持 Python。要将 Python 代码块添加到 R Markdown 文档中，可以在块的头部变为```{python}，例如： ```{python} print(&quot;Hello Python!&quot;) ``` 读者可以像往常一样在 chunk 头中添加 chunk 选项，比如 echo = FALSE 或 eval = FALSE ，并且也支持使用 Python 中的 matplotlib 包绘图。 R Markdown 和 knitr 中的 Python 支持 reticulate 包 (Ushey, Allaire, and Tang 2022)，这个包的一个重要特性是它允许 Python 和 R 之间的双向通信。例如，可以在 R 会话中通过 reticulate 包中的 py 对象访问或创建 Python 变量： ```{r, setup} library(reticulate) ``` 在 Python 会话中创建一个变量 `x`: ```{python} x = [1, 2, 3] ``` 在 R 代码块中访问 Python 变量 `x`: ```{r} py$x ``` 在 Python 会话中使用 R 创建一个新变量 `y`， 并传递一个数据帧给 `y`: ```{r} py$y &lt;- head(cars) ``` 在 Python 中输出变量 `y`： ```{python} print(y) ``` 有关 reticulate 的更多信息，可以在查看它的文档 https://rstudio.github.io/reticulate/。 1 + 1 [1] 2 2 + 2 [1] 4 设置 comment = \"\" 的一个理由是，使用 R 控制台（console）的用户对其更为熟悉。在 R 控制台中，用户不会在文本输出前面看到##。如果想模仿 R 控制台的行为，可以将 comment = \"\" 和 prompt = TRUE 结合在一起使用，例如： ```{r, comment=&quot;&quot;, prompt=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` 对于曾经在 R 控制台中输入并运行过代码的用户，输出结果看起来应该相当熟悉，因为源代码中包含提示字符（prompt character） &gt; 和延续字符（continuation character） +，这就是 prompt = TRUE 的作用： &gt; 1 + 1 [1] 2 &gt; if (TRUE) { + 2 + 2 + } [1] 4 6.3.3 为文本输出块添加属性 (*) 第 3.1.2.5 节展示了一些基于块选项 class.source 样式化代码块的示例。实际上，在 knitr 中有更多类似的选项，如 class.output、class.message、class.warning 以及 class.error。这些选项可以用于将类名添加到相应的文本输出块中，例如 error = TRUE （见第 6.2.2 节）。就像在第 3.1.2.5 节中演示的那样，这些选项最常见的应用可能是使用根据类名定义的 CSS 规则对输出块进行样式化。 通常情况下，文本输出块本质上是一个单独的代码块，它的 Markdown 源代码如下所示： ```{.className} 输出行 ``` 当输出格式为 HTML 时，通常会转换为20: &lt;pre class=&quot;className&quot;&gt; &lt;code&gt;输出行&lt;/code&gt; &lt;/pre&gt; class.* 选项控制了 &lt;pre&gt; 元素中的 class 属性，而 &lt;pre&gt; 是之前提到的文本输出块的“容器”。 事实上，这个类只是 HTML 中 &lt;pre&gt; 元素可能的属性之一。一个 HTML 元素可以有许多其他属性，比如宽度、高度和样式等。块选项 attr.*，包括 attr.source、attr.output、attr.message、attr.warning 以及 attr.error，允许用户向文本输出块添加任意属性。例如，使用 attr.source = 'style=\"background: pink;\"'，可以将源代码块的背景颜色更改为粉红色，相应的代码块将是： ```{style=&quot;background: pink;&quot;} ... ``` 以及 HTML 输出会是： &lt;pre style=&quot;background: pink;&quot;&gt; ... &lt;/pre&gt; 更多的例子可以参见第 6.4.3 节。 作为一个技术性拓展，块选项 class.* 只是 attr.* 的特殊情况，例如，class.source = 'numberLines' 等价于 attr.source = '.numberLines'（注意这里的前导点），但 attr.source 可以取任意的属性值，例如 attr.source = c('.numberLines', 'startFrom=\"11\"')。 这些选项对 HTML 输出非常有用。在某些情况下，这些属性可能对其他输出格式也有用，但这种情况相对较少。这些属性需要被 Pandoc 或第三方的包支持。例如 Pandoc 中，.numberLines 属性适用于 HTML 和 LaTeX 输出；第三方的包则通常需要通过一个 Lua 过滤器，感兴趣者请参见：https://bookdown.org/yihui/rmarkdown-cookbook/lua-filters.html。 6.3.4 同一张图的多种图像输出格式 在大多数情况下，报告可能只需要一种图像格式，例如 png 或 tiff。但有些时候，一些报告需要提交多种格式的图像，这就需要进一步了解图像格式选择的原理。 图像格式由块选项 dev 控制，即渲染图像的图像设备，这个选项的取值可以为设备名（即输出格式）的向量，例如： ```{r, dev=c(&#39;png&#39;, &#39;pdf&#39;, &#39;svg&#39;, &#39;tiff&#39;)} plot(cars) ``` 输出文档中只会呈现第一种格式的图像，但其它格式的图像也会被生成。这里需要注意的是，在默认情况下，图像文件在输出文档呈现后会立即被删除，如要保存这些文件，请参见7.1.5节。 6.3.5 图像的后期加工 (*) 有的时候，可能会需要对已有的图像进行后期加工，从而实现简单的“PS”功能，这一需求可以通过块选项 fig.process 来实现。需要传递给该选项一个输入文件路径、返回已处理图像文件路径的函数。该函数可以有第二个可选参数 options，代表一个由当前块选项组成的列表。 下面的例子展示了如何使用一个功能强大的 magick包 (Ooms 2021) 来在图像中添加 R logo。首先，定义一个函数 add_logo()： install.packages(&quot;magick&quot;) add_logo = function(path, options) { # 代码块中创建的图像 img = magick::image_read(path) # R logo logo = file.path(R.home(&quot;doc&quot;), &quot;html&quot;, &quot;logo.jpg&quot;) logo = magick::image_read(logo) # 默认的重力方向为西北，用户可以通过代码块来改变它 # option magick.gravity if (is.null(g &lt;- options$magick.gravity)) g = &#39;northwest&#39; # 在图像中添加 logo img = magick::image_composite(img, logo, gravity = g) # 写入新的图像中 magick::image_write(img, path) path } 该函数会读取图像的路径，添加 R logo，并将新图像保存到原路径。在默认情况下，logo 会被添加到图像的左上角（西北方向），但用户可以通过自定义块选项 magick.gravity（这个选项名可以是任意的）来自定义位置。 下一步就是将处理函数 add_logo() 应用到代码块中，并使用块选项 fig.process = add_logo 和 magick.gravity = \"northeast\"，所以 logo 会被添加到右上角。实际输出见图 6.2。 par(mar = c(4, 4, .1, .1)) hist(faithful$eruptions, breaks = 30, main = &#39;&#39;, col = &#39;gray&#39;, border = &#39;white&#39;) 图 6.2: 通过块选项 fig.process 来给一幅图添加 R logo。 在对magick包更加熟悉后，就可以通过更有创意和有用的想法来后期加工你的图像。 下面的例子展示了 fig.process 选项的另一个应用，其中 pdf2png() 函数可以将 PDF 图像转换成 PNG 格式。第 6.2.9 节介绍了如何使用 tikz 图像设备来生成图，但该设备生成的 PDF 图不适用于非 LaTeX 的输出文档。而在设置块选项 dev = \"tikz\" 和 fig.process = pdf2png 后，就可以显示图 6.3 的 PNG 版本了。 pdf2png = function(path) { # 只对非LaTeX的输出进行转换 if (knitr::is_latex_output()) return(path) path2 = xfun::with_ext(path, &quot;png&quot;) img = magick::image_read_pdf(path) magick::image_write(img, path2, format = &quot;png&quot;) path2 } 6.3.6 输出高质量的图像 (*) 不同格式的图像往往在输出质量上有差异。rmarkdown 包为不同的输出格式设置了合理的默认图像设备。例如，对 HTML 输出格式使用 png() 设备，所以 knitr 将生成 png 绘图文件；而对 PDF 输出格式则使用 pdf() 设备。如果对默认图像设备的输出质量不满意，可以通过块选项 dev 来更改它们。knitr 支持的设备为：\"bmp\"，\"postscript\"，\"pdf\"，\"png\"，\"svg\"，\"jpeg\"，\"pictex\"，\"tiff\"，\"win.metafile\"，\"cairo_pdf\"，\"cairo_ps\"，\"quartz_pdf\"，\"quartz_png\"，\"quartz_jpeg\"，\"quartz_tiff\"，\"quartz_gif\"，\"quartz_psd\"，\"quartz_bmp\"，\"CairoJPEG\"，\"CairoPNG\"，\"CairoPS\"，\"CairoPDF\"，\"CairoSVG\"，\"CairoTIFF\"，\"Cairo_pdf\"，\"Cairo_png\"，\"Cairo_ps\"，\"Cairo_svg\"，\"svglite\"，\"ragg_png\"，以及\"tikz\"。 通常情况下，图像设备名也是函数名。更多关于图像设备的信息可以参阅 R 的帮助页面。例如，可以在 R 的控制台中输入 ?svg 来了解关于 svg 设备的细节，它包含在 R 的基础包中，所以不需要额外安装。需要注意的是，quartz_XXX 设备是基于 quartz() 函数的，并且它们仅在 macOS 上可用；CairoXXX 设备来自的 R 包 cairoDevice(R-cairoDevice?)；svglite 设备来自 svglite 包 (Wickham et al. 2022)；tikz 设备则在 tikzDevice 包 (Sharpsteen and Bracken 2020)中。如果需要使用这些包中的图像设备，必须先安装这些包。 通常，矢量图比位图质量更高，并且可以在不损失质量的情况下缩放矢量图。对于 HTML 输出，可以使用 dev = \"svg\" 或 dev = \"svglite\" 来绘制 SVG（可缩放矢量图，Scalable Vector Graphics）。需要注意的是，默认情况下 png 设备生成的图像为位图。 对于 PDF 输出，如果对图像中的字体非常挑剔，可以使用 dev = \"tikz\"，因为它提供了对 LaTeX 的原生支持，这意味着图像中的所有元素，包括文本和符号，都可以通过 LaTeX 以高质量呈现。图 6.3 展示了一个在R图像中用块选项 dev = \"tikz\" 添加 LaTeX 数学表达式的例子。 par(mar = c(4, 4, 2, .1)) curve(dnorm, -3, 3, xlab = &#39;$x$&#39;, ylab = &#39;$\\\\phi(x)$&#39;, main = &#39;The density function of $N(0, 1)$&#39;) text(-1, .2, cex = 3, col = &#39;blue&#39;, &#39;$\\\\phi(x)=\\\\frac{1}{\\\\sqrt{2\\\\pi}}e^{\\\\frac{-x^2}{2}}$&#39;) 图 6.3: 通过 tikz 设备呈现的图像。 需要注意的是，R 的基础包实际上支持数学表达式，但它们不是通过 LaTeX 呈现的（具体细节可参见 ?plotmath）。此外，还有几个高级选项可以调整 tikz 设备的排版细节（参见 ?tikzDevice::tikz）。例如，如果图像中包含多字节字符，可以设置选项： options(tikzDefaultEngine = &#39;xetex&#39;) 这是因为在处理 LaTeX 文档中的多字节字符时，xetex 通常比默认引擎 pdftex 要好。 tikz 设备主要有两个缺点。首先，它需要安装 LaTeX，但这其实并不会很麻烦（见第 2.2.2 节），虽然还需要几个 LaTeX 包，但这些包也可以通过 TinyTeX 很方便地安装： tinytex::tlmgr_install(c(&#39;pgf&#39;, &#39;preview&#39;, &#39;xcolor&#39;)) 其次，tikz 设备渲染图的速度通常要慢得多，因为这个设备会生成 LaTeX 文件，并且必须将其编译成 PDF。如果觉得代码块很耗时，可以通过块选项 cache = TRUE 来启用缓存（见第 6.5 节）。 图 6.3 实际上也使用了块选项 fig.process = pdf2png，当输出格式不是 LaTeX时，pdf2png 函数可以将 PDF 图转换为 PNG，其定义见第 6.2.8节。如果没有这一转换，可能无法在 Web 浏览器中查看该书在线版本中的 PDF 图。 6.3.7 带有低级绘图功能的逐步绘图 (*) 在 R 中，有两种类型的绘图函数可以用来画图：高级的绘图函数用于创建新图，以及低级的绘图函数用于在现有的图中添加元素，更多信息请参见R手册《An Introduction to R》的第 12 章（“Graphical procedures”）。 在默认的情况下，当使用一系列低级的绘图函数来修改以前的图像时，knitr 不会显示中间的图，只会显示所有函数执行后的最后一个图。 然而有的时候，尤其是在教学过程中，展示中间的图像是很有用的。为此，可以设置块选项 fig.keep = 'low' 来保留各低级函数更改后的图。例如，图 6.4 和图 6.5 来自一个带有块选项 fig.keep = 'low' 的单个代码块，尽管它们很像两个代码块的输出结果。不仅如此，本节还通过块选项 fig.cap=c('cars ...', '在现有的...') 给它们分配了不同的标题。 par(mar = c(4, 4, .1, .1)) plot(cars) 图 6.4: cars 数据的点图 fit = lm(dist ~ speed, data = cars) abline(fit) 图 6.5: 在现有的点图中添加一条回归线 如果想在不同的代码块中继续修改这张图，请参阅第 6.6.5 节。 6.3.8 在代码块中自定义对象的打印格式 (*) 在默认的情况下，代码块中的对象会通过 knitr::knit_print() 函数来打印，基本上就相当于 R 中的 print()，但这往往并不能满足用户的需求。有的时候用户可能希望直接输出表格，除了第 6.1 节提到的方法外，还有更便捷的方法实现。 本质上，knit_print() 函数是一个 S3 通用函数，这意味着可以通过在其上注册 S3 方法来拓展输出方式。下面的例子展示了如何通过 knitr::kable() 来自动将数据框打印成表格： --- title: 使用自定义的 `knit_print` 方法来打印数据框 --- 首先，定义一个 `knit_print` 方法，并注册它： ```{r} knit_print.data.frame = function(x, ...) { res = paste(c(&quot;&quot;, &quot;&quot;, knitr::kable(x)), collapse = &quot;\\n&quot;) knitr::asis_output(res) } registerS3method( &quot;knit_print&quot;, &quot;data.frame&quot;, knit_print.data.frame, envir = asNamespace(&quot;knitr&quot;) ) ``` 现在可以在数据框上测试这个自定义的打印方法。 需要注意的是，之后不再需要显式地调用 `knitr::kable()` 了。 ```{r} head(iris) ``` ```{r} head(mtcars) ``` 更多关于 knit_print() 函数的信息可参见 knitr 包的简介： vignette(&#39;knit_print&#39;, package = &#39;knitr&#39;) printr 包 (R-printr?)提供了一些 S3 方法来自动将 R 对象打印为表格。只需要在R代码块中输入 library(printr)，所有的方法都将自动注册。 如果觉得上述技术实现难度较大，一些 R Markdown 输出格式，如 html_document 和 pdf_document 也提供了一个选项 df_print，它允许用户自定义数据框的打印行为。例如，如果想通过 knitr::kable() 来将数据框打印为表格，可以设置选项： --- output: html_document: df_print: kable --- 有关输出格式的更多细节可参阅输出格式的帮助页（如 ?rmarkdown::html_document），可以了解 df_print 选项支持哪些输出格式，以及对应的值是什么。 事实上，还可以通过块选项 render 来完全代替打印函数 knit_print()，render 可以使用任何函数来打印对象。例如，如果想使用 pander 包来打印对象，可以设置块选项 render 为函数 pander::pander()： ```{r, render=pander::pander} head(iris) ``` 最终得到的结果见表 ?? Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa render选项给了用户完全的自由来打印 R 对象。 6.3.9 选项钩子 (*) 有时候，用户可能需要根据其他块选项的值，来动态地改变某个块选项，例如设定图像宽不小于高。实际上，可以使用对象 opts_hooks 来设置一个选项钩子（option hook）来实现这个功能。选项钩子是一个与该选项相关的函数，会在对应的块选项不是 NULL 时自动执行。这个函数将当前代码块的选项列表作为输入参数，并且会返回一个（可能是修改过的）列表。例如，对于图像宽和高的限制，可以调整fig.width选项，使它总是不小于fig.height： knitr::opts_hooks$set(fig.width = function(options) { if (options$fig.width &lt; options$fig.height) { options$fig.width = options$fig.height } options }) 因为 fig.width 永远不会是 NULL，所以这个钩子函数总是在代码块之前执行，以更新它的块选项。对于下面的代码块，如果设置了上述的选项钩子，则 fig.width 的实际值将是 6 而不是最初定义的 5： ```{r fig.width = 5, fig.height = 6} plot(1:10) ``` 另外，第 6.2.5 节的最后一个例子介绍了如何将输出格式调整成类似于 R 控制台（console）的格式，这一功能也可以用选项钩子实现，从而可以使用一个单独的块选项 console = TRUE 来代替 comment = \"\" 和 prompt = TRUE。需要注意的是，console 不是一个内置的 knitr 块选项，而是一个自定义的任意的选项名，它的默认值是 NULL。下面是一个完整的例子： ```{r, include=FALSE} knitr::opts_hooks$set(console = function(options) { if (isTRUE(options$console)) { options$comment &lt;- &#39;&#39;; options$prompt &lt;- TRUE } options }) ``` 默认输出为： ```{r} 1 + 1 if (TRUE) { 2 + 2 } ``` 设置 `console = TRUE` 时的输出为： ```{r, console=TRUE} 1 + 1 if (TRUE) { 2 + 2 } ``` 本节第三个例子介绍了如何自动向输出块中添加行号，输出块可以包括源代码块、文本输出、提示信息、警告以及报错。下面的例子使用单个的块选项 numberLines 来控制想要添加行号的输出块。首先定义相关函数： knitr::opts_hooks$set( numberLines = function(options) { attrs &lt;- paste0(&quot;attr.&quot;, options$numberLines) options[attrs] &lt;- lapply(options[attrs], c, &quot;.numberLines&quot;) options } ) knitr::opts_chunk$set( numberLines = c( &quot;source&quot;, &quot;output&quot;, &quot;message&quot;, &quot;warning&quot;, &quot;error&quot; ) ) 选项钩子 numberLines 会将属性 .numberLines 附加到输出块上，并且通过 opts_chunk$set() 来设置块选项 numberLines，从而确保选项钩子会被执行。 通过以上设置，用户可以在代码块上使用选项 numberLines 来决定哪些输出块将具有行号，例如 numberLines = c('source', 'output') 代表给源代码和文本输出添加行号；而设定 numberLines = NULL 则将完全删除行号。 除了使用选项钩子外，还可以直接设置块选项 、attr.source = '.numberLines' 来实现目的。本节介绍的选项钩子的优点是，它们只在块选项中附加属性 .numberLines，这意味着它们不会覆盖现有的块选项值，例如，下面代码块中的源代码块将被编号（使用上面的设置），并且编号会从第二行开始： ```{r, attr.source=&#39;startFrom=&quot;2&quot;&#39;} # 这行注释不会被编号 1 + 1 ``` 这等价于： ```{r, attr.source=c(&#39;startFrom=&quot;2&quot;&#39;, &#39;.numberLines&#39;} # 这行注释不会被编号 1 + 1 ``` 6.3.10 运行 Python 代码并与 Python 交互 6.3.11 通过 asis 引擎有条件地执行内容 正如其名，asis 引擎会按原样（as is）输出块的内容。使用此引擎的优点在于，用户可以有条件地包含一些内容，块的内容的显示由块选项 echo 决定。当 echo = FALSE 时，数据块将被隐藏。下面是一个简单的例子： ```{r} getRandomNumber &lt;- function() { sample(1:6, 1) } ``` ```{asis, echo = getRandomNumber() == 4} 根据 https://xkcd.com/221/, 刚生成的是一个**真**随机数! ``` 只有当条件 getRandomNumber() == 4 （随机）为真时， asis 块中的文本才会显示。 6.3.12 执行 Shell 脚本 【之后再修改】 你可以根据你的喜好，使用 bash、 sh 或 zsh 任何一种引擎运行 Shell 脚本。下面是一个带有 chunk 头 ```{bash} 的 bash 示例： ls *.Rmd | head -n 5 ## [1] &quot;01-intro.Rmd&quot; &quot;02-base.Rmd&quot; &quot;03-document.Rmd&quot; ## [4] &quot;04-working.Rmd&quot; &quot;05-interaction.Rmd&quot; 注意，bash是用 R 函数 system2() 调用的。它将忽略配置文件，例如 ~/.bash_profile 和 ~/.bash_login，其中可能定义了命令别名或修改过的环境变量(如 PATH 变量)。如果你想要这些配置文件像你使用终端时一样被执行，你可以通过引擎将参数 -l 传递给 bash。例如： ```{bash, engine.opts=&#39;-l&#39;} echo $PATH ``` 如果你想对所有 bash 块全局启用 -l 参数，你可以在文档开头的 global chunk 选项中设置为： knitr::opts_chunk$set(engine.opts = list(bash = &#39;-l&#39;)) 还可以将其他参数作为字符向量提供给 chunk 选项engine.opts，从而传递给 bash。 6.3.13 通过 cat 引擎将块内容写入文件 有时将代码块的内容写入外部文件，然后在其他代码块中使用此文件可能会很有用。当然，可以通过 writeLines() 等 R 函数来实现这一点，但问题是，当内容相对较长或包含特殊字符时，传递给 writeLines() 的字符串可能看起来很笨拙。下面是将长字符串写入文件 my-file.txt 的示例： writeLines(&quot;这是一个长字符串。它有多条线。记得要避免双引号 \\&quot;\\&quot;, 但是‘单引号’是可以的。 希望思考关于需要多少反斜杠时，不要失去理智。例如，到底是 &#39;\\t&#39;、&#39;\\\\t&#39; 还是 &#39;\\\\\\\\t&#39;?&quot;, con = &quot;my-file.txt&quot;) 自 R 4.0.0 以来，这个问题已经大大缓解了，因为 R 开始支持 r\"( )\" 中的原始字符串（参见帮助页面 ?Quotes），而且读者不需要记住所有关于特殊字符的规则。即使使用原始字符串，在代码块中显式地将长字符串写入文件仍然会让读者分心。 knitr 中的 cat 引擎为读者提供了一种在代码块中呈现文本内容或将其写入外部文件的方法，而无需考虑有关 R 字符串的所有规则（例如，当需要字面上的反斜杠时，读者需要使用双反斜杠）。 要将块内容写入文件，请在块选项 engine.opts 中指定文件路径，例如 engine.opts = list(file = 'path/to/file')。在引擎盖下，在 engine.opts 中指定的值列表将传递给该函数 base::cat() 并且 file 是 base::cat() 的参数之一。 接下来，将提供三个示例来说明 cat 引擎的用法。 6.3.13.1 写入 CSS 文件 第一种方法是在 R Markdown 文档中嵌入一个 css 代码块，以使用 CSS 样式化元素。另一种方法是通过一些 R Markdown 输出格式(如，html_document)的 CSS 选项为 Pandoc 提供一个定制的 CSS 文件。 cat 引擎可以用来从 Rmd 编写这个 CSS 文件。 下面的例子展示了如何从文档中的块生成 custom.css 文件，并将文件路径传递给 html_document 格式的 css 选项。 --- title: &quot;从代码块中创建一个 CSS 文件&quot; output: html_document: css: custom.css --- 下面的 chunck 中将写入 `custom.css`，它将在 Pandoc 转换期间使用。 ```{cat, engine.opts = list(file = &quot;custom.css&quot;)} h2 { color: blue; } ``` ## 标题会变蓝 css 代码块方法与此方法之间的唯一区别是，前一种方法将 CSS 代码写在输出文档的 &lt;body&gt; 标记内的位置（即，在代码块的位置），并且将 CSS 代码写在输出文档的 &lt;body&gt; 标记内。 后一种方法将 CSS 写入输出文档的 &lt;body&gt; 区域。输出文档中不会有任何实际的视觉差异。 6.3.13.2 在序言中包含 LaTeX 代码 在 6.1 节中，我们介绍了如何将 LaTeX 代码添加到序言中，这需要一个外部 .tex 文件。也可以从 Rmd 生成此文件，这是一个示例： --- title: &quot;从代码块中创建一个 .tex 文件&quot; author: &quot;Jane Doe&quot; classoption: twoside output: pdf_document: includes: in_header: preamble.tex --- # 它是如何运作的 将代码块写入文件 `preamble.tex` 以定义 PDF 输出文档的页眉和页脚： ```{cat, engine.opts=list(file = &#39;preamble.tex&#39;)} \\usepackage{fancyhdr} \\usepackage{lipsum} \\pagestyle{fancy} \\fancyhead[CO,CE]{This is fancy header} \\fancyfoot[CO,CE]{And this is a fancy footer} \\fancyfoot[LE,RO]{\\thepage} \\fancypagestyle{plain}{\\pagestyle{fancy}} ``` \\lipsum[1-15] # 更多随机内容 \\lipsum[16-30] 在上面的 cat 代码块中的 LaTeX 代码中，我们定义了 PDF 文档的页眉和页脚。如果我们还想在页脚中显示作者姓名，我们可以用选项engine.opts = list(file = 'preamble.tex', append = TRUE) 和 code = sprintf('\\\\fancyfoot[LO,RE]{%s}', rmarkdown::metadata$author)将作者信息附加到另一个 cat 代码块中的 preamble.tex 中。要理解这是如何工作的，请回忆一下我们在本节前面提到的：engine.opts 被传递给 base::cat()。(因此 append = TRUE 被传递给 cat())，你可以通过阅读 16.2 节来理解 chunk 选项代码。 6.3.13.3 将 YAML 数据写入文件并显示它 默认情况下，cat 代码块的内容不会显示在输出文档中。如果还想在写出它之后显示它，则将块选项 class.source 设置为语言名称。语言名称用于语法高亮显示。在下面的例子中，我们指定为 yaml 语言： ```{cat, engine.opts=list(file=&#39;demo.yml&#39;), class.source=&#39;yaml&#39;} a: aa: &quot;something&quot; bb: 1 b: aa: &quot;something else&quot; bb: 2 ``` 其输出显示在下面，并且还生成了一个文件 demo.yml。 a: aa: &quot;something&quot; bb: 1 b: aa: &quot;something else&quot; bb: 2 为了显示文件 demo.yml 确实已经生成，我们可以尝试使用 yaml 包 (Garbett et al. 2022) 将其读入 R。 xfun::tree(yaml::read_yaml(&#39;demo.yml&#39;)) ## List of 2 ## |-a:List of 2 ## | |-aa: chr &quot;something&quot; ## | |-bb: int 1 ## |-b:List of 2 ## |-aa: chr &quot;something else&quot; ## |-bb: int 2 6.3.14 运行 SAS 代码 你可以使用 sas 引擎运行 SAS (https://www.sas.com) 代码。你需要确保 SAS 可执行文件在你的环境变量 PATH 中，或者(如果你不知道 PATH 是什么意思)通过 chunk 选项 engine.path 来提供 SAS 可执行文件的完整路径，例如：engine.path = \"C:\\\\Program Files\\\\SASHome\\\\x86\\\\SASFoundation\\\\9.3\\\\sas.exe\"。下面是一个输出 “Hello World” 的示例： ```{sas} data _null_; put &#39;Hello, world!&#39;; run; ``` 6.3.15 运行 Stata 代码 如果你安装了 Stata，你可以通过 stata 引擎 Stata (https://www.stata.com) 来运行 Stata (https://www.stata.com) 代码。除非可以通过环境变量 PATH 找到 stata 可执行文件，否则你需要通过 chunk 选项 engine.path 指定到可执行文件的完整路径，例如：engine.path = \"C:/Program Files (x86)/Stata15/StataSE-64.exe\"。下面给出一个例子： ```{stata} sysuse auto summarize ``` 在 knitr 中的 stata 引擎是相当有限的。Doug Hemken 已经通过 Statamarkdown 包 中对其进行了实质性的扩展，该包可以通过Github中获得，地址为： https://github.com/Hemken/Statamarkdown。通过在线搜索 “Stata R Markdown”，你可以找到关于这个包的教程。 6.3.16 用渐近线 Asymptote 创建图形 渐近线 Asymptote (https://asymptote.sourceforge.io) 是矢量图形的强大语言。如果你已经安装了 Asymptote，那么可以使用 asy 引擎在 R Markdown 中编写并运行 Asymptote 代码(有关安装的说明，请参阅其网站)。下面是从仓库 https://github.com/vectorgraphics/asymptote 中复制的示例，其输出如图 ?? 所示： import graph3; import grid3; import palette; settings.prc = false; currentprojection=orthographic(0.8,1,2); size(500,400,IgnoreAspect); real f(pair z) {return cos(2*pi*z.x)*sin(2*pi*z.y);} surface s=surface(f,(-1/2,-1/2),(1/2,1/2),50,Spline); surface S=planeproject(unitsquare3)*s; S.colors(palette(s.map(zpart),Rainbow())); draw(S,nolight); draw(s,lightgray+opacity(0.7)); grid3(XYZgrid); 注意，对于 PDF 输出，可能需要一些额外的 LaTeX 包，否则可能会出现如下错误： ! LaTeX Error: File `ocgbase.sty&#39; not found. 如果出现这种错误，请参见 1.3 章节了解如何安装丢失的 LaTeX 包。 在上面的 asy 块中，我们使用了 settings.prc = false 的设置。如果没有此设置，当输出格式为 PDF 时，渐近线将生成交互式 3D 图形。但是，交互图形只能在 Acrobat Reader 中查看。如果使用 Acrobat Reader，则可以与图形交互。例如，你可以用鼠标旋转图 ?? 中的 3D 表面。 6.3.16.1 在 R 中生成数据并通过 Asymptote 读取 现在我们展示一个示例，其中我们首先将在 R 中生成的数据保存到 CSV 文件中(下面是一个 R 代码块)： x = seq(0, 5, l = 100) y = sin(x) writeLines(paste(x, y, sep = &#39;,&#39;), &#39;sine.csv&#39;) 然后通过 Asymptote 读取，并根据图 ?? 所示的数据绘制图表(下面是一个 asy 的代码块)： import graph; size(400,300,IgnoreAspect); settings.prc = false; // import data from csv file file in=input(&quot;sine.csv&quot;).line().csv(); real[][] a=in.dimension(0,0); a=transpose(a); // generate a path path rpath = graph(a[0],a[1]); path lpath = (1,0)--(5,1); // find intersection pair pA=intersectionpoint(rpath,lpath); // draw all draw(rpath,red); draw(lpath,dashed + blue); dot(&quot;$\\delta$&quot;,pA,NE); xaxis(&quot;$x$&quot;,BottomTop,LeftTicks); yaxis(&quot;$y$&quot;,LeftRight,RightTicks); 6.3.17 使用 Sass/SCSS 构建 HTML 页面 Sass (https://sass-lang.com) 是一种 CSS 扩展语言，它使用比普通 CSS 更灵活的方式创建 CSS 规则。 sass (Cheng et al. 2022) (Cheng et al. 2020) 包可以用来编译 Sass 到 CSS。基于 sass 包，knitr 包含两个语言引擎： sass和 scss (分别对应于 Sass 和 SCSS 语法)，将代码块编译为 CSS。下面是一个 scss 代码块，头部块为```{scss}： $font-stack: &quot;Comic Sans MS&quot;, cursive, sans-serif; $primary-color: #00FF00; .book.font-family-1 { font: 100% $font-stack; color: $primary-color; } .book.font-family-1{font:100% \"Comic Sans MS\",cursive,sans-serif;color:lime} Sass 语法与 SCSS 语法略有不同，例如: ```{sass} $font-stack: &quot;Comic Sans MS&quot;, cursive, sans-serif $primary-color: #00FF00 .book.font-family-1 font: 100% $font-stack color: $primary-color ``` 由于上面这一语句的作用，在本节的HTML版本中，当前页面的英文字体会被更改为 Comic Sans。 sass/scss 代码块是通过sass::sass()函数编译而成的。目前，块选项 engine.opts 可以定制 CSS 代码的输出样式，例如：engine.opts = list(style = \"expanded\")。默认的样式是 “compressed”。请参阅帮助页面 ?sass::sass_options 了解更多 output_style 可用的参数。 6.4 输出钩子 (*) 6.4.1 编辑源代码 6.4.2 向源代码中添加行号 6.4.3 可滚动的文本输出 6.4.4 截断文本输出 6.4.5 以HTML5格式输出图像 6.5 缓存 (*) 6.5.1 缓存耗时的代码块 在一个报告中，往往会有一些运行起来很费时且很关键的代码块（如数据预处理等）。为了节省时间，可以考虑通过块选项 cache = TRUE 来缓存该代码块的结果。当启用缓存时，如果一个代码块之前被执行过且之后没有任何变化时，knitr 将跳过这个代码块的执行，从而大大缩短编译所需的时间。而当再次修改代码块时（如修改代码或块选项），之前的缓存将自动失效，并且 knitr 将再次运行并缓存该代码块。 对于一个被缓存了的代码块，它的输出以及变量对象将从上一次的运行中自动加载，就像该代码块被再次执行了一样。当加载结果比计算结果快得多时，缓存操作通常是有用的。然而，天下没有免费的午餐，有的时候 knitr 会令缓存失效或是部分失效，如外部文件内容的改变可能没有体现在报告中等等。更多关于如何缓存，特别是缓存失效的相关知识可参见：https://yihui.org/en/2018/06/cache-invalidation/。 缓存的一个典型应用场景是保存和重新加载那些需要很长时间才能在代码块中计算的 R 对象。需要注意的是，代码需要没有任何“副产物”，否则建议不要进行缓存。例如在使用 options() 更改全局 R 选项时，产生的更改不会被缓存。 正如前文提到的，缓存依赖于代码或块选项。如果改变了任何块选项（除了 include 选项），缓存将会失效。此特性可用于解决一个常见的问题，即当代码需要读取外部数据文件时，应在更新数据文件时使缓存失效，那仅仅像下面这样简单地使用 cache = TRUE 是不够的： ```{r import-data, cache=TRUE} d &lt;- read.csv(&#39;数据.csv&#39;) ``` 必须要让 knitr 知道数据文件是否已被更改。一种方法是添加另一个块选项 cache.extra = file.mtime('数据.csv')，或者更严格的方式：cache.extra = tools::md5sum('数据.csv')。前者意味着如果文件的修改时间发生了变化，就需要使缓存失效；而后者的意思是，如果文件的内容被修改，就更新缓存。需要注意的是，cache.extra不是一个内置的 knitr 代码选项，可以为该选项使用任何其他名称，只要它不与内置选项名称冲突。 类似地，还可以将缓存与其他信息相关联，比如R的版本（cache.extra = getRversion()）、时间（cache.extra = Sys.Date()）或是操作系统（cache.extra = Sys.info()[['sysname']]），当这些条件改变时，可以使缓存正确地失效。 需要注意的是，本书不建议在文档中设置全局块选项 cache = TRUE，因为缓存可能相当棘手。相反的，可以只在个别耗时很久的代码块上启用缓存，这样并不会产生副产物。 如果对 knitr 的缓存设计不满意，还可以选择自己缓存对象，下面是一个简单的例子： if (file.exists(&#39;结果.rds&#39;)) { res = readRDS(&#39;结果.rds&#39;) } else { res = compute_it() # 一个很耗时的函数 saveRDS(res, &#39;结果.rds&#39;) } 在这一例子中，使缓存失效的唯一（也是简单的）方法就是删除文件results.rds。如果对这个简单的缓存机制感兴趣，可以使用在6.5.4节中介绍的函数xfun::cache_rds()。 6.5.2 为多种输出格式缓存代码块 当通过块选项 cache = TRUE启用缓存时，knitr 将把在代码块中生成的 R 对象写入缓存数据库，以便下次重新加载它们。缓存数据库的路径由块选项 cache.path 决定。默认情况下，R Markdown 对不同的输出格式会使用不同的缓存路径，这意味着对于每种输出格式都将完全执行一次这个（耗时的）代码块。这可能很不方便，但这种默认的行为是有原因的，即代码块的输出可能依赖于特定的输出格式。例如，生成图像，当输出格式为word_document时，图像的输出可能是像 ![text](path/to/image.png) 这样的标记代码；而或者当输出格式为 html_document 时，输出的HTML代码则类似 &lt;img src=\"path/to/image.png\" /&gt;。 当代码块没有任何副产物（如图像）时，对所有输出格式使用相同的缓存数据库是安全的，还可以节省时间。例如，当读取一个大型数据对象或运行一个比较耗时的模型时，若结果不依赖于输出格式，就可以使用相同的缓存数据库。可以通过块选项 cache.path ，例如： ```{r important-computing, cache=TRUE, cache.path=&quot;cache/&quot;} ``` 实际上，在 R Markdown 中，cache.path 的默认设置为 cache.path = \"INPUT_cache/FORMAT/\"，其中 INPUT 代表输入的文件名，FORMAT 为输出格式（如 html、latex 或 docx），这就导致了不同的输出格式对应不同的缓存路径。 6.5.3 缓存大型的对象 当设定块选项 cache = TRUE 时，缓存的对象将被延迟加载到 R 中，这意味着对象将不会从缓存数据库中读取，直到它在代码中被实际使用。当不是所有对象都在文档中稍后被使用时，这一操作可以节省一些内存。例如，如果读取了一个大型的数据对象，但在后续的分析中只使用了其中的一个子集，那么原始的数据对象将不会从缓存数据库中加载： ```{r, read-data, cache=TRUE} full &lt;- read.csv(&quot;大型数据集.csv&quot;) rows &lt;- subset(full, price &gt; 100) # 之后只使用 `rows` 数据集 ``` ```{r} plot(rows) ``` 然而，当一个对象太大时，可能会遇到这样的报错： Error in lazyLoadDBinsertVariable(vars[i], ... long vectors not supported yet: ... Execution halted 如果出现这个问题，可以尝试通过块选项 cache.lazy = FALSE 来关闭延迟加载，这样该代码块中的所有对象都将立即被加载到内存中。 6.5.4 一个更透明的缓存机制 如果在使用的过程中，觉得前文介绍的基于 knitr 的缓存机过于复杂，可以考虑使用基于函数 xfun::cache_rds() 的一个更简单的缓存机制，例如： xfun::cache_rds({ # 在这里编写你的耗时代码 }) 关于 knitr 缓存，其棘手之处在于如何决定何时使缓存失效，而使用 xfun::cache_rds() 则要清楚得多：第一次将 R 表达式传递给这个函数时，它会计算表达式并将结果保存到 .rds 文件中；下次再次运行 cache_rds() 时，它会读取 .rds 文件，并立即返回结果，而不再次计算表达式。使缓存无效的最明显的方法是删除 .rds 的文件。如果不想手动删除它，则可以用参数 rerun = TRUE 来调用 xfun::cache_rds()。 当 xfun::cache_rds() 在 knitr 源文档的一个代码块中被调用时，.rds 文件的路径由块选项 cache.path 和块标签决定。例如，对于在 Rmd 文档 input.Rmd 中带有块标签 foo 的代码块： ```{r, foo} res &lt;- xfun::cache_rds({ Sys.sleep(3) 1:10 }) ``` .rds 文件的路径格式为 input_cache/FORMAT/foo_HASH.rds，其中 FORMAT 是 Pandoc 输出格式名称（例如 html 或 latex）， HASH 是一个MD5哈希值，包含了 32 个十六进制数字（a-f 和 0-9），例如 input_cache/html/foo_7a3f22c4309d400eff95de0e8bddac71.rds。 如帮助页面 ?xfun::cache_rds 所述，通常在两种的情况下可能想要使缓存失效：（1）待求值表达式中的代码发生了变化；（2）代码使用了一个外部变量，并且该变量的值已经改变。本节接下来将解释这两种情况下缓存是如何失效的，以及如何将缓存的多个副本保存到对应于不同版本的代码中。 6.5.4.1 通过更改表达式中的代码使缓存失效 当改变 cache_rds()中的代码时（例如，从 cache_rds({x + 1}) 改为 cache_rds({x + 2})），缓存将自动失效，表达式将被重新计算。但是需要注意的是，空格或注释的变化是不重要的，或者一般来说，只要更改不影响已解析的表达式，缓存就不会失效。例如，下面传递给 cache_rds() 的两个表达式在本质上是相同的： res &lt;- xfun::cache_rds({ Sys.sleep(3); x&lt;-1:10; # 分号不影响 x+1; }) res &lt;- xfun::cache_rds({ Sys.sleep(3) x &lt;- 1:10 # 一个注释 x + 1 # 可以随意修改空格部分 }) 因此，如果对第一个表达式执行 cache_rds() ，那么第二个表达式将能够调用缓存的结果。这一特性非常有用，因为其允许在代码中进行修饰性更改，而不会使缓存失效。 如果不确定两个版本的代码是否相等，则可以尝试下面的 parse_code() 函数： parse_code &lt;- function(expr) { deparse(substitute(expr)) } # 空格或分号不影响 parse_code({x+1}) ## [1] &quot;{&quot; &quot; x + 1&quot; &quot;}&quot; parse_code({ x + 1; }) ## [1] &quot;{&quot; &quot; x + 1&quot; &quot;}&quot; # 左箭头和右箭头是等价的 identical(parse_code({x &lt;- 1}), parse_code({1 -&gt; x})) ## [1] TRUE 6.5.4.2 通过更改全局变量使缓存失效 通常情况下，表达式中有两种类型的变量：全局变量和局部变量。全局变量是在表达式外部创建的，局部变量则是在表达式内部创建的。如果表达式中全局变量的值发生了变化，那么缓存的结果和再次运行的结果之间可能会产生差异。例如，在下面的表达式中，如果 y 发生了变化，需要想要使缓存失效并重新运行表达式，否则仍然会得到根据 y 之前的值计算得到的结果： y &lt;- 2 res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }) 如果要使缓存在 y 发生变化时失效，则需要通过 hash 参数，让 cache_rds() 在决定缓存是否应该失效时知道需要考虑 y： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }, hash = list(y)) 当 hash 参数的值改变时，缓存文件名中的 32 位哈希值（如前所述）会相应地改变，导致缓存失效。这提供了一种方法来指定缓存与其他 R 对象的依赖关系。例如，如果想要使缓存依赖于 y 以及 R 的版本，可以这样指定依赖： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y }, hash = list(y, getRversion())) 或者如果想让缓存依赖于 y 以及数据文件最后一次修改的时间，可以这样做： res &lt;- xfun::cache_rds({ x &lt;- read.csv(&quot;数据.csv&quot;) x[[1]] + y }, hash = list(y, file.mtime(&quot;数据.csv&quot;))) 如果不想为 hash 参数提供全局变量的列表，则可以尝试 hash = \"auto\"，它将使 cache_rds() 自动找出所有的全局变量，并将它们作为 hash 参数的值，例如： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y + z # y 和 z 是全局变量 }, hash = &quot;auto&quot;) 这等价于： res &lt;- xfun::cache_rds({ x &lt;- 1:10 x + y + z # y 和 z 是全局变量 }, hash = list(y = y, z = z)) 当 hash = \"auto\" 时，全局变量由 codetools::findGlobals() 识别，这可能不是完全可靠的，所以如果需要完全确定哪些变量可以使缓存失效，本书建议在 hash 参数中亲自给定变量列表。 6.5.4.3 保留缓存的多个副本 由于缓存通常用于非常耗时的代码，在使其失效时应当保守一些。有的时候可能会因过早或主动地使缓存失效而后悔，因为如果再次需要一个旧版本的缓存时，则将不得不等待很长的时间才能重新完成计算。 若将 cache_rds() 中的 clean 参数设置为 FALSE，则将允许保留旧的缓存副本。也可以设置全局 R 选项 options(xfun.cache_rds.clean = FALSE) 来使其成为文档的默认行为。在默认情况下，clean = TRUE 和 cache_rds() 每次都会尝试删除旧的缓存。如果还在进行代码测试，那么设置 clean = FALSE 会很有用。例如，可以缓存一个线性模型的两个版本： model &lt;- xfun::cache_rds({ lm(dist ~ speed, data = cars) }, clean = FALSE) model &lt;- xfun::cache_rds({ lm(dist ~ speed + I(speed^2), data = cars) }, clean = FALSE) 在决定使用哪个模型之后，可以再次设置 clean = TRUE，或者删除 clean 参数（默认为 TRUE）。 6.5.4.4 与 knitr 的缓存比较 那么什么时候使用 knitr 的缓存（例如，设置块选项 cache = TRUE），什么时候在 knitr 源文档中使用 xfun::cache_rds()呢？后者最大的缺点是它不缓存副产物（而只缓存表达式的值），而 knitr 却可以。有的时候，一些副产物是有用的，比如打印的输出或图像。例如，在下面的代码中，当使用 cache_rds() 加载缓存时，文本输出和图像将会丢失，只会返回 1:10： xfun::cache_rds({ print(&quot;Hello world!&quot;) plot(cars) 1:10 }) 相比之下，对于设定选项为 cache = TRUE 的代码块，所有的内容都将被缓存： ```{r, cache=TRUE} print(&quot;Hello world!&quot;) plot(cars) 1:10 ``` 但 knitr 的缓存最大的缺点（同时也是用户最常抱怨的）是缓存可能会在不经意间失效，因为缓存由太多的因素所决定。例如，任何块选项的改变都会使缓存失效21，但有些块选项可能与计算无关。例如在下面的代码块中，改变块选项 fig.width = 6 到 fig.width = 10 会导致缓存失效，但实际上却不需要重新运行一次代码： ```{r, cache=TRUE, fig.width=6} # 这个块没有生成图像 x &lt;- rnorm(1000) mean(x) ``` 实际上，knitr 的缓存非常强大且灵活，它的行为可以通过多种方式进行调整。它的作者也经常怀疑是否值得介绍这些不太为人所知的特性，因为可能会导致用户花更多的时间来学习和理解缓存如何工作，而非运行实际的代码。 在不清楚用哪个的情况下，xfun::cache_rds() 是缓存计算结果的通用方法，它可以在任何地方使用，而 knitr 的缓存只能在 knitr 文档中使用。 6.6 其它使用 knitr 的小技巧 (*) 6.6.1 重复使用代码块 6.6.2 在创建对象之前使用它 (*) 6.6.3 提前退出编译 6.6.4 生成一个图像并在其他地方显示 6.6.5 修改之前代码块中的图像 6.6.6 保存一组块选项并重复使用它们 (*) 6.6.7 使用 knitr::knit_expand() 来生成 Rmd 源代码 6.6.8 允许代码块中的标签重复 (*) 参考文献 "],["rmarkdown-project.html", "第 7 章 使用R Markdown开展项目工作 7.1 使用 R Markdown 在工作中管理项目 7.2 使用 R Markdown 实现工作流", " 第 7 章 使用R Markdown开展项目工作 7.1 使用 R Markdown 在工作中管理项目 7.1.1 来自外部的 R 脚本 7.1.2 将外部脚本读取到一个块中 7.1.3 从外部脚本读取多个代码块 (*) 7.1.4 子文档 (*) 7.1.5 保留图像文件 7.1.6 R 代码块的工作目录 7.2 使用 R Markdown 实现工作流 7.2.1 使用 RStudio 键盘快捷键 7.2.2 R Markdown 的拼写检查 7.2.3 用 rmarkdown::render() 呈现 R Markdown 7.2.4 参数化的报告 7.2.5 自定义 Knit 按钮 (*) 7.2.6 通过 Google Drive 对 Rmd 文档进行协作 7.2.7 用 workflowr 将R Markdown项目组织到一个研究网站上 7.2.8 使用 GitHub Actions 实现自动化部署 "],["references.html", "参考文献", " 参考文献 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
