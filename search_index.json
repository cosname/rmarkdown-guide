[["-.html", "第 2 章 与其他语言的结合 2.1 注册自定义语言引擎（*）", " 第 2 章 与其他语言的结合 除R语言外， knitr 软件包在 R Markdown 中支持许多其他语言。语言名称由三个反引号后的花括号中的第一个单词表示。 例如， {r}` 中的小 `r` 表示代码块包含 R 代码，而{python}` 是指包含 Python 代码块。在本章中，我们将介绍一些你可能不熟悉的语言。 在 knitr 中，每种语言都通过语言引擎得到支持。语言引擎本质上是一些函数，它们以源代码和块的选项作为输入，并返回一个字符串作为输出。它们通过 knitr::knit_engines 进行管理。你可以通过以下方式检查现有引擎： names(knitr::knit_engines$get()) ## [1] &quot;awk&quot; &quot;bash&quot; &quot;coffee&quot; &quot;gawk&quot; &quot;groovy&quot; ## [6] &quot;haskell&quot; &quot;lein&quot; &quot;mysql&quot; &quot;node&quot; &quot;octave&quot; ## [11] &quot;perl&quot; &quot;psql&quot; &quot;Rscript&quot; &quot;ruby&quot; &quot;sas&quot; ## [16] &quot;scala&quot; &quot;sed&quot; &quot;sh&quot; &quot;stata&quot; &quot;zsh&quot; ## [21] &quot;highlight&quot; &quot;Rcpp&quot; &quot;tikz&quot; &quot;dot&quot; &quot;c&quot; ## [26] &quot;cc&quot; &quot;fortran&quot; &quot;fortran95&quot; &quot;asy&quot; &quot;cat&quot; ## [31] &quot;asis&quot; &quot;stan&quot; &quot;block&quot; &quot;block2&quot; &quot;js&quot; ## [36] &quot;css&quot; &quot;sql&quot; &quot;go&quot; &quot;python&quot; &quot;julia&quot; ## [41] &quot;sass&quot; &quot;scss&quot; &quot;R&quot; &quot;bslib&quot; &quot;theorem&quot; ## [46] &quot;lemma&quot; &quot;corollary&quot; &quot;proposition&quot; &quot;conjecture&quot; &quot;definition&quot; ## [51] &quot;example&quot; &quot;exercise&quot; &quot;proof&quot; &quot;remark&quot; &quot;solution&quot; 目前，大多数非r语言的代码块都是独立执行的。例如，同一文档中的所有 bash 代码块都在各自的会话中单独执行，因此后面的 bash 代码块不能使用在先前 bash 代码块中创建的变量，更改后的工作目录(通过 cd )不会跨不同的bash块持久存在。只有 R、Python 和 Julia 代码块在同一个会话中执行。请注意，所有的R代码块都在同一个R会话中执行，所有的Python代码块都在同一个Python会话中执行，等等。R会话和Python会话是两个不同的会话，但是可以从另一个会话访问或操作一个会话的对象(参见15.2节)。 R Markdown权威指南 (Xie, Allaire, and Grolemund 2018) 的2.7节 展示了如何在R Markdown中使用Python, Shell, SQL, Rcpp, Stan, JavaScript, CSS, Julia, C，和Fortran代码。在本章中，我们将展示更多的语言引擎，你可以在下面的库中找到更多的例子： https://github.com/yihui/knitr-examples （查找包含单词引擎的文件名）. 首先，让我们通过注册一个自定义语言引擎来揭示语言引擎是如何工作的。 2.1 注册自定义语言引擎（*） 你可以通过使用 knitr::knit engines$set() 方法注册一个自定义语言引擎。它接受一个函数作为输入，例如： knitr::knit_engines$set(foo = function(options) { # the source code is in options$code; just do whatever # you want with it }) 这样就已经注册了 foo 引擎，现在你可以使用以```{foo}开头的代码块了。 这个引擎函数中有一个options参数，它是代码块的块选项列表。你可以在options$code中以字符向量的形式访问块的源代码。例如，对于代码块： ```foo 1 + 1 2 + 2 ``` "]]
